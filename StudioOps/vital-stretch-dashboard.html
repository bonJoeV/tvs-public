<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>The Vital Stretch - Analytics Dashboard</title>
    
    <!-- Google Fonts -->
    <link href="https://fonts.googleapis.com/css2?family=Yeseva+One&display=swap" rel="stylesheet">
    
    <!-- External Libraries -->
    <script src="https://cdn.jsdelivr.net/npm/chart.js@4.4.0/dist/chart.umd.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/PapaParse/5.4.1/papaparse.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/jszip/3.10.1/jszip.min.js"></script>
    
    <style>
        /* The Vital Stretch - Dashboard Styles */
        :root {
            --primary: #013160;
            --accent: #71BED2;
            --highlight: #FBB514;
            --white: #FFFFFF;
            --gray-light: #F5F5F5;
            --gray: #E0E0E0;
            --text: #333333;
            --success: #28a745;
            --warning: #ffc107;
            --danger: #dc3545;
        }

        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Futura', 'Arial', sans-serif;
            background: linear-gradient(135deg, var(--gray-light) 0%, var(--white) 100%);
            color: var(--text);
            line-height: 1.6;
        }

        h1, h2, h3, h4, h5, h6 {
            font-family: 'Yeseva One', serif;
            color: var(--primary);
        }

        /* Header */
        .dashboard-header {
            background: var(--primary);
            color: white;
            padding: 15px 30px;
            box-shadow: 0 2px 10px rgba(1, 49, 96, 0.3);
            position: relative;
        }

        .header-content {
            position: relative;
            z-index: 1;
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 15px;
        }

        .logo {
            width: 50px;
            height: 50px;
            background: white;
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            font-weight: bold;
            color: var(--primary);
            font-size: 18px;
            box-shadow: 0 2px 8px rgba(0,0,0,0.2);
        }

        .dashboard-header h1 {
            font-size: 1.8em;
            margin-bottom: 0;
            color: white;
        }

        .tagline {
            font-size: 0.9em;
            font-style: italic;
            color: var(--highlight);
            margin-top: 5px;
            font-weight: 600;
        }

        /* Header Icons */
        .header-icons {
            position: fixed;
            top: 15px;
            right: 20px;
            display: flex;
            gap: 10px;
            z-index: 1000;
        }

        .icon-btn {
            background: white;
            color: var(--primary);
            border: 2px solid var(--accent);
            width: 50px;
            height: 50px;
            border-radius: 50%;
            cursor: pointer;
            font-size: 24px;
            display: flex;
            align-items: center;
            justify-content: center;
            box-shadow: 0 3px 10px rgba(0,0,0,0.15);
            transition: all 0.3s ease;
            position: relative;
        }

        .icon-btn:hover {
            background: var(--accent);
            color: white;
            transform: translateY(-2px);
            box-shadow: 0 5px 15px rgba(0,0,0,0.25);
        }

        .icon-btn.highlight {
            background: var(--highlight);
            border-color: var(--highlight);
            animation: pulse 2s infinite;
        }

        @keyframes pulse {
            0%, 100% { transform: scale(1); }
            50% { transform: scale(1.05); }
        }

        .icon-btn .badge {
            position: absolute;
            top: -5px;
            right: -5px;
            background: var(--danger);
            color: white;
            width: 20px;
            height: 20px;
            border-radius: 50%;
            font-size: 12px;
            font-weight: bold;
            display: flex;
            align-items: center;
            justify-content: center;
        }


        /* Modal Styles */
        .settings-modal-overlay {
            display: none;
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: rgba(0, 0, 0, 0.7);
            z-index: 10000;
            overflow-y: auto;
        }

        .settings-modal-overlay.show {
            display: flex;
            align-items: flex-start;
            justify-content: center;
            padding: 20px;
        }

        .settings-modal-content {
            background: white;
            border-radius: 15px;
            box-shadow: 0 10px 40px rgba(0,0,0,0.3);
            max-width: 1200px;
            width: 100%;
            margin: 20px auto;
        }

        .upload-modal-overlay {
            display: none;
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: rgba(0, 0, 0, 0.7);
            z-index: 10000;
            overflow-y: auto;
        }

        .upload-modal-overlay.show {
            display: flex;
            align-items: center;
            justify-content: center;
            padding: 20px;
        }

        .upload-modal-content {
            background: white;
            border-radius: 15px;
            box-shadow: 0 10px 40px rgba(0,0,0,0.3);
            max-width: 900px;
            width: 100%;
        }

        .modal-header-custom {
            background: linear-gradient(135deg, var(--primary) 0%, var(--accent) 100%);
            color: white;
            padding: 20px 25px;
            border-radius: 15px 15px 0 0;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }

        .modal-header-custom h3 {
            margin: 0;
            color: white;
            font-size: 1.5em;
        }

        .modal-close-custom {
            background: rgba(255, 255, 255, 0.2);
            border: none;
            color: white;
            font-size: 24px;
            cursor: pointer;
            width: 35px;
            height: 35px;
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            transition: all 0.3s ease;
        }

        .modal-close-custom:hover {
            background: rgba(255, 255, 255, 0.3);
            transform: rotate(90deg);
        }

        .modal-body-custom {
            padding: 25px;
        }

        .empty-state {
            text-align: center;
            padding: 60px 20px;
            color: #666;
        }

        .empty-state-icon {
            font-size: 80px;
            margin-bottom: 20px;
            opacity: 0.5;
        }

        .empty-state h2 {
            color: var(--primary);
            margin-bottom: 15px;
        }

        .empty-state p {
            font-size: 16px;
            margin-bottom: 30px;
        }

        /* Container */
        .container {
            max-width: 1400px;
            margin: 20px auto;
            padding: 0 20px;
        }

        /* Upload Section */
        .upload-section {
            background: white;
            padding: 15px;
            border-radius: 15px;
            box-shadow: 0 5px 20px rgba(0,0,0,0.1);
            margin-bottom: 20px;
            border: 2px solid var(--accent);
        }

        .upload-section h2 {
            margin-bottom: 10px;
            text-align: center;
            font-size: 1.3em;
        }

        .upload-grid {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 15px;
            margin-top: 10px;
        }

        .upload-box {
            text-align: center;
            padding: 15px;
            background: var(--gray-light);
            border-radius: 10px;
            border: 2px dashed var(--accent);
            transition: all 0.3s ease;
        }

        .upload-box:hover {
            border-color: var(--primary);
            background: white;
        }

        .upload-box h3 {
            font-size: 16px;
            margin-bottom: 10px;
        }

        .upload-btn {
            background: var(--highlight);
            color: var(--primary);
            padding: 12px 25px;
            border: none;
            border-radius: 50px;
            cursor: pointer;
            font-size: 14px;
            font-weight: bold;
            transition: all 0.3s ease;
            box-shadow: 0 4px 15px rgba(251, 181, 20, 0.3);
            display: inline-block;
        }

        .upload-btn:hover {
            background: var(--primary);
            color: var(--highlight);
            transform: translateY(-2px);
        }

        .upload-status {
            margin-top: 10px;
            font-size: 14px;
            min-height: 20px;
        }

        /* Collapsible Section */
        .collapsible-header {
            cursor: pointer;
            user-select: none;
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 5px 0;
            transition: all 0.3s ease;
        }

        .collapsible-header:hover {
            opacity: 0.8;
        }

        .collapsible-header h2 {
            margin-bottom: 0;
        }

        .collapse-icon {
            font-size: 1.5em;
            transition: transform 0.3s ease;
            display: inline-block;
        }

        .collapse-icon.collapsed {
            transform: rotate(-90deg);
        }

        .collapsible-content {
            max-height: 1000px;
            overflow: hidden;
            transition: max-height 0.3s ease, opacity 0.3s ease, margin 0.3s ease;
            opacity: 1;
        }

        .collapsible-content.collapsed {
            max-height: 0;
            opacity: 0;
            margin-top: 0 !important;
        }

        /* Modal Styles */
        .modal-overlay {
            display: none;
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: rgba(0, 0, 0, 0.7);
            z-index: 9999;
            animation: fadeIn 0.2s ease;
        }

        .modal-overlay.show {
            display: flex;
            align-items: center;
            justify-content: center;
            padding: 20px;
        }

        @keyframes fadeIn {
            from { opacity: 0; }
            to { opacity: 1; }
        }

        .modal-content {
            background: white;
            border-radius: 15px;
            box-shadow: 0 10px 40px rgba(0, 0, 0, 0.3);
            max-width: 900px;
            max-height: 90vh;
            width: 100%;
            overflow-y: auto;
            animation: slideUp 0.3s ease;
            position: relative;
        }

        @keyframes slideUp {
            from {
                transform: translateY(50px);
                opacity: 0;
            }
            to {
                transform: translateY(0);
                opacity: 1;
            }
        }

        .modal-header {
            background: linear-gradient(135deg, var(--primary) 0%, var(--accent) 100%);
            color: white;
            padding: 20px 25px;
            border-radius: 15px 15px 0 0;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }

        .modal-header h3 {
            margin: 0;
            color: white;
            font-size: 1.5em;
        }

        .modal-close {
            background: rgba(255, 255, 255, 0.2);
            border: none;
            color: white;
            font-size: 24px;
            cursor: pointer;
            width: 35px;
            height: 35px;
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            transition: all 0.3s ease;
        }

        .modal-close:hover {
            background: rgba(255, 255, 255, 0.3);
            transform: rotate(90deg);
        }

        .modal-body {
            padding: 25px;
        }

        .modal-stat {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 12px;
            background: var(--gray-light);
            border-radius: 8px;
            margin-bottom: 10px;
            border-left: 4px solid var(--accent);
        }

        .modal-stat-label {
            font-weight: 600;
            color: var(--primary);
        }

        .modal-stat-value {
            font-size: 1.2em;
            font-weight: bold;
            color: var(--text);
        }

        .modal-section {
            margin-bottom: 25px;
        }

        .modal-section h4 {
            color: var(--primary);
            margin-bottom: 15px;
            padding-bottom: 10px;
            border-bottom: 2px solid var(--accent);
        }

        .modal-table {
            width: 100%;
            border-collapse: collapse;
            margin-top: 10px;
        }

        .modal-table th {
            background: var(--primary);
            color: white;
            padding: 10px;
            text-align: left;
            font-weight: 600;
            font-size: 0.9em;
        }

        .modal-table td {
            padding: 10px;
            border-bottom: 1px solid var(--gray);
            font-size: 0.9em;
        }

        .modal-table tr:hover {
            background: var(--gray-light);
        }

        .modal-table tr:last-child td {
            border-bottom: none;
        }

        .modal-highlight {
            background: linear-gradient(135deg, rgba(251, 181, 20, 0.1) 0%, rgba(251, 181, 20, 0.05) 100%);
            padding: 15px;
            border-radius: 10px;
            border-left: 4px solid var(--highlight);
            margin-bottom: 15px;
        }

        .modal-highlight strong {
            color: var(--primary);
        }

        /* Interactive Indicator Badge */
        .chart-card {
            position: relative;
        }

        .interactive-badge {
            position: absolute;
            top: 10px;
            right: 10px;
            background: transparent;
            color: transparent;
            padding: 0;
            border-radius: 0;
            font-size: 24px;
            font-weight: normal;
            z-index: 10;
            box-shadow: none;
            display: flex;
            align-items: center;
            gap: 0;
            cursor: pointer;
            animation: wiggle 2s ease-in-out infinite;
            filter: drop-shadow(0 2px 4px rgba(0,0,0,0.2));
        }

        @keyframes wiggle {
            0%, 100% {
                transform: rotate(0deg);
            }
            10%, 30%, 50%, 70%, 90% {
                transform: rotate(-10deg);
            }
            20%, 40%, 60%, 80% {
                transform: rotate(10deg);
            }
        }

        .interactive-badge::before {
            content: 'üëÜ';
            font-size: 28px;
        }

        /* CSV Export Button */
        .csv-export-btn {
            background: var(--success);
            color: white;
            border: none;
            padding: 10px 20px;
            border-radius: 8px;
            cursor: pointer;
            font-weight: bold;
            font-size: 14px;
            transition: all 0.3s ease;
            display: inline-flex;
            align-items: center;
            gap: 8px;
            margin-top: 15px;
        }

        .csv-export-btn:hover {
            background: #218838;
            transform: translateY(-2px);
            box-shadow: 0 4px 12px rgba(40, 167, 69, 0.3);
        }

        .csv-export-btn::before {
            content: 'üì•';
            font-size: 16px;
        }

        /* Tooltip for hover data */
        .name-cell {
            cursor: help;
            position: relative;
        }

        .name-cell:hover::after {
            content: attr(data-tooltip);
            position: absolute;
            bottom: 100%;
            left: 50%;
            transform: translateX(-50%);
            background: var(--primary);
            color: white;
            padding: 8px 12px;
            border-radius: 6px;
            white-space: nowrap;
            font-size: 12px;
            z-index: 1000;
            margin-bottom: 5px;
            box-shadow: 0 4px 12px rgba(0,0,0,0.2);
        }

        .name-cell:hover::before {
            content: '';
            position: absolute;
            bottom: 100%;
            left: 50%;
            transform: translateX(-50%);
            border: 6px solid transparent;
            border-top-color: var(--primary);
            margin-bottom: -1px;
        }

        /* Active Filters Badge */
        .active-filters {
            background: var(--accent);
            color: white;
            padding: 15px 20px;
            border-radius: 10px;
            margin-bottom: 20px;
            display: none;
        }

        .active-filters.show {
            display: block;
        }

        .filter-badge {
            display: inline-block;
            background: white;
            color: var(--primary);
            padding: 5px 12px;
            border-radius: 20px;
            margin: 5px 5px 5px 0;
            font-size: 13px;
            font-weight: 600;
        }

        /* Filters */
        .filters {
            background: white;
            padding: 15px;
            border-radius: 15px;
            box-shadow: 0 5px 20px rgba(0,0,0,0.1);
            margin-bottom: 20px;
            border-top: 4px solid var(--primary);
        }

        .filters h2 {
            margin-bottom: 10px;
            font-size: 1.3em;
        }

        .filter-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
            gap: 12px;
            margin-bottom: 15px;
        }

        .filter-group label {
            display: block;
            margin-bottom: 5px;
            font-weight: 600;
            color: var(--primary);
        }
        
        /* Make Compare To label smaller */
        .filter-group label[for="comparisonPeriod"] {
            font-size: 13px;
        }

        .filter-group select,
        .filter-group input {
            width: 100%;
            padding: 10px;
            border: 2px solid var(--accent);
            border-radius: 8px;
            font-size: 14px;
        }

        .filter-group select:focus,
        .filter-group input:focus {
            outline: none;
            border-color: var(--primary);
        }

        .quick-filters {
            display: flex;
            gap: 10px;
            flex-wrap: wrap;
            margin-top: 15px;
        }

        .quick-filter-btn {
            padding: 6px 12px;
            background: var(--accent);
            color: white;
            border: none;
            border-radius: 20px;
            cursor: pointer;
            font-size: 10px;
            transition: all 0.3s ease;
        }

        .quick-filter-btn:hover {
            background: var(--primary);
            transform: translateY(-2px);
        }

        .refresh-filter-btn {
            padding: 8px 16px;
            background: var(--highlight);
            color: var(--primary);
            border: none;
            border-radius: 25px;
            cursor: pointer;
            font-size: 12px;
            font-weight: bold;
            transition: all 0.3s ease;
            box-shadow: 0 2px 8px rgba(251, 181, 20, 0.3);
            margin-top: 10px;
        }

        .refresh-filter-btn:hover {
            background: var(--primary);
            color: var(--highlight);
            transform: translateY(-2px);
        }

        .refresh-filter-btn:active {
            transform: translateY(0);
        }

        /* Footer */
        .dashboard-footer {
            background: var(--primary);
            color: white;
            text-align: center;
            padding: 15px 30px;
            margin-top: 40px;
            border-top: 3px solid var(--highlight);
        }

        .footer-content {
            display: flex;
            justify-content: center;
            align-items: center;
            gap: 20px;
            flex-wrap: wrap;
            font-size: 14px;
        }

        .footer-version {
            color: var(--accent);
            font-weight: 600;
        }

        .footer-credits {
            color: var(--highlight);
        }

        .footer-separator {
            color: var(--accent);
        }

        /* Tabs */
        .tabs {
            display: flex;
            gap: 5px;
            margin-bottom: 30px;
            flex-wrap: nowrap;
            overflow-x: auto;
        }

        .tab {
            padding: 12px 20px;
            min-width: auto;
            flex: 1;
            background: white;
            border: 2px solid var(--accent);
            border-radius: 10px;
            cursor: pointer;
            transition: all 0.3s ease;
            font-weight: 600;
            color: var(--primary);
            white-space: nowrap;
            text-align: center;
        }

        .tab:hover {
            background: var(--accent);
            color: white;
            transform: translateY(-2px);
        }

        .tab.active {
            background: var(--primary);
            color: white;
            border-color: var(--primary);
        }

        .tab-content {
            display: none;
        }

        .tab-content.active {
            display: block;
        }

        /* Metrics Grid */
        .metrics-grid {
            display: grid;
            grid-template-columns: repeat(8, 1fr);
            gap: 12px;
            margin-bottom: 30px;
        }

        .metric-card {
            background: white;
            padding: 25px;
            border-radius: 15px;
            box-shadow: 0 5px 15px rgba(0,0,0,0.1);
            border-left: 5px solid var(--accent);
            transition: all 0.3s ease;
            position: relative;
        }

        .metric-card.compact {
            padding: 11px;
            transform: scale(0.9);
            transform-origin: center;
            border-left-width: 3px;
            border-radius: 10px;
            text-align: center;
        }

        .metric-card.compact:hover {
            transform: scale(0.9) translateY(-5px);
        }

        .metric-card.compact .metric-label {
            font-size: 11px;
            margin-bottom: 5px;
        }

        .metric-card.compact .metric-value {
            font-size: 1.6em;
            margin-bottom: 0;
        }

        .metric-card.compact .metric-subtext {
            font-size: 10px;
            opacity: 0;
            max-height: 0;
            overflow: hidden;
            transition: all 0.3s ease;
            margin-top: 5px;
        }

        .metric-card.compact .comparison-details {
            opacity: 0;
            max-height: 0;
            overflow: hidden;
            transition: all 0.3s ease;
        }

        .metric-card.compact:hover .metric-subtext {
            opacity: 1;
            max-height: 50px;
        }

        .metric-card.compact:hover .comparison-details {
            opacity: 1;
            max-height: 30px;
        }

        .metric-card:hover {
            transform: translateY(-5px);
            box-shadow: 0 8px 25px rgba(0,0,0,0.15);
        }

        .metric-card.warning {
            border-left-color: var(--warning);
        }

        .metric-card.danger {
            border-left-color: var(--danger);
        }

        .metric-card.success {
            border-left-color: var(--success);
        }

        .metric-label {
            color: var(--primary);
            font-size: 14px;
            font-weight: 600;
            text-transform: uppercase;
            margin-bottom: 10px;
        }

        .metric-value {
            font-size: 2.2em;
            font-weight: bold;
            color: var(--primary);
            margin-bottom: 5px;
            font-family: 'Yeseva One', serif;
            word-break: break-word;
            line-height: 1.2;
        }

        .metric-subtext {
            color: var(--accent);
            font-size: 13px;
        }

        /* Charts */
        .charts-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(400px, 1fr));
            gap: 25px;
            margin-bottom: 30px;
        }

        .chart-container {
            background: white;
            padding: 25px;
            border-radius: 15px;
            box-shadow: 0 5px 15px rgba(0,0,0,0.1);
            position: relative;
        }

        .chart-container.full-width {
            grid-column: 1 / -1;
        }

        .chart-container h2, .chart-container h3 {
            margin-bottom: 20px;
            font-size: 1.3em;
        }

        .chart-wrapper {
            position: relative;
            height: 300px;
        }

        /* Tables */
        .table-container {
            background: white;
            padding: 25px;
            border-radius: 15px;
            box-shadow: 0 5px 15px rgba(0,0,0,0.1);
            margin-bottom: 30px;
            overflow-x: auto;
        }

        table {
            width: 100%;
            border-collapse: collapse;
            margin-top: 15px;
        }

        thead {
            background: var(--primary);
            color: white;
        }

        th {
            padding: 15px;
            text-align: left;
            font-weight: 600;
            border-bottom: 3px solid var(--highlight);
        }

        td {
            padding: 12px 15px;
            border-bottom: 1px solid var(--gray);
        }

        tbody tr:hover {
            background: var(--gray-light);
        }

        /* Alerts */
        .alert {
            padding: 20px;
            margin-bottom: 20px;
            border-radius: 10px;
            border-left: 5px solid;
        }

        .alert.success {
            background: rgba(40, 167, 69, 0.1);
            border-color: var(--success);
            color: #155724;
        }

        .alert.warning {
            background: rgba(255, 193, 7, 0.1);
            border-color: var(--warning);
            color: #856404;
        }

        .alert.danger {
            background: rgba(220, 53, 69, 0.1);
            border-color: var(--danger);
            color: #721c24;
        }

        .alert.info {
            background: rgba(113, 190, 210, 0.1);
            border-color: var(--accent);
            color: var(--primary);
        }

        .alert h4 {
            margin-bottom: 10px;
            color: inherit;
        }

        /* Progress Bars */
        .progress-bar {
            height: 30px;
            background: var(--gray-light);
            border-radius: 15px;
            overflow: hidden;
            border: 2px solid var(--gray);
            margin: 10px 0;
        }

        .progress-fill {
            height: 100%;
            background: linear-gradient(90deg, var(--accent), var(--primary));
            display: flex;
            align-items: center;
            justify-content: center;
            color: white;
            font-weight: bold;
            transition: width 0.5s ease;
        }

        .progress-fill.warning {
            background: linear-gradient(90deg, #ffc107, #ff9800);
        }

        .progress-fill.danger {
            background: linear-gradient(90deg, #dc3545, #c82333);
        }

        .progress-fill.success {
            background: linear-gradient(90deg, #28a745, #20c997);
        }

        /* Heatmap */
        .heatmap-table {
            border-collapse: collapse;
            font-size: 0.9em;
            margin: 20px 0;
            width: 100%;
        }

        .heatmap-table th {
            background: var(--primary);
            color: white;
            padding: 10px;
            text-align: center;
            font-size: 0.85em;
        }

        .heatmap-table td {
            padding: 12px;
            text-align: center;
            border: 1px solid var(--gray);
            cursor: pointer;
            transition: transform 0.2s;
            min-width: 50px;
            font-size: 0.9em;
        }

        .heatmap-table td:first-child {
            font-weight: bold;
            background: var(--gray-light);
            position: sticky;
            left: 0;
            z-index: 1;
        }

        .heatmap-table td:hover:not(:first-child) {
            transform: scale(1.05);
            box-shadow: 0 2px 8px rgba(0,0,0,0.2);
        }

        .heatmap-cell {
            border-radius: 5px;
            font-weight: 600;
        }

        .heatmap-0 { background-color: #f5f5f5; color: #999; }
        .heatmap-1 { background-color: rgba(113, 190, 210, 0.2); color: var(--primary); }
        .heatmap-2 { background-color: rgba(113, 190, 210, 0.4); color: var(--primary); }
        .heatmap-3 { background-color: rgba(113, 190, 210, 0.6); color: white; }
        .heatmap-4 { background-color: rgba(113, 190, 210, 0.8); color: white; }
        .heatmap-5 { background-color: var(--accent); color: white; }
        .heatmap-6 { background-color: var(--primary); color: white; }
        .heatmap-7 { background-color: #001a3a; color: white; }

        /* Loading Spinner */
        .spinner {
            display: inline-block;
            width: 20px;
            height: 20px;
            border: 3px solid rgba(0,0,0,.1);
            border-radius: 50%;
            border-top-color: var(--accent);
            animation: spin 1s ease-in-out infinite;
        }

        @keyframes spin {
            to { transform: rotate(360deg); }
        }

        /* Responsive */
        @media (max-width: 768px) {
            .dashboard-header {
                padding: 12px 15px;
            }

            .dashboard-header h1 {
                font-size: 1.4em;
            }

            .tagline {
                font-size: 0.8em;
            }

            .logo {
                width: 40px;
                height: 40px;
                font-size: 16px;
            }

            .header-content {
                flex-direction: row;
                gap: 10px;
            }
            
            .charts-grid {
                grid-template-columns: 1fr;
            }
            
            .filter-grid {
                grid-template-columns: 1fr;
            }

            .upload-grid {
                grid-template-columns: 1fr;
            }

            .tabs {
                overflow-x: auto;
            }

            .metrics-grid {
                grid-template-columns: repeat(2, 1fr);
            }

            .heatmap-table {
                font-size: 0.75em;
            }

            .heatmap-table td {
                padding: 8px;
                min-width: 40px;
            }

            .settings-btn {
                top: 10px;
                right: 10px;
                padding: 8px 14px;
                font-size: 12px;
            }
        }

        /* Period Comparison Styles */
        .comparison-indicator {
            display: inline-flex;
            align-items: center;
            margin-left: 10px;
            font-size: 0.9em;
            font-weight: 600;
            padding: 4px 10px;
            border-radius: 12px;
            background: rgba(0,0,0,0.05);
        }

        .comparison-indicator.positive {
            color: #28a745;
            background: rgba(40, 167, 69, 0.1);
        }

        .comparison-indicator.negative {
            color: #dc3545;
            background: rgba(220, 53, 69, 0.1);
        }

        .comparison-indicator.neutral {
            color: #666;
        }

        .comparison-arrow {
            font-size: 1.2em;
            margin-right: 4px;
        }

        .comparison-details {
            font-size: 11px;
            color: #666;
            font-style: italic;
            margin-top: 3px;
        }

        /* Journey Visualization Styles */
        .journey-flow {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin: 40px 0;
            padding: 20px;
            background: var(--gray-light);
            border-radius: 15px;
            overflow-x: auto;
        }

        .journey-stage {
            flex: 1;
            min-width: 140px;
            text-align: center;
            padding: 20px;
            background: white;
            border-radius: 12px;
            box-shadow: 0 3px 10px rgba(0,0,0,0.1);
            margin: 0 10px;
            cursor: pointer;
            transition: all 0.3s ease;
            border: 3px solid transparent;
        }

        .journey-stage:hover {
            transform: translateY(-5px);
            box-shadow: 0 5px 20px rgba(0,0,0,0.15);
            border-color: var(--accent);
        }

        .journey-stage-icon {
            font-size: 36px;
            margin-bottom: 10px;
        }

        .journey-stage-title {
            font-weight: bold;
            color: var(--primary);
            margin-bottom: 8px;
            font-size: 14px;
        }

        .journey-stage-count {
            font-size: 28px;
            font-weight: bold;
            color: var(--primary);
            margin-bottom: 0px;
            line-height: 1.2;
        }

        .journey-stage-percent {
            font-size: 16px;
            color: var(--accent);
            font-weight: 600;
            display: inline-block;
            margin-top: 4px;
        }

        .journey-arrow {
            font-size: 28px;
            color: var(--accent);
            opacity: 0.6;
            flex: 0 0 30px;
        }

        .journey-dropoff {
            position: absolute;
            top: 10px;
            right: 10px;
            background: #dc3545;
            color: white;
            padding: 4px 10px;
            border-radius: 12px;
            font-size: 11px;
            font-weight: bold;
        }

        /* Leaderboard Styles */
        .leaderboard-card {
            background: white;
            padding: 25px;
            border-radius: 15px;
            box-shadow: 0 5px 15px rgba(0,0,0,0.1);
            margin-bottom: 20px;
            transition: all 0.3s ease;
        }

        .leaderboard-card:hover {
            transform: translateY(-3px);
            box-shadow: 0 8px 25px rgba(0,0,0,0.15);
        }

        .leaderboard-rank {
            display: inline-flex;
            align-items: center;
            justify-content: center;
            width: 50px;
            height: 50px;
            border-radius: 50%;
            font-size: 24px;
            font-weight: bold;
            margin-right: 20px;
        }

        .leaderboard-rank.gold {
            background: linear-gradient(135deg, #FFD700, #FFA500);
            color: white;
            box-shadow: 0 4px 15px rgba(255, 215, 0, 0.4);
        }

        .leaderboard-rank.silver {
            background: linear-gradient(135deg, #C0C0C0, #A8A8A8);
            color: white;
            box-shadow: 0 4px 15px rgba(192, 192, 192, 0.4);
        }

        .leaderboard-rank.bronze {
            background: linear-gradient(135deg, #CD7F32, #8B4513);
            color: white;
            box-shadow: 0 4px 15px rgba(205, 127, 50, 0.4);
        }

        .leaderboard-rank.other {
            background: var(--gray-light);
            color: var(--primary);
            border: 2px solid var(--accent);
        }

        .leaderboard-content {
            display: flex;
            align-items: center;
            justify-content: space-between;
        }

        .leaderboard-info {
            flex: 1;
        }

        .leaderboard-name {
            font-size: 20px;
            font-weight: bold;
            color: var(--primary);
            margin-bottom: 8px;
        }

        .leaderboard-stats {
            display: flex;
            gap: 20px;
            flex-wrap: wrap;
        }

        .leaderboard-stat {
            font-size: 13px;
            color: #666;
        }

        .leaderboard-stat strong {
            color: var(--primary);
            font-size: 16px;
        }

        .leaderboard-score {
            text-align: center;
            padding: 15px;
            background: var(--gray-light);
            border-radius: 12px;
            min-width: 100px;
        }

        .leaderboard-score-label {
            font-size: 12px;
            color: #666;
            margin-bottom: 5px;
        }

        .leaderboard-score-value {
            font-size: 28px;
            font-weight: bold;
            color: var(--primary);
        }

        /* AI Recommendations */
        .recommendation-card {
            background: linear-gradient(135deg, rgba(113, 190, 210, 0.1), rgba(251, 181, 20, 0.1));
            border-left: 5px solid var(--accent);
            padding: 20px;
            border-radius: 12px;
            margin-bottom: 15px;
            transition: all 0.3s ease;
        }

        .recommendation-card:hover {
            transform: translateX(5px);
            box-shadow: 0 5px 15px rgba(0,0,0,0.1);
        }

        .recommendation-priority {
            display: inline-block;
            padding: 4px 12px;
            border-radius: 12px;
            font-size: 11px;
            font-weight: bold;
            margin-bottom: 10px;
        }

        .recommendation-priority.high {
            background: #dc3545;
            color: white;
        }

        .recommendation-priority.medium {
            background: #ffc107;
            color: #333;
        }

        .recommendation-priority.low {
            background: #28a745;
            color: white;
        }

        .recommendation-title {
            font-size: 18px;
            font-weight: bold;
            color: var(--primary);
            margin-bottom: 10px;
        }

        .recommendation-impact {
            display: inline-flex;
            align-items: center;
            gap: 5px;
            background: white;
            padding: 6px 12px;
            border-radius: 8px;
            font-size: 13px;
            font-weight: 600;
            color: #28a745;
            margin-top: 10px;
        }

        /* Client Segmentation Styles */
        .segmentation-container {
            background: linear-gradient(135deg, rgba(1, 49, 96, 0.03), rgba(113, 190, 210, 0.03));
            padding: 25px;
            border-radius: 15px;
            margin: 30px 0;
            border: 2px solid var(--accent);
        }

        .segmentation-header {
            text-align: center;
            margin-bottom: 30px;
        }

        .segmentation-header h2 {
            font-size: 28px;
            margin-bottom: 10px;
            color: var(--primary);
        }

        .segmentation-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(260px, 1fr));
            gap: 20px;
            margin-bottom: 20px;
        }

        .segment-card {
            background: white;
            border-radius: 12px;
            padding: 20px;
            box-shadow: 0 4px 12px rgba(0,0,0,0.08);
            transition: all 0.3s ease;
            border-left: 5px solid;
            position: relative;
            overflow: hidden;
        }

        .segment-card::before {
            content: '';
            position: absolute;
            top: 0;
            right: 0;
            width: 100px;
            height: 100px;
            border-radius: 50%;
            opacity: 0.05;
            transform: translate(30%, -30%);
        }

        .segment-card:hover {
            transform: translateY(-5px);
            box-shadow: 0 8px 20px rgba(0,0,0,0.12);
        }

        .segment-card.vip {
            border-left-color: #FFD700;
        }

        .segment-card.vip::before {
            background: #FFD700;
        }

        .segment-card.at-risk {
            border-left-color: #dc3545;
        }

        .segment-card.at-risk::before {
            background: #dc3545;
        }

        .segment-card.new-client {
            border-left-color: #28a745;
        }

        .segment-card.new-client::before {
            background: #28a745;
        }

        .segment-card.high-frequency {
            border-left-color: #007bff;
        }

        .segment-card.high-frequency::before {
            background: #007bff;
        }

        .segment-card.inactive-paid {
            border-left-color: #ff9800;
        }

        .segment-card.inactive-paid::before {
            background: #ff9800;
        }

        .segment-icon {
            font-size: 36px;
            margin-bottom: 10px;
        }

        .segment-title {
            font-size: 18px;
            font-weight: bold;
            color: var(--primary);
            margin-bottom: 5px;
        }

        .segment-description {
            font-size: 13px;
            color: #666;
            margin-bottom: 15px;
            min-height: 40px;
        }

        .segment-count {
            font-size: 42px;
            font-weight: bold;
            color: var(--primary);
            margin: 15px 0;
            text-align: center;
        }

        .segment-stats {
            background: var(--gray-light);
            padding: 12px;
            border-radius: 8px;
            margin-bottom: 15px;
            font-size: 13px;
        }

        .segment-stats-row {
            display: flex;
            justify-content: space-between;
            margin-bottom: 5px;
        }

        .segment-stats-row:last-child {
            margin-bottom: 0;
        }

        .segment-actions {
            display: flex;
            gap: 10px;
        }

        .segment-btn {
            flex: 1;
            padding: 10px 15px;
            border: none;
            border-radius: 8px;
            cursor: pointer;
            font-weight: bold;
            font-size: 13px;
            transition: all 0.3s ease;
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 5px;
        }

        .segment-btn.view {
            background: var(--accent);
            color: white;
        }

        .segment-btn.view:hover {
            background: #5AA8BB;
            transform: translateY(-2px);
        }

        .segment-btn.download {
            background: var(--success);
            color: white;
        }

        .segment-btn.download:hover {
            background: #218838;
            transform: translateY(-2px);
        }

        .segment-summary {
            background: white;
            padding: 20px;
            border-radius: 12px;
            margin-top: 20px;
            box-shadow: 0 4px 12px rgba(0,0,0,0.08);
        }

        .segment-summary h3 {
            color: var(--primary);
            margin-bottom: 15px;
        }

        .summary-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
            gap: 15px;
        }

        .summary-item {
            padding: 15px;
            background: var(--gray-light);
            border-radius: 8px;
            text-align: center;
        }

        .summary-label {
            font-size: 12px;
            color: #666;
            margin-bottom: 5px;
        }

        .summary-value {
            font-size: 24px;
            font-weight: bold;
            color: var(--primary);
        }

        @media print {
            .settings-btn,
            .upload-section,
            .filters,
            .tabs,
            .active-filters {
                display: none !important;
            }
            
            .tab-content {
                display: block !important;
            }
        }
    </style>
</head>
<body>
    <!-- Header Icons -->
    <div class="header-icons">
        <button class="icon-btn" id="uploadBtn" onclick="openUploadModal()" title="Upload Data">
            üìÅ
            <span class="badge" id="uploadBadge" style="display: none;">!</span>
        </button>
        <button class="icon-btn" onclick="openSettingsModal()" title="Settings">
            ‚öôÔ∏è
        </button>
    </div>

    <!-- Dashboard Header -->
    <div class="dashboard-header">
        <div class="header-content">
            <div class="logo">TVS</div>
            <div>
                <h1>The Vital Stretch</h1>
                <p class="tagline">Operational Insights Dashboard</p>
            </div>
        </div>
    </div>
    
    <div class="container">
        <!-- Empty State (shown when no data loaded) -->
        <div class="empty-state" id="emptyState">
            <div class="empty-state-icon">üìä</div>
            <h2>Welcome to The Vital Stretch Dashboard</h2>
            <p>Get started by uploading your Momence data files</p>
            <button class="icon-btn highlight" onclick="openUploadModal()" style="position: relative; width: auto; height: auto; padding: 15px 30px; border-radius: 25px; font-size: 16px; font-weight: 600;">
                üìÅ Upload Data to Get Started
            </button>
        </div>

        <!-- Main Content (hidden until data loaded) -->
        <div id="mainContent" style="display: none;">
        
        <!-- Active Filters Display -->
        <div class="active-filters" id="activeFiltersDisplay"></div>
        
        <!-- Filters -->
        <div class="filters" id="filtersSection" style="display: none;">
            <div class="collapsible-header" onclick="toggleCollapse('filtersContent', 'filtersIcon')">
                <h2>üîç Filters</h2>
                <span class="collapse-icon collapsed" id="filtersIcon">‚ñº</span>
            </div>
            <div class="collapsible-content collapsed" id="filtersContent">
                <div class="filter-grid">
                    <div class="filter-group">
                        <label for="monthFilter">Month</label>
                        <select id="monthFilter">
                            <option value="all">All Months</option>
                        </select>
                    </div>
                    <div class="filter-group">
                        <label for="locationFilter">Location</label>
                        <select id="locationFilter">
                            <option value="all">All Locations</option>
                        </select>
                    </div>
                    <div class="filter-group">
                        <label for="practitionerFilter">VSP</label>
                        <select id="practitionerFilter">
                            <option value="all">All VSPs</option>
                        </select>
                    </div>
                    <div class="filter-group">
                        <label for="serviceFilter">Service</label>
                        <select id="serviceFilter">
                            <option value="all">All Services</option>
                        </select>
                    </div>
                    <div class="filter-group">
                        <label for="startDate">Start Date</label>
                        <input type="date" id="startDate">
                    </div>
                    <div class="filter-group">
                        <label for="endDate">End Date</label>
                        <input type="date" id="endDate">
                    </div>
                    <div class="filter-group">
                        <label for="comparisonPeriod">üìä Compare To</label>
                        <select id="comparisonPeriod" onchange="toggleComparison()">
                            <option value="none">No Comparison</option>
                            <option value="previous">Previous Period</option>
                            <option value="lastMonth">Last Month</option>
                            <option value="lastQuarter">Last Quarter</option>
                            <option value="lastYear">Same Period Last Year</option>
                        </select>
                    </div>
                </div>
                <div class="quick-filters">
                    <button class="quick-filter-btn" onclick="setQuickFilter('7days')">Last 7 Days</button>
                    <button class="quick-filter-btn" onclick="setQuickFilter('30days')">Last 30 Days</button>
                    <button class="quick-filter-btn" onclick="setQuickFilter('90days')">Last 90 Days</button>
                    <button class="quick-filter-btn" onclick="setQuickFilter('thisMonth')">This Month</button>
                    <button class="quick-filter-btn" onclick="setQuickFilter('lastMonth')">Last Month</button>
                    <button class="quick-filter-btn" onclick="setQuickFilter('reset')">Reset All</button>
                </div>
                <div style="text-align: center;">
                    <button class="refresh-filter-btn" onclick="refreshData()">üîÑ Refresh Data</button>
                </div>
            </div>
        </div>
        
        <!-- Main Tabs -->
        <div class="tabs" id="mainTabs" style="display: none;">
            <div class="tab active" onclick="switchTab('overview')">Overview</div>
            <div class="tab" onclick="switchTab('timeline')">Timeline</div>
            <div class="tab" onclick="switchTab('practitioners')">VSP</div>
            <div class="tab" onclick="switchTab('customers')">Customers</div>
            <div class="tab" onclick="switchTab('retention')">Retention</div>
            <div class="tab" onclick="switchTab('journey')">Journey</div>
            <div class="tab" onclick="switchTab('memberships')">Memberships</div>
            <div class="tab" onclick="switchTab('cancellations')">Cancellations</div>
            <div class="tab" onclick="switchTab('schedule')">Schedule</div>
            <div class="tab" onclick="switchTab('insights')">Insights</div>
        </div>
        
        <!-- Tab Contents -->
        <div id="overview" class="tab-content active"></div>
        <div id="memberships" class="tab-content"></div>
        <div id="cancellations" class="tab-content"></div>
        <div id="journey" class="tab-content"></div>
        <div id="retention" class="tab-content"></div>
        <div id="schedule" class="tab-content"></div>
        <div id="customers" class="tab-content"></div>
        <div id="practitioners" class="tab-content"></div>
        <div id="timeline" class="tab-content"></div>
        <div id="insights" class="tab-content"></div>
        </div> <!-- end mainContent -->
    </div>
    
    <!-- Upload Modal -->
    <div class="upload-modal-overlay" id="uploadModal">
        <div class="upload-modal-content">
            <div class="modal-header-custom">
                <h3>üìÅ Upload Data Files</h3>
                <button class="modal-close-custom" onclick="closeUploadModal()">√ó</button>
            </div>
            <div class="modal-body-custom">
                <p style="text-align: center; margin-bottom: 25px; color: #666;">
                    Upload your Momence exports to start analyzing your franchise performance
                </p>
                
                <div class="upload-grid" style="grid-template-columns: 1fr 1fr 1fr; gap: 20px;">
                    <div class="upload-box">
                        <h3>üì¶ Payroll Zip</h3>
                        <p style="font-size: 12px; color: #666; margin: 10px 0;">All employee payroll files</p>
                        <input type="file" id="payrollZipFile" accept=".zip" style="display: none;">
                        <label for="payrollZipFile" class="upload-btn">Choose Zip File</label>
                        <div class="upload-status" id="payrollZipStatus"></div>
                    </div>
                    
                    <div class="upload-box">
                        <h3>üí≥ Memberships</h3>
                        <p style="font-size: 12px; color: #666; margin: 10px 0;">Sales & cancellations</p>
                        <input type="file" id="membershipsFile" accept=".csv" multiple style="display: none;">
                        <label for="membershipsFile" class="upload-btn">Choose File(s)</label>
                        <div class="upload-status" id="membershipsStatus"></div>
                    </div>
                    
                    <div class="upload-box">
                        <h3>üë• Leads</h3>
                        <p style="font-size: 12px; color: #666; margin: 10px 0;">Leads & customers</p>
                        <input type="file" id="leadsFile" accept=".csv" style="display: none;">
                        <label for="leadsFile" class="upload-btn">Choose File</label>
                        <div class="upload-status" id="leadsStatus"></div>
                    </div>
                </div>
                
                <div style="margin-top: 25px; padding: 15px; background: var(--gray-light); border-radius: 8px;">
                    <p style="font-size: 13px; color: #666; margin: 0;">
                        <strong>üí° Tip:</strong> For memberships, you can upload both sales and cancellations files together. 
                        The dashboard will automatically detect and process them correctly.
                    </p>
                </div>
            </div>
        </div>
    </div>

    <!-- Settings Modal -->
    <div class="settings-modal-overlay" id="settingsModal">
        <div class="settings-modal-content">
            <div class="modal-header-custom">
                <h3>‚öôÔ∏è Franchise Settings</h3>
                <button class="modal-close-custom" onclick="closeSettingsModal()">√ó</button>
            </div>
            <div class="modal-body-custom">
                <div style="display: grid; grid-template-columns: repeat(auto-fit, minmax(280px, 1fr)); gap: 20px; margin-bottom: 20px;">
                    
                    <!-- Timezone -->
                    <div style="background: var(--gray-light); padding: 20px; border-radius: 10px; border-left: 4px solid var(--highlight);">
                        <label style="display: block; font-weight: 600; color: var(--primary); margin-bottom: 8px;">
                            üåç Timezone
                        </label>
                        <p style="font-size: 13px; color: #666; margin-bottom: 10px;">
                            Your local timezone for date/time conversions
                        </p>
                        <select id="timezoneSelect" style="width: 100%; padding: 12px; border: 2px solid var(--accent); border-radius: 8px; font-size: 16px; font-weight: 600;">
                            <option value="America/New_York">Eastern Time</option>
                            <option value="America/Chicago" selected>Central Time</option>
                            <option value="America/Denver">Mountain Time</option>
                            <option value="Pacific/Honolulu">Hawaii Time</option>
                        </select>
                    </div>
                    
                    <!-- Franchise Fee -->
                    <div style="background: var(--gray-light); padding: 20px; border-radius: 10px; border-left: 4px solid var(--accent);">
                        <label style="display: block; font-weight: 600; color: var(--primary); margin-bottom: 8px;">
                            üè¢ Franchise Fee
                        </label>
                        <p style="font-size: 13px; color: #666; margin-bottom: 10px;">
                            Percentage of revenue paid as franchise fee
                        </p>
                        <input type="number" id="franchiseFeePercent" value="7.0" min="0" max="100" step="0.1" 
                            style="width: 100%; padding: 12px; border: 2px solid var(--accent); border-radius: 8px; font-size: 16px; font-weight: 600;">
                    </div>
                    
                    <!-- Brand Fund -->
                    <div style="background: var(--gray-light); padding: 20px; border-radius: 10px; border-left: 4px solid var(--accent);">
                        <label style="display: block; font-weight: 600; color: var(--primary); margin-bottom: 8px;">
                            üéØ Brand Fund
                        </label>
                        <p style="font-size: 13px; color: #666; margin-bottom: 10px;">
                            Percentage of revenue for brand marketing
                        </p>
                        <input type="number" id="brandFundPercent" value="1.5" min="0" max="100" step="0.1" 
                            style="width: 100%; padding: 12px; border: 2px solid var(--accent); border-radius: 8px; font-size: 16px; font-weight: 600;">
                    </div>
                    
                    <!-- CC Processing -->
                    <div style="background: var(--gray-light); padding: 20px; border-radius: 10px; border-left: 4px solid var(--accent);">
                        <label style="display: block; font-weight: 600; color: var(--primary); margin-bottom: 8px;">
                            üí≥ CC Processing Fees
                        </label>
                        <p style="font-size: 13px; color: #666; margin-bottom: 10px;">
                            Credit card processing fee percentage
                        </p>
                        <input type="number" id="ccFeesPercent" value="2.9" min="0" max="100" step="0.1" 
                            style="width: 100%; padding: 12px; border: 2px solid var(--accent); border-radius: 8px; font-size: 16px; font-weight: 600;">
                    </div>
                    
                    <!-- Monthly Paid Appointments Goal -->
                    <div style="background: var(--gray-light); padding: 20px; border-radius: 10px; border-left: 4px solid var(--primary);">
                        <label style="display: block; font-weight: 600; color: var(--primary); margin-bottom: 8px;">
                            üéØ Monthly Paid Appointments Goal
                        </label>
                        <p style="font-size: 13px; color: #666; margin-bottom: 10px;">
                            Target for paid, non-intro appointments per month
                        </p>
                        <input type="number" id="monthlyPaidApptGoal" value="300" min="0" step="1" 
                            style="width: 100%; padding: 12px; border: 2px solid var(--accent); border-radius: 8px; font-size: 16px; font-weight: 600;">
                    </div>
                    
                    <!-- Monthly Intro Appointments Goal -->
                    <div style="background: var(--gray-light); padding: 20px; border-radius: 10px; border-left: 4px solid var(--primary);">
                        <label style="display: block; font-weight: 600; color: var(--primary); margin-bottom: 8px;">
                            üÜï Monthly Intro Appointments Goal
                        </label>
                        <p style="font-size: 13px; color: #666; margin-bottom: 10px;">
                            Target for intro appointments per month
                        </p>
                        <input type="number" id="monthlyIntroApptGoal" value="36" min="0" step="1" 
                            style="width: 100%; padding: 12px; border: 2px solid var(--accent); border-radius: 8px; font-size: 16px; font-weight: 600;">
                    </div>
                    
                    <!-- Monthly Revenue Goal -->
                    <div style="background: var(--gray-light); padding: 20px; border-radius: 10px; border-left: 4px solid var(--primary);">
                        <label style="display: block; font-weight: 600; color: var(--primary); margin-bottom: 8px;">
                            üí∞ Monthly Revenue Goal
                        </label>
                        <p style="font-size: 13px; color: #666; margin-bottom: 10px;">
                            Target monthly revenue
                        </p>
                        <input type="number" id="monthlyRevenueGoal" value="50000" min="0" step="1000" 
                            style="width: 100%; padding: 12px; border: 2px solid var(--accent); border-radius: 8px; font-size: 16px; font-weight: 600;">
                    </div>
                    
                    <!-- Base Hourly Rate -->
                    <div style="background: var(--gray-light); padding: 20px; border-radius: 10px; border-left: 4px solid var(--highlight);">
                        <label style="display: block; font-weight: 600; color: var(--primary); margin-bottom: 8px;">
                            üíµ Base Hourly Rate
                        </label>
                        <p style="font-size: 13px; color: #666; margin-bottom: 10px;">
                            Hourly rate for non-appointment work
                        </p>
                        <input type="number" id="baseRateInput" value="13" min="0" step="0.50" 
                            style="width: 100%; padding: 12px; border: 2px solid var(--accent); border-radius: 8px; font-size: 16px; font-weight: 600;">
                    </div>
                </div>
                
                <div style="text-align: center; margin-top: 20px;">
                    <button onclick="saveFranchiseSettings()" class="upload-btn" style="min-width: 250px; font-size: 16px;">
                        üíæ Save Settings
                    </button>
                    <div id="franchiseSettingsStatus" style="margin-top: 15px; min-height: 20px; font-weight: 600;"></div>
                </div>
            </div>
        </div>
    </div>
    
    <!-- Data Detail Modal -->
    <div class="modal-overlay" id="dataModal" onclick="closeModal()">
        <div class="modal-content" onclick="event.stopPropagation()">
            <div class="modal-header">
                <h3 id="modalTitle">Data Details</h3>
                <button class="modal-close" onclick="closeModal()">√ó</button>
            </div>
            <div class="modal-body" id="modalBody">
                <!-- Dynamic content will be inserted here -->
            </div>
        </div>
    </div>
    
    <script>
        /* =====================================================
         * PERFORMANCE OPTIMIZATIONS IMPLEMENTED:
         * =====================================================
         * 1. Lazy Tab Loading: Tabs render only when clicked
         * 2. Memoized Date Parsing: Caches parsed dates
         * 3. Chart Helper Functions: Reduces duplicate code
         * 4. Tab State Tracking: Prevents re-rendering
         * 5. Efficient Filtering: Optimized data processing
         * ===================================================== */
        
        // Toggle collapsible sections
        function toggleCollapse(contentId, iconId) {
            const content = document.getElementById(contentId);
            const icon = document.getElementById(iconId);
            
            content.classList.toggle('collapsed');
            icon.classList.toggle('collapsed');
        }
        
        // Modal functions
        let currentModalData = null;
        
        function showModal(title, content, exportData = null) {
            document.getElementById('modalTitle').textContent = title;
            document.getElementById('modalBody').innerHTML = content;
            document.getElementById('dataModal').classList.add('show');
            document.body.style.overflow = 'hidden';
            
            // Store export data for the export button
            currentModalData = exportData;
            
            // Add export button if data is provided
            const modalHeader = document.querySelector('.modal-header');
            let exportBtn = document.getElementById('modalExportBtn');
            if (exportData && exportData.length > 0) {
                if (!exportBtn) {
                    exportBtn = document.createElement('button');
                    exportBtn.id = 'modalExportBtn';
                    exportBtn.textContent = 'üì• Export CSV';
                    exportBtn.style.cssText = 'padding: 8px 16px; background: var(--accent); color: white; border: none; border-radius: 5px; cursor: pointer; margin-left: 10px;';
                    exportBtn.onclick = exportModalData;
                    modalHeader.insertBefore(exportBtn, modalHeader.querySelector('.modal-close'));
                }
                exportBtn.style.display = 'inline-block';
            } else if (exportBtn) {
                exportBtn.style.display = 'none';
            }
        }
        
        function exportModalData() {
            if (currentModalData && currentModalData.length > 0) {
                const filename = 'modal-data-' + new Date().toISOString().split('T')[0] + '.csv';
                exportToCSV(currentModalData, filename);
            }
        }
        
        function closeModal() {
            const modal = document.getElementById('dataModal');
            modal.classList.remove('show');
            modal.style.display = ''; // Clear any inline display styles
            document.body.style.overflow = 'auto';
            currentModalData = null;
        }
        
        // Escape key to close modal
        document.addEventListener('keydown', function(e) {
            if (e.key === 'Escape') {
                closeModal();
            }
        });
        
        // CSV Export Function
        function exportToCSV(data, filename) {
            if (!data || data.length === 0) {
                alert('No data to export');
                return;
            }
            
            // Get headers from first object
            const headers = Object.keys(data[0]);
            
            // Create CSV content
            let csv = headers.join(',') + '\n';
            
            data.forEach(row => {
                const values = headers.map(header => {
                    let value = row[header];
                    
                    // Handle values with commas or quotes
                    if (typeof value === 'string' && (value.includes(',') || value.includes('"') || value.includes('\n'))) {
                        value = '"' + value.replace(/"/g, '""') + '"';
                    }
                    
                    return value;
                });
                csv += values.join(',') + '\n';
            });
            
            // Create download link
            const blob = new Blob([csv], { type: 'text/csv;charset=utf-8;' });
            const link = document.createElement('a');
            const url = URL.createObjectURL(blob);
            
            link.setAttribute('href', url);
            link.setAttribute('download', filename);
            link.style.visibility = 'hidden';
            
            document.body.appendChild(link);
            link.click();
            document.body.removeChild(link);
        }
        
        // Show LTV distribution details
        function showLTVDetails(range, customers) {
            const customersInRange = leadsData.filter(customer => {
                const ltv = parseFloat(customer.LTV) || 0;
                
                if (range === '$1-$100') return ltv > 0 && ltv <= 100;
                if (range === '$100-$250') return ltv > 100 && ltv <= 250;
                if (range === '$250-$500') return ltv > 250 && ltv <= 500;
                if (range === '$500-$1000') return ltv > 500 && ltv <= 1000;
                if (range === '$1000-$2000') return ltv > 1000 && ltv <= 2000;
                if (range === '$2000-$3000') return ltv > 2000 && ltv <= 3000;
                if (range === '$3000+') return ltv > 3000;
                
                return false;
            });
            
            // Get detailed info for each customer
            const customersWithDetails = customersInRange.map(c => {
                const customerEmail = c['E-mail'];
                const customerAppointments = filteredAppointments.filter(a => a['Customer Email'] === customerEmail);
                
                // Get latest appointment date
                let latestDate = null;
                customerAppointments.forEach(a => {
                    const apptDate = parseDate(a['Appointment Date']);
                    if (apptDate && (!latestDate || apptDate > latestDate)) {
                        latestDate = apptDate;
                    }
                });
                
                // Get practitioner counts
                const practitionerCounts = {};
                customerAppointments.forEach(a => {
                    const firstName = a['Practitioner First Name'];
                    const lastName = a['Practitioner Last Name'];
                    if (firstName && lastName) {
                        const key = `${firstName} ${lastName}`;
                        practitionerCounts[key] = (practitionerCounts[key] || 0) + 1;
                    }
                });
                
                // Format practitioners as "First L. (count)"
                const practitionerList = Object.entries(practitionerCounts)
                    .sort((a, b) => b[1] - a[1]) // Sort by count descending
                    .map(([name, count]) => {
                        const parts = name.split(' ');
                        const firstName = parts[0];
                        const lastInitial = parts[1] ? parts[1].charAt(0) + '.' : '';
                        return `${firstName} ${lastInitial} (${count})`;
                    })
                    .join(', ');
                
                return {
                    ...c,
                    latestDate: latestDate,
                    latestDateStr: latestDate ? latestDate.toLocaleDateString('en-US') : 'N/A',
                    practitionerList: practitionerList || 'N/A',
                    joinDateStr: c['Join date'] ? c['Join date'].split(',')[0] : 'N/A'
                };
            });
            
            // Sort by latest appointment date descending (most recent first)
            customersWithDetails.sort((a, b) => {
                if (!a.latestDate) return 1;
                if (!b.latestDate) return -1;
                return b.latestDate - a.latestDate;
            });
            
            const totalLTV = customersWithDetails.reduce((sum, c) => sum + (parseFloat(c.LTV) || 0), 0);
            const avgLTV = customersWithDetails.length > 0 ? totalLTV / customersWithDetails.length : 0;
            
            let tableRows = customersWithDetails.slice(0, 50).map(c => `
                <tr>
                    <td class="name-cell" data-tooltip="Joined: ${c.joinDateStr}">${c['First name'] || ''} ${c['Last name'] || ''}</td>
                    <td>${formatCurrency(parseFloat(c.LTV) || 0)}</td>
                    <td>${c.latestDateStr}</td>
                    <td>${c.practitionerList}</td>
                </tr>
            `).join('');
            
            if (customersWithDetails.length > 50) {
                tableRows += `<tr><td colspan="4" style="text-align: center; color: #666; font-style: italic;">Showing first 50 of ${customersWithDetails.length} customers</td></tr>`;
            }
            
            // Prepare CSV data
            const csvData = customersWithDetails.map(c => ({
                'Name': `${c['First name'] || ''} ${c['Last name'] || ''}`,
                'LTV': parseFloat(c.LTV) || 0,
                'Latest Visit': c.latestDateStr,
                'Join Date': c.joinDateStr,
                'Practitioners': c.practitionerList
            }));
            
            const content = `
                <div class="modal-highlight">
                    <strong>LTV Range:</strong> ${range}<br>
                    <strong>Total Customers:</strong> ${customersWithDetails.length}<br>
                    <strong>Average LTV:</strong> ${formatCurrency(avgLTV)}<br>
                    <strong>Total Revenue:</strong> ${formatCurrency(totalLTV)}
                </div>
                
                <div class="modal-section">
                    <h4>Customer Details</h4>
                    <p style="font-size: 12px; color: #999; margin: -10px 0 10px 0; font-style: italic;">‚Üì Sorted by Latest Visit (Most Recent First) | üí° Hover over names for join date</p>
                    <table class="modal-table">
                        <thead>
                            <tr>
                                <th>Name</th>
                                <th>LTV</th>
                                <th>Latest Visit</th>
                                <th>Practitioner(s)</th>
                            </tr>
                        </thead>
                        <tbody>
                            ${tableRows}
                        </tbody>
                    </table>
                    <button class="csv-export-btn" onclick='exportToCSV(${JSON.stringify(csvData)}, "ltv-distribution-${range.replace(/[^a-zA-Z0-9]/g, '-')}.csv")'>
                        Export to CSV
                    </button>
                </div>
            `;
            
            showModal(`LTV Distribution: ${range}`, content);
        }
        
        // Show visit frequency details
        function showVisitFrequencyDetails(range, count) {
            const clientVisits = {};
            const activeMemberEmails = getActiveMemberEmails();
            
            filteredAppointments.forEach(row => {
                const email = row['Customer Email'];
                if (email) {
                    clientVisits[email] = (clientVisits[email] || 0) + 1;
                }
            });
            
            let clientsInRange = [];
            Object.entries(clientVisits).forEach(([email, visits]) => {
                let inRange = false;
                // Match the keys from visitDist: '1 visit', '2-3 visits', '4-6 visits', '7-10 visits', '11+ visits'
                if (range === '1 visit' && visits === 1) inRange = true;
                else if (range === '2-3 visits' && visits >= 2 && visits <= 3) inRange = true;
                else if (range === '4-6 visits' && visits >= 4 && visits <= 6) inRange = true;
                else if (range === '7-10 visits' && visits >= 7 && visits <= 10) inRange = true;
                else if (range === '11+ visits' && visits > 10) inRange = true;
                
                if (inRange) {
                    const appointments = filteredAppointments.filter(a => a['Customer Email'] === email);
                    // Calculate revenue excluding if they are an active member
                    const customerEmail = email.toLowerCase().trim();
                    const revenue = activeMemberEmails.has(customerEmail) ? 0 : 
                        appointments.reduce((sum, a) => sum + (parseFloat(a.Revenue) || 0), 0);
                    const customerName = appointments[0]?.['Customer Name'] || 'Unknown';
                    const lastVisitDate = appointments[appointments.length - 1]?.['Appointment Date'] || 'N/A';
                    
                    clientsInRange.push({
                        email,
                        name: customerName,
                        visits,
                        revenue,
                        lastVisit: lastVisitDate,
                        lastVisitDate: parseDate(lastVisitDate)
                    });
                }
            });
            
            // Sort by revenue descending by default
            clientsInRange.sort((a, b) => b.revenue - a.revenue);
            
            const totalRevenue = clientsInRange.reduce((sum, c) => sum + c.revenue, 0);
            const avgRevenue = clientsInRange.length > 0 ? totalRevenue / clientsInRange.length : 0;
            
            // Format range display
            const rangeDisplay = range; // Use the range as-is since it's already formatted
            
            let tableRows = '';
            if (clientsInRange.length === 0) {
                tableRows = '<tr><td colspan="4" style="text-align: center; color: #999; padding: 30px;">No clients found in this range</td></tr>';
            } else {
                tableRows = clientsInRange.slice(0, 50).map(c => `
                    <tr>
                        <td>${c.name}</td>
                        <td>${c.visits}</td>
                        <td>${formatCurrency(c.revenue)}</td>
                        <td>${c.lastVisit.split(',')[0] || 'N/A'}</td>
                    </tr>
                `).join('');
                
                if (clientsInRange.length > 50) {
                    tableRows += `<tr><td colspan="4" style="text-align: center; color: #666; font-style: italic;">Showing first 50 of ${clientsInRange.length} clients</td></tr>`;
                }
            }
            
            // Prepare CSV data
            const csvData = clientsInRange.map(c => ({
                'Name': c.name,
                'Email': c.email,
                'Visits': c.visits,
                'Revenue': c.revenue,
                'Last Visit': c.lastVisit.split(',')[0] || 'N/A'
            }));
            
            const content = `
                <div class="modal-highlight">
                    <strong>Visit Range:</strong> ${rangeDisplay}<br>
                    <strong>Total Clients:</strong> ${clientsInRange.length}<br>
                    <strong>Total Revenue:</strong> ${formatCurrency(totalRevenue)}<br>
                    <strong>Average Revenue per Client:</strong> ${formatCurrency(avgRevenue)}
                </div>
                
                <div class="modal-section">
                    <h4>Client Details</h4>
                    <p style="font-size: 12px; color: #999; margin: -10px 0 10px 0; font-style: italic;">‚Üì Sorted by Revenue (Highest First)</p>
                    <table class="modal-table">
                        <thead>
                            <tr>
                                <th>Name</th>
                                <th>Visits</th>
                                <th>Revenue</th>
                                <th>Last Visit</th>
                            </tr>
                        </thead>
                        <tbody>
                            ${tableRows}
                        </tbody>
                    </table>
                    ${clientsInRange.length > 0 ? `<button class="csv-export-btn" onclick='exportToCSV(${JSON.stringify(csvData)}, "visit-frequency-${range.replace(/[^a-zA-Z0-9]/g, '-')}.csv")'>
                        Export to CSV
                    </button>` : ''}
                </div>
            `;
            
            showModal(`Visit Frequency: ${rangeDisplay}`, content);
        }
        
        // Show practitioner details
        function showPractitionerDetails(practitionerName) {
            const appointments = filteredAppointments.filter(row => {
                return `${row['Practitioner First Name']} ${row['Practitioner Last Name']}` === practitionerName;
            });
            
            const revenue = appointments.reduce((sum, a) => sum + (parseFloat(a.Revenue) || 0), 0);
            const payout = appointments.reduce((sum, a) => sum + (parseFloat(a['Total Payout']) || 0), 0);
            const uniqueClients = new Set(appointments.map(a => a['Customer Email'])).size;
            
            // Service breakdown
            const services = {};
            appointments.forEach(a => {
                const service = a.Appointment;
                if (!services[service]) {
                    services[service] = { count: 0, revenue: 0 };
                }
                services[service].count++;
                services[service].revenue += parseFloat(a.Revenue) || 0;
            });
            
            const sortedServices = Object.entries(services)
                .sort((a, b) => b[1].count - a[1].count)
                .slice(0, 10);
            
            const serviceRows = sortedServices.map(([service, data]) => `
                <tr>
                    <td>${service}</td>
                    <td>${data.count}</td>
                    <td>${formatCurrency(data.revenue)}</td>
                    <td>${formatCurrency(data.revenue / data.count)}</td>
                </tr>
            `).join('');
            
            // Prepare CSV data
            const csvData = sortedServices.map(([service, data]) => ({
                'Service': service,
                'Count': data.count,
                'Revenue': data.revenue,
                'Avg per Appt': data.revenue / data.count
            }));
            
            const content = `
                <div class="modal-highlight">
                    <strong>Practitioner:</strong> ${practitionerName}<br>
                    <strong>Total Appointments:</strong> ${appointments.length}<br>
                    <strong>Unique Clients:</strong> ${uniqueClients}<br>
                    <strong>Total Revenue:</strong> ${formatCurrency(revenue)}<br>
                    <strong>Total Payout:</strong> ${formatCurrency(payout)}<br>
                    <strong>Avg Revenue per Appointment:</strong> ${formatCurrency(revenue / appointments.length)}
                </div>
                
                <div class="modal-section">
                    <h4>Service Breakdown</h4>
                    <p style="font-size: 12px; color: #999; margin: -10px 0 10px 0; font-style: italic;">‚Üì Sorted by Appointment Count (Highest First)</p>
                    <table class="modal-table">
                        <thead>
                            <tr>
                                <th>Service</th>
                                <th>Count</th>
                                <th>Revenue</th>
                                <th>Avg per Appt</th>
                            </tr>
                        </thead>
                        <tbody>
                            ${serviceRows}
                        </tbody>
                    </table>
                    <button class="csv-export-btn" onclick='exportToCSV(${JSON.stringify(csvData)}, "practitioner-${practitionerName.replace(/[^a-zA-Z0-9]/g, '-')}.csv")'>
                        Export to CSV
                    </button>
                </div>
            `;
            
            showModal(`Practitioner: ${practitionerName}`, content);
        }
        
        // Show service details
        function showServiceDetails(serviceName) {
            const appointments = filteredAppointments.filter(row => row.Appointment === serviceName);
            
            const revenue = appointments.reduce((sum, a) => sum + (parseFloat(a.Revenue) || 0), 0);
            const uniqueClients = new Set(appointments.map(a => a['Customer Email'])).size;
            const avgRevenue = appointments.length > 0 ? revenue / appointments.length : 0;
            
            // Practitioner breakdown
            const practitioners = {};
            appointments.forEach(a => {
                const name = `${a['Practitioner First Name']} ${a['Practitioner Last Name']}`;
                if (!practitioners[name]) {
                    practitioners[name] = { count: 0, revenue: 0 };
                }
                practitioners[name].count++;
                practitioners[name].revenue += parseFloat(a.Revenue) || 0;
            });
            
            const sortedPractitioners = Object.entries(practitioners)
                .sort((a, b) => b[1].count - a[1].count);
            
            const practitionerRows = sortedPractitioners.map(([name, data]) => `
                <tr>
                    <td>${name}</td>
                    <td>${data.count}</td>
                    <td>${formatCurrency(data.revenue)}</td>
                    <td>${((data.count / appointments.length) * 100).toFixed(1)}%</td>
                </tr>
            `).join('');
            
            // Prepare CSV data
            const csvData = sortedPractitioners.map(([name, data]) => ({
                'Practitioner': name,
                'Appointments': data.count,
                'Revenue': data.revenue,
                '% of Total': ((data.count / appointments.length) * 100).toFixed(1)
            }));
            
            const content = `
                <div class="modal-highlight">
                    <strong>Service:</strong> ${serviceName}<br>
                    <strong>Total Appointments:</strong> ${appointments.length}<br>
                    <strong>Unique Clients:</strong> ${uniqueClients}<br>
                    <strong>Total Revenue:</strong> ${formatCurrency(revenue)}<br>
                    <strong>Avg Revenue per Appointment:</strong> ${formatCurrency(avgRevenue)}
                </div>
                
                <div class="modal-section">
                    <h4>Practitioner Breakdown</h4>
                    <p style="font-size: 12px; color: #999; margin: -10px 0 10px 0; font-style: italic;">‚Üì Sorted by Appointment Count (Highest First)</p>
                    <table class="modal-table">
                        <thead>
                            <tr>
                                <th>Practitioner</th>
                                <th>Appointments</th>
                                <th>Revenue</th>
                                <th>% of Total</th>
                            </tr>
                        </thead>
                        <tbody>
                            ${practitionerRows}
                        </tbody>
                    </table>
                    <button class="csv-export-btn" onclick='exportToCSV(${JSON.stringify(csvData)}, "service-${serviceName.replace(/[^a-zA-Z0-9]/g, '-')}.csv")'>
                        Export to CSV
                    </button>
                </div>
            `;
            
            showModal(`Service: ${serviceName}`, content);
        }
        
        // Show day of week details
        function showDayOfWeekDetails(dayName) {
            const dayAppointments = filteredAppointments.filter(row => {
                const date = parseDate(row['Appointment Date']);
                if (!date) return false;
                const days = ['Sunday', 'Monday', 'Tuesday', 'Wednesday', 'Thursday', 'Friday', 'Saturday'];
                return days[date.getDay()] === dayName;
            });
            
            const revenue = dayAppointments.reduce((sum, a) => sum + (parseFloat(a.Revenue) || 0), 0);
            const uniqueClients = new Set(dayAppointments.map(a => a['Customer Email'])).size;
            
            // Hour breakdown
            const hourBreakdown = {};
            dayAppointments.forEach(a => {
                const date = parseDate(a['Appointment Date']);
                if (date) {
                    const hour = date.getHours();
                    if (!hourBreakdown[hour]) {
                        hourBreakdown[hour] = { count: 0, revenue: 0 };
                    }
                    hourBreakdown[hour].count++;
                    hourBreakdown[hour].revenue += parseFloat(a.Revenue) || 0;
                }
            });
            
            const sortedHours = Object.entries(hourBreakdown)
                .sort((a, b) => b[1].count - a[1].count)
                .slice(0, 10);
            
            const hourRows = sortedHours.map(([hour, data]) => {
                const hourNum = parseInt(hour);
                const ampm = hourNum >= 12 ? 'PM' : 'AM';
                const displayHour = hourNum > 12 ? hourNum - 12 : (hourNum === 0 ? 12 : hourNum);
                return `
                    <tr>
                        <td>${displayHour}:00 ${ampm}</td>
                        <td>${data.count}</td>
                        <td>${formatCurrency(data.revenue)}</td>
                        <td>${formatCurrency(data.revenue / data.count)}</td>
                    </tr>
                `;
            }).join('');
            
            // Prepare CSV data
            const csvData = sortedHours.map(([hour, data]) => {
                const hourNum = parseInt(hour);
                const ampm = hourNum >= 12 ? 'PM' : 'AM';
                const displayHour = hourNum > 12 ? hourNum - 12 : (hourNum === 0 ? 12 : hourNum);
                return {
                    'Hour': `${displayHour}:00 ${ampm}`,
                    'Appointments': data.count,
                    'Revenue': data.revenue,
                    'Avg Revenue': data.revenue / data.count
                };
            });
            
            const content = `
                <div class="modal-highlight">
                    <strong>Day:</strong> ${dayName}<br>
                    <strong>Total Appointments:</strong> ${dayAppointments.length}<br>
                    <strong>Unique Clients:</strong> ${uniqueClients}<br>
                    <strong>Total Revenue:</strong> ${formatCurrency(revenue)}<br>
                    <strong>Avg Revenue per Appointment:</strong> ${formatCurrency(revenue / dayAppointments.length)}
                </div>
                
                <div class="modal-section">
                    <h4>Peak Hours on ${dayName}</h4>
                    <p style="font-size: 12px; color: #999; margin: -10px 0 10px 0; font-style: italic;">‚Üì Sorted by Appointment Count (Highest First)</p>
                    <table class="modal-table">
                        <thead>
                            <tr>
                                <th>Hour</th>
                                <th>Appointments</th>
                                <th>Revenue</th>
                                <th>Avg Revenue</th>
                            </tr>
                        </thead>
                        <tbody>
                            ${hourRows}
                        </tbody>
                    </table>
                    <button class="csv-export-btn" onclick='exportToCSV(${JSON.stringify(csvData)}, "${dayName.toLowerCase()}-peak-hours.csv")'>
                        Export to CSV
                    </button>
                </div>
            `;
            
            showModal(`${dayName} Performance`, content);
        }
        
        // Show specific hour details with individual appointment information
        function showHourDetails(dayName, hour) {
            const days = ['Sunday', 'Monday', 'Tuesday', 'Wednesday', 'Thursday', 'Friday', 'Saturday'];
            const dayIndex = days.indexOf(dayName);
            
            // Filter appointments for this specific day of week and hour
            const hourAppointments = filteredAppointments.filter(row => {
                const date = parseDate(row['Appointment Date']);
                if (!date) return false;
                return date.getDay() === dayIndex && date.getHours() === hour;
            });
            
            if (hourAppointments.length === 0) {
                showModal(`${dayName} ${hour}:00`, `<p>No appointments found for this time slot.</p>`);
                return;
            }
            
            const revenue = hourAppointments.reduce((sum, a) => sum + (parseFloat(a.Revenue) || 0), 0);
            const uniqueClients = new Set(hourAppointments.map(a => a['Customer Email'])).size;
            
            // Create detailed appointment list
            const appointmentRows = hourAppointments.map(appt => {
                const date = parseDate(appt['Appointment Date']);
                const dateStr = date ? date.toLocaleDateString() : 'N/A';
                const customerName = appt['Customer Name'] || 'Unknown';
                const revenue = parseFloat(appt.Revenue) || 0;
                const service = appt['Appointment'] || 'Unknown';
                const practitioner = `${appt['Practitioner First Name'] || ''} ${appt['Practitioner Last Name'] || ''}`.trim() || 'Unknown';
                
                return `
                    <tr>
                        <td>${dateStr}</td>
                        <td>${customerName}</td>
                        <td>${formatCurrency(revenue)}</td>
                        <td style="font-size: 0.85em;">${service.substring(0, 30)}${service.length > 30 ? '...' : ''}</td>
                        <td>${practitioner}</td>
                    </tr>
                `;
            }).join('');
            
            // Prepare CSV data
            const csvData = hourAppointments.map(appt => {
                const date = parseDate(appt['Appointment Date']);
                return {
                    'Date': date ? date.toLocaleDateString() : 'N/A',
                    'Customer Name': appt['Customer Name'] || 'Unknown',
                    'Customer Email': appt['Customer Email'] || 'N/A',
                    'Revenue': parseFloat(appt.Revenue) || 0,
                    'Service': appt['Appointment'] || 'Unknown',
                    'Practitioner': `${appt['Practitioner First Name'] || ''} ${appt['Practitioner Last Name'] || ''}`.trim() || 'Unknown',
                    'Duration (h)': appt['Time (h)'] || 'N/A'
                };
            });
            
            const ampm = hour >= 12 ? 'PM' : 'AM';
            const displayHour = hour > 12 ? hour - 12 : (hour === 0 ? 12 : hour);
            
            const content = `
                <div class="modal-highlight">
                    <strong>Time Slot:</strong> ${dayName}s at ${displayHour}:00 ${ampm}<br>
                    <strong>Total Appointments:</strong> ${hourAppointments.length}<br>
                    <strong>Unique Clients:</strong> ${uniqueClients}<br>
                    <strong>Total Revenue:</strong> ${formatCurrency(revenue)}<br>
                    <strong>Avg Revenue per Appointment:</strong> ${formatCurrency(revenue / hourAppointments.length)}
                </div>
                
                <div class="modal-section">
                    <h4>All Appointments at This Time</h4>
                    <p style="font-size: 12px; color: #999; margin: -10px 0 10px 0; font-style: italic;">‚Üì Showing all ${dayName} appointments at ${displayHour}:00 ${ampm}</p>
                    <table class="modal-table">
                        <thead>
                            <tr>
                                <th>Date</th>
                                <th>Customer</th>
                                <th>Revenue</th>
                                <th>Service</th>
                                <th>VSP</th>
                            </tr>
                        </thead>
                        <tbody>
                            ${appointmentRows}
                        </tbody>
                    </table>
                    <button class="csv-export-btn" onclick='exportToCSV(${JSON.stringify(csvData)}, "${dayName.toLowerCase()}-${hour}00-appointments.csv")'>
                        Export to CSV
                    </button>
                </div>
            `;
            
            showModal(`${dayName} ${displayHour}:00 ${ampm} - Appointments`, content);
        }
        
        // Show retention segment details
        function showRetentionDetails(segment, count) {
            const clientVisits = {};
            filteredAppointments.forEach(row => {
                const email = row['Customer Email'];
                if (email) {
                    clientVisits[email] = (clientVisits[email] || 0) + 1;
                }
            });
            
            let clientsInSegment = [];
            Object.entries(clientVisits).forEach(([email, visits]) => {
                const isOneTime = visits === 1;
                const isReturning = visits > 1;
                
                if ((segment === 'One-Time Visitors' && isOneTime) || 
                    (segment === 'Returning Clients' && isReturning)) {
                    const appointments = filteredAppointments.filter(a => a['Customer Email'] === email);
                    const revenue = appointments.reduce((sum, a) => sum + (parseFloat(a.Revenue) || 0), 0);
                    const customerName = appointments[0]?.['Customer Name'] || 'Unknown';
                    const firstVisit = appointments[0]?.['Appointment Date'] || 'N/A';
                    const lastVisit = appointments[appointments.length - 1]?.['Appointment Date'] || 'N/A';
                    
                    clientsInSegment.push({
                        email,
                        name: customerName,
                        visits,
                        revenue,
                        firstVisit,
                        lastVisit
                    });
                }
            });
            
            clientsInSegment.sort((a, b) => b.revenue - a.revenue);
            
            const totalRevenue = clientsInSegment.reduce((sum, c) => sum + c.revenue, 0);
            const avgRevenue = clientsInSegment.length > 0 ? totalRevenue / clientsInSegment.length : 0;
            
            let tableRows = clientsInSegment.slice(0, 50).map(c => `
                <tr>
                    <td>${c.name}</td>
                    <td>${c.email}</td>
                    <td>${c.visits}</td>
                    <td>${formatCurrency(c.revenue)}</td>
                    <td>${c.firstVisit.split(',')[0] || 'N/A'}</td>
                    <td>${c.lastVisit.split(',')[0] || 'N/A'}</td>
                </tr>
            `).join('');
            
            if (clientsInSegment.length > 50) {
                tableRows += `<tr><td colspan="6" style="text-align: center; color: #666; font-style: italic;">Showing first 50 of ${clientsInSegment.length} clients</td></tr>`;
            }
            
            // Prepare CSV data
            const csvData = clientsInSegment.map(c => ({
                'Name': c.name,
                'Email': c.email,
                'Visits': c.visits,
                'Revenue': c.revenue,
                'First Visit': c.firstVisit.split(',')[0] || 'N/A',
                'Last Visit': c.lastVisit.split(',')[0] || 'N/A'
            }));
            
            const content = `
                <div class="modal-highlight">
                    <strong>Segment:</strong> ${segment}<br>
                    <strong>Total Clients:</strong> ${clientsInSegment.length}<br>
                    <strong>Total Revenue:</strong> ${formatCurrency(totalRevenue)}<br>
                    <strong>Average Revenue per Client:</strong> ${formatCurrency(avgRevenue)}
                </div>
                
                <div class="modal-section">
                    <h4>Client Details (Sorted by Revenue)</h4>
                    <table class="modal-table">
                        <thead>
                            <tr>
                                <th>Name</th>
                                <th>Email</th>
                                <th>Visits</th>
                                <th>Revenue</th>
                                <th>First Visit</th>
                                <th>Last Visit</th>
                            </tr>
                        </thead>
                        <tbody>
                            ${tableRows}
                        </tbody>
                    </table>
                    <button class="csv-export-btn" onclick='exportToCSV(${JSON.stringify(csvData)}, "${segment.replace(/[^a-zA-Z0-9]/g, '-')}.csv")'>
                        Export to CSV
                    </button>
                </div>
            `;
            
            showModal(segment, content);
        }
        
        // Global State
        let appointmentsData = [];
        let leadsData = [];
        let membershipsData = [];
        let membershipCancellationsData = [];
        let filteredAppointments = [];
        let filteredMemberships = [];
        let filteredLeads = [];
        let filteredCancellations = [];
        let filteredTimeTracking = [];
        let allCharts = {};
        let membershipTypes = {};
        let salesByStaff = {};
        
        // Configuration
        const CONFIG = {
            currencySymbol: '$',
            dateFormat: 'en-US',
            timezone: 'America/Chicago', // Central Time
            goals: {
                monthlyRevenue: 20000,
                monthlyAppointments: 300,
                monthlyIntroAppointments: 50,
                avgRevenuePerAppt: 100
            },
            baseHourlyRate: 13.00,
            franchiseFeePercent: 7.0,
            brandFundPercent: 1.5,
            ccFeesPercent: 2.9
        };
        
        // Franchise Settings Management
        function saveFranchiseSettings() {
            const settings = {
                timezone: document.getElementById('timezoneSelect').value,
                franchiseFeePercent: parseFloat(document.getElementById('franchiseFeePercent').value),
                brandFundPercent: parseFloat(document.getElementById('brandFundPercent').value),
                ccFeesPercent: parseFloat(document.getElementById('ccFeesPercent').value),
                monthlyPaidApptGoal: parseInt(document.getElementById('monthlyPaidApptGoal').value),
                monthlyIntroApptGoal: parseInt(document.getElementById('monthlyIntroApptGoal').value),
                monthlyRevenueGoal: parseFloat(document.getElementById('monthlyRevenueGoal').value),
                baseHourlyRate: parseFloat(document.getElementById('baseRateInput').value)
            };
            
            // Validate (skip timezone as it's a string, allow 0 or positive numbers)
            for (const [key, value] of Object.entries(settings)) {
                if (key === 'timezone') continue; // Skip timezone validation
                if (isNaN(value) || value < 0) {
                    showFranchiseSettingsStatus('‚ùå Please enter valid numbers (0 or greater) for all fields', 'error');
                    return;
                }
            }
            
            // Update CONFIG
            CONFIG.timezone = settings.timezone;
            CONFIG.franchiseFeePercent = settings.franchiseFeePercent;
            CONFIG.brandFundPercent = settings.brandFundPercent;
            CONFIG.ccFeesPercent = settings.ccFeesPercent;
            CONFIG.goals.monthlyAppointments = settings.monthlyPaidApptGoal;
            CONFIG.goals.monthlyIntroAppointments = settings.monthlyIntroApptGoal;
            CONFIG.goals.monthlyRevenue = settings.monthlyRevenueGoal;
            CONFIG.baseHourlyRate = settings.baseHourlyRate;
            
            // Save to localStorage
            localStorage.setItem('vitalStretchFranchiseSettings', JSON.stringify(settings));
            
            // Show success message
            showFranchiseSettingsStatus('‚úÖ Settings saved successfully!', 'success');
            
            // Re-render tabs if data is loaded
            if (appointmentsData.length > 0) {
                renderAllTabs();
            }
        }
        
        function showFranchiseSettingsStatus(message, type) {
            const statusEl = document.getElementById('franchiseSettingsStatus');
            statusEl.textContent = message;
            statusEl.style.color = type === 'success' ? 'var(--success)' : 'var(--danger)';
            
            setTimeout(() => {
                statusEl.textContent = '';
            }, 3000);
        }
        
        function loadFranchiseSettingsFromStorage() {
            const saved = localStorage.getItem('vitalStretchFranchiseSettings');
            if (saved) {
                try {
                    const settings = JSON.parse(saved);
                    
                    // Update CONFIG
                    CONFIG.timezone = settings.timezone || 'America/Chicago';
                    CONFIG.franchiseFeePercent = settings.franchiseFeePercent || 7.0;
                    CONFIG.brandFundPercent = settings.brandFundPercent || 1.5;
                    CONFIG.ccFeesPercent = settings.ccFeesPercent || 2.9;
                    CONFIG.goals.monthlyAppointments = settings.monthlyPaidApptGoal || 300;
                    CONFIG.goals.monthlyIntroAppointments = settings.monthlyIntroApptGoal || 50;
                    CONFIG.goals.monthlyRevenue = settings.monthlyRevenueGoal || 20000;
                    CONFIG.baseHourlyRate = settings.baseHourlyRate || 13.00;
                    
                    // Update form fields
                    document.getElementById('timezoneSelect').value = CONFIG.timezone;
                    document.getElementById('franchiseFeePercent').value = CONFIG.franchiseFeePercent;
                    document.getElementById('brandFundPercent').value = CONFIG.brandFundPercent;
                    document.getElementById('ccFeesPercent').value = CONFIG.ccFeesPercent;
                    document.getElementById('monthlyPaidApptGoal').value = CONFIG.goals.monthlyAppointments;
                    document.getElementById('monthlyIntroApptGoal').value = CONFIG.goals.monthlyIntroAppointments;
                    document.getElementById('monthlyRevenueGoal').value = CONFIG.goals.monthlyRevenue;
                    document.getElementById('baseRateInput').value = CONFIG.baseHourlyRate;
                } catch (e) {
                    console.error('Error loading settings:', e);
                }
            }
        }
        
        // Load saved settings on page load
        window.addEventListener('DOMContentLoaded', function() {
            loadFranchiseSettingsFromStorage();
        });
        
        // Utility Functions
        function formatNumber(num) {
            return num.toLocaleString('en-US', {
                minimumFractionDigits: 0,
                maximumFractionDigits: 2
            });
        }
        
        function formatCurrency(num) {
            // Only round to nearest dollar if >= 1000, otherwise show cents
            if (Math.abs(num) >= 1000) {
                return CONFIG.currencySymbol + formatNumber(Math.round(num));
            }
            return CONFIG.currencySymbol + num.toLocaleString('en-US', {
                minimumFractionDigits: 2,
                maximumFractionDigits: 2
            });
        }
        
        // Memoized date parsing for performance
        const dateCache = new Map();
        function parseDate(dateStr) {
            if (!dateStr) return new Date();
            
            // Check cache first
            if (dateCache.has(dateStr)) {
                return dateCache.get(dateStr);
            }
            
            let result;
            
            // Handle "YYYY-MM-DD, HH:MM AM/PM" format
            const parts = dateStr.split(',');
            if (parts.length >= 2) {
                const datePart = parts[0].trim();
                const timePart = parts[1].trim();
                
                // Parse date
                const dateComponents = datePart.split('-');
                if (dateComponents.length === 3) {
                    const year = parseInt(dateComponents[0]);
                    const month = parseInt(dateComponents[1]) - 1;
                    const day = parseInt(dateComponents[2]);
                    
                    // Parse time
                    const timeMatch = timePart.match(/(\d+):(\d+)\s*(AM|PM)/i);
                    if (timeMatch) {
                        let hour = parseInt(timeMatch[1]);
                        const minute = parseInt(timeMatch[2]);
                        const ampm = timeMatch[3].toUpperCase();
                        
                        // Convert to 24-hour format
                        if (ampm === 'PM' && hour !== 12) {
                            hour += 12;
                        } else if (ampm === 'AM' && hour === 12) {
                            hour = 0;
                        }
                        
                        result = new Date(year, month, day, hour, minute);
                    } else {
                        result = new Date(year, month, day);
                    }
                } else {
                    result = new Date(dateStr);
                }
            } else {
                result = new Date(dateStr);
            }
            
            // Cache the result
            dateCache.set(dateStr, result);
            return result;
        }

        function isIntroOffer(service) {
            if (!service) return false;
            const serviceLower = service.toLowerCase();
            return serviceLower.includes('intro') || serviceLower.includes('introductory');
        }
        
        // File Upload Handlers
        document.getElementById('leadsFile').addEventListener('change', function(e) {
            const file = e.target.files[0];
            if (!file) return;
            
            document.getElementById('leadsStatus').innerHTML = '<span class="spinner"></span> Processing...';
            
            Papa.parse(file, {
                header: true,
                skipEmptyLines: true,
                complete: function(results) {
                    leadsData = results.data;
                    filteredLeads = [...leadsData];
                    
                    // Count customers vs leads
                    const customers = leadsData.filter(row => (row['Type'] || '').toLowerCase() === 'customer').length;
                    const leads = leadsData.filter(row => (row['Type'] || '').toLowerCase() === 'lead').length;
                    
                    let statusHTML = '<span style="color: var(--success); font-weight: 600;">‚úÖ ';
                    if (customers > 0 && leads > 0) {
                        statusHTML += `${formatNumber(customers)} customers, ${formatNumber(leads)} leads loaded`;
                    } else if (customers > 0) {
                        statusHTML += `${formatNumber(customers)} customers loaded`;
                    } else if (leads > 0) {
                        statusHTML += `${formatNumber(leads)} leads loaded`;
                    } else {
                        statusHTML += `${formatNumber(leadsData.length)} records loaded`;
                    }
                    statusHTML += '</span>';
                    
                    document.getElementById('leadsStatus').innerHTML = statusHTML;
                    
                    if (appointmentsData.length > 0) {
                        hideEmptyState();
                        renderAllTabs();
                    }
                },
                error: function(error) {
                    document.getElementById('leadsStatus').innerHTML = 
                        '<span style="color: var(--danger);">‚ùå Error loading file</span>';
                    console.error('Parse error:', error);
                }
            });
        });
        
        document.getElementById('membershipsFile').addEventListener('change', function(e) {
            const files = e.target.files;
            if (!files || files.length === 0) return;
            
            document.getElementById('membershipsStatus').innerHTML = '<span class="spinner"></span> Processing...';
            
            let salesCount = 0;
            let cancellationsCount = 0;
            let filesProcessed = 0;
            let statusMessages = [];
            
            // Process each file
            Array.from(files).forEach((file, index) => {
                Papa.parse(file, {
                    header: true,
                    skipEmptyLines: true,
                    complete: function(results) {
                        if (results.data.length > 0) {
                            // Check if it's sales or cancellations by looking at headers
                            const headers = Object.keys(results.data[0]);
                            
                            if (headers.includes('Cancelled at')) {
                                // This is a cancellations file
                                membershipCancellationsData = results.data;
                                filteredCancellations = [...membershipCancellationsData];
                                cancellationsCount = results.data.length;
                                console.log('Loaded cancellations:', cancellationsCount);
                            } else if (headers.includes('Bought Date/Time (GMT)')) {
                                // This is a sales file
                                membershipsData = results.data;
                                filteredMemberships = [...membershipsData];
                                salesCount = results.data.length;
                                console.log('Loaded memberships:', salesCount);
                            } else {
                                statusMessages.push(`‚ö†Ô∏è Unknown file type`);
                            }
                        }
                        
                        filesProcessed++;
                        
                        // When all files are processed, update status
                        if (filesProcessed === files.length) {
                            // Build status message showing current state of both files
                            const currentStatus = [];
                            
                            // Check what we have in memory (from all uploads)
                            if (membershipsData.length > 0) {
                                currentStatus.push(`<span style="color: var(--success); font-weight: 600;">‚úÖ ${formatNumber(membershipsData.length)} memberships loaded</span>`);
                            }
                            
                            if (membershipCancellationsData.length > 0) {
                                currentStatus.push(`<span style="color: var(--success); font-weight: 600;">‚úÖ ${formatNumber(membershipCancellationsData.length)} cancellations loaded</span>`);
                            }
                            
                            if (statusMessages.length > 0 && statusMessages[0].includes('‚ö†Ô∏è')) {
                                currentStatus.push(...statusMessages);
                            }
                            
                            if (currentStatus.length > 0) {
                                document.getElementById('membershipsStatus').innerHTML = currentStatus.join('<br>');
                            } else {
                                document.getElementById('membershipsStatus').innerHTML = 
                                    '<span style="color: var(--danger);">‚ùå No valid data found</span>';
                            }
                            
                            console.log('Final status - Sales:', membershipsData.length, 'Cancellations:', membershipCancellationsData.length);
                            
                            if (appointmentsData.length > 0 && (membershipsData.length > 0 || membershipCancellationsData.length > 0)) {
                                hideEmptyState();
                                renderAllTabs();
                            }
                        }
                    },
                    error: function(error) {
                        filesProcessed++;
                        statusMessages.push(`‚ùå Error in file`);
                        if (filesProcessed === files.length) {
                            document.getElementById('membershipsStatus').innerHTML = 
                                statusMessages.map(msg => `<span style="color: var(--danger); font-weight: 600;">${msg}</span>`).join('<br>');
                        }
                        console.error('Parse error:', error);
                    }
                });
            });
        });
        
        // Zip File Handler for Payroll Data
        document.getElementById('payrollZipFile').addEventListener('change', async function(e) {
            const file = e.target.files[0];
            if (!file) return;
            
            document.getElementById('payrollZipStatus').innerHTML = '<span class="spinner"></span> Processing zip file...';
            
            try {
                const zip = await JSZip.loadAsync(file);
                let allAppointments = [];
                let allTimeTracking = [];
                let allCommissions = [];
                let employeeStats = {};
                
                // Process all files in the zip
                for (const [filename, zipEntry] of Object.entries(zip.files)) {
                    if (zipEntry.dir) continue;
                    
                    const content = await zipEntry.async('text');
                    
                    // Extract employee name from filename
                    const nameParts = filename.match(/momence-payroll-(?:appointments|time)-(.+?)(?:-aggregate)?\.csv/);
                    if (!nameParts) continue;
                    
                    const employeeName = nameParts[1].replace(/-/g, ' ').replace(/\b\w/g, l => l.toUpperCase());
                    
                    // Parse appointments files (not aggregate)
                    if (filename.includes('appointments') && !filename.includes('aggregate')) {
                        Papa.parse(content, {
                            header: true,
                            skipEmptyLines: true,
                            complete: function(results) {
                                // Add employee name and practitioner info to each row
                                results.data.forEach(row => {
                                    const names = employeeName.split(' ');
                                    row['Practitioner First Name'] = names[0];
                                    row['Practitioner Last Name'] = names.slice(1).join(' ');
                                    row['Employee Name'] = employeeName;
                                    
                                    // Convert Time booked (h) to Time (h) for consistency
                                    if (row['Time booked (h)']) {
                                        row['Time (h)'] = row['Time booked (h)'];
                                    }
                                });
                                allAppointments = allAppointments.concat(results.data);
                            }
                        });
                    }
                    
                    // Parse time tracking files
                    if (filename.includes('time') && !filename.includes('aggregate')) {
                        Papa.parse(content, {
                            header: true,
                            skipEmptyLines: true,
                            complete: function(results) {
                                results.data.forEach(row => {
                                    row['Employee Name'] = employeeName;
                                    // Store for cleaning later
                                    if (!employeeStats[employeeName]) {
                                        employeeStats[employeeName] = { durations: [] };
                                    }
                                    const duration = parseFloat(row['Duration (h)']);
                                    if (!isNaN(duration)) {
                                        employeeStats[employeeName].durations.push(duration);
                                    }
                                });
                                allTimeTracking = allTimeTracking.concat(results.data);
                            }
                        });
                    }
                    
                    // Parse commission files
                    if (filename.includes('commissions') && !filename.includes('aggregate')) {
                        Papa.parse(content, {
                            header: true,
                            skipEmptyLines: true,
                            complete: function(results) {
                                results.data.forEach(row => {
                                    row['Employee Name'] = employeeName;
                                    // Clean product names - remove special characters
                                    if (row['Item name']) {
                                        row['Item name'] = row['Item name']
                                            .replace(/[¬Æ‚Ñ¢¬©√Ç¬Æ]/g, '')           // Remove special characters
                                            .replace(/[\u0080-\u00FF]/g, '')  // Remove extended ASCII
                                            .replace(/\s+/g, ' ')              // Normalize whitespace
                                            .trim();
                                    }
                                    // Only include Membership and Product commissions
                                    const itemType = (row['Item type'] || '').toLowerCase();
                                    if (itemType === 'membership' || itemType === 'product') {
                                        allCommissions = allCommissions || [];
                                        allCommissions.push(row);
                                    }
                                });
                            }
                        });
                    }
                }
                
                // Wait a bit for all parsing to complete
                await new Promise(resolve => setTimeout(resolve, 500));
                
                // Clean Duration (h) data - replace values > 12 with employee average
                Object.keys(employeeStats).forEach(employeeName => {
                    const durations = employeeStats[employeeName].durations.filter(d => d > 0 && d <= 12);
                    const avgDuration = durations.length > 0 
                        ? durations.reduce((sum, d) => sum + d, 0) / durations.length 
                        : 8; // Default to 8 hours if no valid data
                    employeeStats[employeeName].avgDuration = avgDuration;
                });
                
                // Apply cleaning to time tracking data
                allTimeTracking = allTimeTracking.map(row => {
                    const duration = parseFloat(row['Duration (h)']);
                    if (!isNaN(duration) && duration > 12) {
                        const employeeName = row['Employee Name'];
                        const avgDuration = employeeStats[employeeName]?.avgDuration || 8;
                        row['Duration (h)'] = avgDuration.toFixed(2);
                        row['Original Duration (h)'] = duration.toFixed(2); // Keep original for reference
                        row['Duration Corrected'] = 'Yes';
                    }
                    return row;
                });
                
                // Calculate utilization for each employee
                const employeeUtilization = {};
                Object.keys(employeeStats).forEach(employeeName => {
                    const employeeAppts = allAppointments.filter(a => a['Employee Name'] === employeeName);
                    const employeeTime = allTimeTracking.filter(t => t['Employee Name'] === employeeName);
                    
                    const totalApptHours = employeeAppts.reduce((sum, a) => {
                        const hours = parseFloat(a['Time (h)'] || a['Time booked (h)'] || 0);
                        return sum + hours;
                    }, 0);
                    
                    const totalClockedHours = employeeTime.reduce((sum, t) => {
                        const hours = parseFloat(t['Duration (h)'] || 0);
                        return sum + hours;
                    }, 0);
                    
                    const utilization = totalClockedHours > 0 
                        ? (totalApptHours / totalClockedHours * 100) 
                        : 0;
                    
                    employeeUtilization[employeeName] = {
                        totalApptHours: totalApptHours,
                        totalClockedHours: totalClockedHours,
                        utilization: utilization,
                        appointmentCount: employeeAppts.length,
                        shiftCount: employeeTime.length
                    };
                });
                
                // Store utilization data globally
                window.employeeUtilization = employeeUtilization;
                window.timeTrackingData = allTimeTracking;
                window.commissionsData = allCommissions;
                window.filteredCommissions = [...allCommissions];
                
                // Set appointments data
                appointmentsData = allAppointments;
                filteredAppointments = [...appointmentsData];
                
                const totalAppts = allAppointments.length;
                const totalEmployees = Object.keys(employeeStats).length;
                const avgUtilization = Object.values(employeeUtilization)
                    .reduce((sum, e) => sum + e.utilization, 0) / totalEmployees;
                
                document.getElementById('payrollZipStatus').innerHTML = 
                    `<span style="color: var(--success); font-weight: 600;">‚úÖ ${formatNumber(totalAppts)} appointments from ${totalEmployees} employees (Avg Utilization: ${avgUtilization.toFixed(1)}%)</span>`;
                
                initializeDashboard();
                
            } catch (error) {
                document.getElementById('payrollZipStatus').innerHTML = 
                    '<span style="color: var(--danger);">‚ùå Error processing zip file</span>';
                console.error('Zip processing error:', error);
            }
        });
        
        // Initialize Dashboard
        function initializeDashboard() {
            if (appointmentsData.length === 0) return;
            
            hideEmptyState();
            
            document.getElementById('filtersSection').style.display = 'block';
            document.getElementById('mainTabs').style.display = 'flex';
            
            populateFilters();
            renderAllTabs();
        }
        
        // Populate Filters
        function populateFilters() {
            const months = new Set();
            const locations = new Set();
            const practitioners = new Set();
            const services = new Set();
            
            appointmentsData.forEach(row => {
                const date = parseDate(row['Appointment Date']);
                const monthKey = `${date.getFullYear()}-${String(date.getMonth() + 1).padStart(2, '0')}`;
                months.add(monthKey);
                
                if (row.Location) locations.add(row.Location);
                if (row['Practitioner First Name'] && row['Practitioner Last Name']) {
                    practitioners.add(`${row['Practitioner First Name']} ${row['Practitioner Last Name']}`);
                }
                if (row['Appointment']) services.add(row['Appointment']);
            });
            
            // Populate month filter
            const monthFilter = document.getElementById('monthFilter');
            monthFilter.innerHTML = '<option value="all">All Months</option>';
            Array.from(months).sort().reverse().forEach(month => {
                const [year, mon] = month.split('-');
                const date = new Date(year, mon - 1);
                const label = date.toLocaleDateString('en-US', { month: 'long', year: 'numeric' });
                monthFilter.innerHTML += `<option value="${month}">${label}</option>`;
            });
            
            // Populate location filter
            const locationFilter = document.getElementById('locationFilter');
            locationFilter.innerHTML = '<option value="all">All Locations</option>';
            Array.from(locations).sort().forEach(loc => {
                locationFilter.innerHTML += `<option value="${loc}">${loc}</option>`;
            });
            
            // Populate practitioner filter
            const practitionerFilter = document.getElementById('practitionerFilter');
            practitionerFilter.innerHTML = '<option value="all">All VSPs</option>';
            Array.from(practitioners).sort().forEach(prac => {
                practitionerFilter.innerHTML += `<option value="${prac}">${prac}</option>`;
            });
            
            // Populate service filter
            const serviceFilter = document.getElementById('serviceFilter');
            serviceFilter.innerHTML = '<option value="all">All Services</option>';
            Array.from(services).sort().forEach(service => {
                serviceFilter.innerHTML += `<option value="${service}">${service}</option>`;
            });
            
            // Add event listeners
            ['monthFilter', 'locationFilter', 'practitionerFilter', 'serviceFilter', 'startDate', 'endDate'].forEach(id => {
                document.getElementById(id).addEventListener('change', applyFilters);
            });
        }
        
        // Display Active Filters
        function displayActiveFilters() {
            const month = document.getElementById('monthFilter').value;
            const location = document.getElementById('locationFilter').value;
            const practitioner = document.getElementById('practitionerFilter').value;
            const service = document.getElementById('serviceFilter').value;
            const startDate = document.getElementById('startDate').value;
            const endDate = document.getElementById('endDate').value;
            
            let badges = [];
            
            if (month !== 'all') {
                const [year, mon] = month.split('-');
                const date = new Date(year, mon - 1);
                const label = date.toLocaleDateString('en-US', { month: 'short', year: 'numeric' });
                badges.push(label);
            }
            if (location !== 'all') badges.push(location);
            if (practitioner !== 'all') badges.push(practitioner);
            if (service !== 'all') badges.push(service.substring(0, 30));
            if (startDate && endDate) badges.push(`${startDate} to ${endDate}`);
            else if (startDate) badges.push(`From ${startDate}`);
            else if (endDate) badges.push(`Until ${endDate}`);
            
            const display = document.getElementById('activeFiltersDisplay');
            if (badges.length > 0) {
                display.innerHTML = '<strong>Active Filters:</strong> ' + 
                    badges.map(b => `<span class="filter-badge">${b}</span>`).join('');
                display.classList.add('show');
            } else {
                display.classList.remove('show');
            }
        }
        
        // Recalculate Utilization Based on Filtered Data
        function recalculateUtilization() {
            if (!window.timeTrackingData || window.timeTrackingData.length === 0) {
                return; // No time tracking data available
            }
            
            const month = document.getElementById('monthFilter').value;
            const startDate = document.getElementById('startDate').value;
            const endDate = document.getElementById('endDate').value;
            
            // Filter time tracking data by the same date range as appointments
            const filteredTimeTracking = window.timeTrackingData.filter(row => {
                const clockedIn = row['Clocked in'] ? new Date(row['Clocked in']) : null;
                if (!clockedIn) return false;
                
                // Month filter
                if (month !== 'all') {
                    const rowMonth = `${clockedIn.getFullYear()}-${String(clockedIn.getMonth() + 1).padStart(2, '0')}`;
                    if (rowMonth !== month) return false;
                }
                
                // Date range filters
                if (startDate && clockedIn < new Date(startDate)) return false;
                if (endDate && clockedIn > new Date(endDate)) return false;
                
                return true;
            });
            
            // Recalculate utilization for each employee based on filtered data
            const employeeUtilization = {};
            
            // Get unique employee names from filtered appointments
            const employeeNames = new Set();
            filteredAppointments.forEach(a => {
                if (a['Employee Name']) {
                    employeeNames.add(a['Employee Name']);
                }
            });
            
            // Calculate utilization for each employee
            employeeNames.forEach(employeeName => {
                const employeeAppts = filteredAppointments.filter(a => a['Employee Name'] === employeeName);
                const employeeTime = filteredTimeTracking.filter(t => t['Employee Name'] === employeeName);
                
                const totalApptHours = employeeAppts.reduce((sum, a) => {
                    const hours = parseFloat(a['Time (h)'] || a['Time booked (h)'] || 0);
                    return sum + hours;
                }, 0);
                
                const totalClockedHours = employeeTime.reduce((sum, t) => {
                    const hours = parseFloat(t['Duration (h)'] || 0);
                    return sum + hours;
                }, 0);
                
                const utilization = totalClockedHours > 0 
                    ? (totalApptHours / totalClockedHours * 100) 
                    : 0;
                
                employeeUtilization[employeeName] = {
                    totalApptHours: totalApptHours,
                    totalClockedHours: totalClockedHours,
                    utilization: utilization,
                    appointmentCount: employeeAppts.length,
                    shiftCount: employeeTime.length
                };
            });
            
            // Update the global employeeUtilization object
            window.employeeUtilization = employeeUtilization;
        }
        
        // Get Active Member Emails (for revenue exclusion)
        function getActiveMemberEmails() {
            const activeMemberEmails = new Set();
            if (membershipsData && membershipsData.length > 0) {
                membershipsData.forEach(m => {
                    // Only include active (non-expired) memberships
                    if (m.Expired !== 'Yes' && m['Customer Email']) {
                        activeMemberEmails.add(m['Customer Email'].toLowerCase().trim());
                    }
                });
            }
            return activeMemberEmails;
        }
        
        // Calculate appointment revenue excluding active members
        function calculateAppointmentRevenue(appointments) {
            const activeMemberEmails = getActiveMemberEmails();
            return appointments.reduce((sum, row) => {
                const customerEmail = (row['Customer Email'] || '').toLowerCase().trim();
                // Exclude revenue from active members
                if (activeMemberEmails.has(customerEmail)) {
                    return sum;
                }
                return sum + parseFloat(row.Revenue || 0);
            }, 0);
        }
        
        // Apply Filters
        function applyFilters() {
            const month = document.getElementById('monthFilter').value;
            const location = document.getElementById('locationFilter').value;
            const practitioner = document.getElementById('practitionerFilter').value;
            const service = document.getElementById('serviceFilter').value;
            const startDate = document.getElementById('startDate').value;
            const endDate = document.getElementById('endDate').value;
            
            // Filter appointments
            filteredAppointments = appointmentsData.filter(row => {
                const date = parseDate(row['Appointment Date']);
                
                // Month filter
                if (month !== 'all') {
                    const rowMonth = `${date.getFullYear()}-${String(date.getMonth() + 1).padStart(2, '0')}`;
                    if (rowMonth !== month) return false;
                }
                
                // Location filter
                if (location !== 'all' && row.Location !== location) return false;
                
                // Practitioner filter
                if (practitioner !== 'all') {
                    const rowPractitioner = `${row['Practitioner First Name']} ${row['Practitioner Last Name']}`;
                    if (rowPractitioner !== practitioner) return false;
                }
                
                // Service filter
                if (service !== 'all' && row['Appointment'] !== service) return false;
                
                // Date range filters
                if (startDate && date < new Date(startDate)) return false;
                if (endDate && date > new Date(endDate)) return false;
                
                return true;
            });
            
            // Filter memberships by date range (use Bought Date/Time)
            filteredMemberships = membershipsData.filter(row => {
                const boughtDate = row['Bought Date/Time (GMT)'] ? new Date(row['Bought Date/Time (GMT)']) : null;
                if (!boughtDate) return false;
                
                // Month filter
                if (month !== 'all') {
                    const rowMonth = `${boughtDate.getFullYear()}-${String(boughtDate.getMonth() + 1).padStart(2, '0')}`;
                    if (rowMonth !== month) return false;
                }
                
                // Date range filters
                if (startDate && boughtDate < new Date(startDate)) return false;
                if (endDate && boughtDate > new Date(endDate)) return false;
                
                return true;
            });
            
            // Filter leads by date range (use Join date)
            filteredLeads = leadsData.filter(row => {
                const joinDate = row['Join date'] ? parseDate(row['Join date']) : null;
                if (!joinDate) return false; // Exclude leads without join dates
                
                // Month filter
                if (month !== 'all') {
                    const rowMonth = `${joinDate.getFullYear()}-${String(joinDate.getMonth() + 1).padStart(2, '0')}`;
                    if (rowMonth !== month) return false;
                }
                
                // Date range filters
                if (startDate && joinDate < new Date(startDate)) return false;
                if (endDate && joinDate > new Date(endDate)) return false;
                
                return true;
            });
            
            // Filter membership cancellations by date range (use Cancelled at)
            filteredCancellations = membershipCancellationsData.filter(row => {
                const cancelledDate = row['Cancelled at'] ? parseDate(row['Cancelled at']) : null;
                if (!cancelledDate) return false;
                
                // Month filter
                if (month !== 'all') {
                    const rowMonth = `${cancelledDate.getFullYear()}-${String(cancelledDate.getMonth() + 1).padStart(2, '0')}`;
                    if (rowMonth !== month) return false;
                }
                
                // Date range filters
                if (startDate && cancelledDate < new Date(startDate)) return false;
                if (endDate && cancelledDate > new Date(endDate)) return false;
                
                return true;
            });
            
            // Filter commissions by date range
            if (window.commissionsData && window.commissionsData.length > 0) {
                window.filteredCommissions = window.commissionsData.filter(row => {
                    const commDate = row['Date'] ? new Date(row['Date']) : null;
                    if (!commDate) return false;
                    
                    // Month filter
                    if (month !== 'all') {
                        const rowMonth = `${commDate.getFullYear()}-${String(commDate.getMonth() + 1).padStart(2, '0')}`;
                        if (rowMonth !== month) return false;
                    }
                    
                    // Date range filters
                    if (startDate && commDate < new Date(startDate)) return false;
                    if (endDate && commDate > new Date(endDate)) return false;
                    
                    return true;
                });
            }
            
            // Filter time tracking by date range
            if (window.timeTrackingData && window.timeTrackingData.length > 0) {
                filteredTimeTracking = window.timeTrackingData.filter(row => {
                    if (!row['Employee Name']) return false;
                    const clockedDate = parseDate(row['Clock in date']);
                    if (!clockedDate) return false;
                    
                    // Month filter
                    if (month !== 'all') {
                        const rowMonth = `${clockedDate.getFullYear()}-${String(clockedDate.getMonth() + 1).padStart(2, '0')}`;
                        if (rowMonth !== month) return false;
                    }
                    
                    // Date range filters
                    if (startDate && clockedDate < new Date(startDate)) return false;
                    if (endDate && clockedDate > new Date(endDate + 'T23:59:59')) return false;
                    
                    // Practitioner filter
                    if (practitioner !== 'all' && row['Employee Name'] !== practitioner) return false;
                    
                    return true;
                });
            } else {
                filteredTimeTracking = [];
            }
            
            // Recalculate utilization based on filtered data
            recalculateUtilization();
            
            displayActiveFilters();
            renderAllTabs();
        }
        
        // Refresh data with current filters
        function refreshData() {
            applyFilters();
        }
        
        // Quick Filters
        function setQuickFilter(filter) {
            const today = new Date();
            const startDateInput = document.getElementById('startDate');
            const endDateInput = document.getElementById('endDate');
            const monthFilter = document.getElementById('monthFilter');
            
            // Reset filters
            if (filter === 'reset') {
                startDateInput.value = '';
                endDateInput.value = '';
                monthFilter.value = 'all';
                document.getElementById('locationFilter').value = 'all';
                document.getElementById('practitionerFilter').value = 'all';
                document.getElementById('serviceFilter').value = 'all';
                applyFilters();
                return;
            }
            
            // Apply quick filter
            switch(filter) {
                case '7days':
                    const sevenDaysAgo = new Date(today);
                    sevenDaysAgo.setDate(sevenDaysAgo.getDate() - 7);
                    startDateInput.value = sevenDaysAgo.toISOString().split('T')[0];
                    endDateInput.value = today.toISOString().split('T')[0];
                    monthFilter.value = 'all';
                    break;
                case '30days':
                    const thirtyDaysAgo = new Date(today);
                    thirtyDaysAgo.setDate(thirtyDaysAgo.getDate() - 30);
                    startDateInput.value = thirtyDaysAgo.toISOString().split('T')[0];
                    endDateInput.value = today.toISOString().split('T')[0];
                    monthFilter.value = 'all';
                    break;
                case '90days':
                    const ninetyDaysAgo = new Date(today);
                    ninetyDaysAgo.setDate(ninetyDaysAgo.getDate() - 90);
                    startDateInput.value = ninetyDaysAgo.toISOString().split('T')[0];
                    endDateInput.value = today.toISOString().split('T')[0];
                    monthFilter.value = 'all';
                    break;
                case 'thisMonth':
                    const monthStr = `${today.getFullYear()}-${String(today.getMonth() + 1).padStart(2, '0')}`;
                    monthFilter.value = monthStr;
                    startDateInput.value = '';
                    endDateInput.value = '';
                    break;
                case 'lastMonth':
                    const lastMonth = new Date(today.getFullYear(), today.getMonth() - 1, 1);
                    const lastMonthStr = `${lastMonth.getFullYear()}-${String(lastMonth.getMonth() + 1).padStart(2, '0')}`;
                    monthFilter.value = lastMonthStr;
                    startDateInput.value = '';
                    endDateInput.value = '';
                    break;
            }
            
            applyFilters();
        }
        
        // Tab Switching
        // Tab state tracking
        let renderedTabs = new Set();
        let currentActiveTab = 'overview';
        
        function switchTab(tabName) {
            document.querySelectorAll('.tab').forEach(t => t.classList.remove('active'));
            document.querySelectorAll('.tab-content').forEach(c => c.classList.remove('active'));
            
            event.target.classList.add('active');
            document.getElementById(tabName).classList.add('active');
            currentActiveTab = tabName;
            
            // Lazy render: only render tab if not already rendered or if data has changed
            if (!renderedTabs.has(tabName)) {
                renderTab(tabName);
                renderedTabs.add(tabName);
            }
        }
        
        // Get currently active tab
        function getCurrentActiveTab() {
            return currentActiveTab;
        }
        
        // Render specific tab
        function renderTab(tabName) {
            switch(tabName) {
                case 'overview': renderOverviewTab(); break;
                case 'memberships': if (membershipsData.length > 0) renderMembershipsTab(); break;
                case 'cancellations': if (membershipCancellationsData.length > 0) renderCancellationsTab(); break;
                case 'journey': renderJourneyTab(); break;
                case 'retention': renderRetentionTab(); break;
                case 'schedule': renderScheduleTab(); break;
                case 'customers': renderCustomersTab(); break;
                case 'practitioners': renderPractitionersTab(); break;
                case 'timeline': renderTimelineTab(); break;
                case 'insights': renderInsightsTab(); break;
            }
        }
        
        // Render All Tabs (only called when filters change)
        function renderAllTabs() {
            renderedTabs.clear(); // Clear cache when data changes
            renderOverviewTab(); // Always render overview
            renderedTabs.add('overview');
            
            // Also re-render the currently active tab if it's not overview
            const activeTab = getCurrentActiveTab();
            if (activeTab !== 'overview') {
                renderTab(activeTab);
                renderedTabs.add(activeTab);
            }
            // Other tabs will render lazily when clicked
        }
        
        // Get current period for goal tracking
        function getCurrentPeriod() {
            if (filteredAppointments.length === 0) return 'All Time';
            
            const month = document.getElementById('monthFilter').value;
            if (month !== 'all') {
                const [year, mon] = month.split('-');
                const date = new Date(year, mon - 1);
                return date.toLocaleDateString('en-US', { month: 'long', year: 'numeric' });
            }
            
            // Check if using date range
            const startDate = document.getElementById('startDate').value;
            const endDate = document.getElementById('endDate').value;
            
            if (startDate && endDate) {
                return `${startDate} to ${endDate}`;
            } else if (startDate) {
                return `From ${startDate}`;
            } else if (endDate) {
                return `Until ${endDate}`;
            }
            
            // Check if data spans single month
            const dates = filteredAppointments.map(row => parseDate(row['Appointment Date']));
            const minDate = new Date(Math.min(...dates));
            const maxDate = new Date(Math.max(...dates));
            
            if (minDate.getMonth() === maxDate.getMonth() && minDate.getFullYear() === maxDate.getFullYear()) {
                return minDate.toLocaleDateString('en-US', { month: 'long', year: 'numeric' });
            }
            
            return `${minDate.toLocaleDateString('en-US', { month: 'short', year: 'numeric' })} - ${maxDate.toLocaleDateString('en-US', { month: 'short', year: 'numeric' })}`;
        }

        // OVERVIEW TAB
        function renderOverviewTab() {
            const data = filteredAppointments;
            
            // Calculate appointment revenue EXCLUDING active members
            const apptRevenue = calculateAppointmentRevenue(data);
            
            // Calculate membership revenue if data is available
            let membershipRevenue = 0;
            if (filteredMemberships && filteredMemberships.length > 0) {
                membershipRevenue = filteredMemberships.reduce((sum, m) => sum + parseFloat(m['Paid Amount'] || 0), 0);
            }
            
            const totalRevenue = apptRevenue + membershipRevenue;
            const totalPayout = data.reduce((sum, row) => sum + parseFloat(row['Total Payout'] || 0), 0);
            const totalHours = data.reduce((sum, row) => sum + parseFloat(row['Time (h)'] || 0), 0);
            const avgRevenue = data.length > 0 ? apptRevenue / data.length : 0;
            
            // Calculate total labor costs including non-appointment work
            let totalLaborCost = totalPayout;
            let nonApptHours = 0;
            let nonApptLaborCost = 0;
            
            if (filteredTimeTracking && filteredTimeTracking.length > 0) {
                const totalClockedHours = filteredTimeTracking.reduce((sum, t) => {
                    const hours = parseFloat(t['Duration (h)'] || 0);
                    return sum + hours;
                }, 0);
                
                // Non-appointment hours = clocked hours - appointment hours
                nonApptHours = Math.max(0, totalClockedHours - totalHours);
                nonApptLaborCost = nonApptHours * CONFIG.baseHourlyRate;
                totalLaborCost = totalPayout + nonApptLaborCost;
            }
            
            const profit = totalRevenue - totalLaborCost;
            const profitMargin = totalRevenue > 0 ? (profit / totalRevenue * 100) : 0;
            
            // Count intro sessions and late cancellations
            const introSessions = data.filter(row => isIntroOffer(row['Appointment'])).length;
            const lateCancellations = data.filter(row => 
                row['Late cancellations'] && row['Late cancellations'].toLowerCase() === 'yes'
            ).length;
            
            // Unique clients
            const uniqueClients = new Set(
                data.map(row => (row['Customer Email'] || '').toLowerCase().trim())
                    .filter(email => email)
            ).size;
            
            // Revenue per hour
            const revenuePerHour = totalHours > 0 ? totalRevenue / totalHours : 0;
            
            // Average ticket size
            const avgTicketSize = data.length > 0 ? totalRevenue / data.length : 0;
            
            // Calculate utilization if data available
            let avgUtilization = null;
            if (window.employeeUtilization) {
                const utilizationValues = Object.values(window.employeeUtilization)
                    .map(e => e.utilization)
                    .filter(u => u > 0);
                if (utilizationValues.length > 0) {
                    avgUtilization = utilizationValues.reduce((sum, u) => sum + u, 0) / utilizationValues.length;
                }
            }
            
            // Client visit frequency
            const clientVisits = {};
            data.forEach(row => {
                const email = row['Customer Email'];
                if (email) {
                    clientVisits[email] = (clientVisits[email] || 0) + 1;
                }
            });
            const newClients = Object.values(clientVisits).filter(v => v === 1).length;
            const returningClients = uniqueClients - newClients;
            const avgVisitsPerClient = uniqueClients > 0 ? data.length / uniqueClients : 0;
            
            // Busiest day
            const dayCount = {};
            data.forEach(row => {
                const date = parseDate(row['Appointment Date']);
                if (date) {
                    const days = ['Sunday', 'Monday', 'Tuesday', 'Wednesday', 'Thursday', 'Friday', 'Saturday'];
                    const day = days[date.getDay()];
                    dayCount[day] = (dayCount[day] || 0) + 1;
                }
            });
            const busiestDay = Object.entries(dayCount).sort((a, b) => b[1] - a[1])[0];
            
            // Top paid service by appointments (excluding demo and intro)
            const serviceCount = {};
            data.forEach(row => {
                const service = row.Appointment;
                if (service && !isIntroOffer(service)) {
                    serviceCount[service] = (serviceCount[service] || 0) + 1;
                }
            });
            const topService = Object.entries(serviceCount).sort((a, b) => b[1] - a[1])[0];
            
            // Number of practitioners
            const uniquePractitioners = new Set(
                data.map(row => `${row['Practitioner First Name']} ${row['Practitioner Last Name']}`)
                    .filter(name => name.trim() !== '')
            ).size;
            const revenuePerPractitioner = uniquePractitioners > 0 ? totalRevenue / uniquePractitioners : 0;
            
            // Calculate comparison data if enabled
            if (document.getElementById('comparisonPeriod').value !== 'none') {
                calculateComparisonData();
            }
            
            let html = `
                ${comparisonData ? `<div class="alert info"><h4>üìä Period Comparison Active</h4><p>Comparing current period to: <strong>${comparisonData.period}</strong></p></div>` : ''}
                
                <div class="metrics-grid">
                    <div class="metric-card compact">
                        <div class="metric-label">Total Revenue</div>
                        <div class="metric-value">
                            ${formatCurrency(totalRevenue)}
                            ${comparisonData ? getComparisonIndicator(totalRevenue, comparisonData.revenue, 'currency') : ''}
                        </div>
                        <div class="metric-subtext">
                            ${membershipRevenue > 0 
                                ? `Appointments: ${formatCurrency(apptRevenue)} | Memberships: ${formatCurrency(membershipRevenue)}`
                                : `From ${formatNumber(data.length)} appointments`
                            }
                        </div>
                        ${comparisonData ? `<div class="comparison-details">vs ${formatCurrency(comparisonData.revenue)} last period</div>` : ''}
                    </div>
                    <div class="metric-card compact">
                        <div class="metric-label">Appointments</div>
                        <div class="metric-value">
                            ${formatNumber(data.length)}
                            ${comparisonData ? getComparisonIndicator(data.length, comparisonData.appointments) : ''}
                        </div>
                        <div class="metric-subtext">Total bookings</div>
                        ${comparisonData ? `<div class="comparison-details">vs ${formatNumber(comparisonData.appointments)} last period</div>` : ''}
                    </div>
                    <div class="metric-card compact">
                        <div class="metric-label">Unique Clients</div>
                        <div class="metric-value">
                            ${formatNumber(uniqueClients)}
                            ${comparisonData ? getComparisonIndicator(uniqueClients, comparisonData.clients) : ''}
                        </div>
                        <div class="metric-subtext">${formatNumber(newClients)} new, ${formatNumber(returningClients)} returning</div>
                        ${comparisonData ? `<div class="comparison-details">vs ${formatNumber(comparisonData.clients)} last period</div>` : ''}
                    </div>
                    ${avgUtilization !== null ? `
                    <div class="metric-card compact success">
                        <div class="metric-label">Utilization</div>
                        <div class="metric-value">${avgUtilization.toFixed(1)}%</div>
                        <div class="metric-subtext">Table time efficiency</div>
                    </div>
                    ` : ''}
                    <div class="metric-card compact">
                        <div class="metric-label">Revenue/Hour</div>
                        <div class="metric-value">${formatCurrency(revenuePerHour)}</div>
                        <div class="metric-subtext">${formatNumber(totalHours)} total hours</div>
                    </div>
                    <div class="metric-card compact">
                        <div class="metric-label">Avg Ticket Size</div>
                        <div class="metric-value">${formatCurrency(avgTicketSize)}</div>
                        <div class="metric-subtext">Per appointment</div>
                    </div>
                    <div class="metric-card compact">
                        <div class="metric-label">Client Frequency</div>
                        <div class="metric-value">${avgVisitsPerClient.toFixed(1)}</div>
                        <div class="metric-subtext">Avg visits per client</div>
                    </div>
                    <div class="metric-card compact">
                        <div class="metric-label">Revenue per VSP</div>
                        <div class="metric-value">${formatCurrency(revenuePerPractitioner)}</div>
                        <div class="metric-subtext">${formatNumber(uniquePractitioners)} VSPs</div>
                    </div>

                    ${membershipRevenue > 0 ? `
                    <div class="metric-card compact" style="background: linear-gradient(135deg, rgba(156, 39, 176, 0.1), rgba(123, 31, 162, 0.05)); border-left: 4px solid #9c27b0;">
                        <div class="metric-label">üí≥ Total Memberships</div>
                        <div class="metric-value">${formatNumber(membershipsData.length)}</div>
                        <div class="metric-subtext">${formatNumber(membershipsData.filter(m => m.Expired !== 'Yes').length)} active</div>
                    </div>
                    <div class="metric-card compact" style="background: linear-gradient(135deg, rgba(40, 167, 69, 0.1), rgba(32, 201, 151, 0.05)); border-left: 4px solid #28a745;">
                        <div class="metric-label">üíµ Membership Revenue</div>
                        <div class="metric-value">${formatCurrency(membershipRevenue)}</div>
                        <div class="metric-subtext">Avg ${formatCurrency(membershipRevenue / membershipsData.length)} per membership</div>
                    </div>
                    <div class="metric-card compact" style="background: linear-gradient(135deg, rgba(0, 123, 255, 0.1), rgba(0, 86, 179, 0.05)); border-left: 4px solid #007bff;">
                        <div class="metric-label">üîÑ Monthly Recurring Revenue</div>
                        <div class="metric-value">${formatCurrency(membershipsData.filter(m => m['Membership Type'] === 'subscription' && m.Expired !== 'Yes').reduce((sum, m) => sum + (parseFloat(m['Paid Amount']) || 0), 0))}</div>
                        <div class="metric-subtext">From ${formatNumber(membershipsData.filter(m => m['Membership Type'] === 'subscription' && m.Expired !== 'Yes').length)} active subscriptions</div>
                    </div>
                    <div class="metric-card compact" style="background: linear-gradient(135deg, rgba(33, 150, 243, 0.1), rgba(13, 71, 161, 0.05)); border-left: 4px solid #2196f3;">
                        <div class="metric-label">‚ùÑÔ∏è Frozen Memberships</div>
                        <div class="metric-value">${formatNumber(membershipsData.filter(m => m.Frozen === 'Yes').length)}</div>
                        <div class="metric-subtext">${((membershipsData.filter(m => m.Frozen === 'Yes').length / membershipsData.length) * 100).toFixed(1)}% of total memberships</div>
                    </div>
                    <div class="metric-card compact" style="background: linear-gradient(135deg, rgba(244, 67, 54, 0.1), rgba(211, 47, 47, 0.05)); border-left: 4px solid #f44336;">
                        <div class="metric-label">üí∏ Refunded Memberships</div>
                        <div class="metric-value">${formatNumber(membershipsData.filter(m => parseFloat(m.Refunded) > 0).length)}</div>
                        <div class="metric-subtext">${formatCurrency(membershipsData.reduce((sum, m) => sum + (parseFloat(m.Refunded) || 0), 0))} total refunded</div>
                    </div>
                    <div class="metric-card compact" style="background: linear-gradient(135deg, rgba(255, 193, 7, 0.1), rgba(255, 152, 0, 0.05)); border-left: 4px solid #ffc107;">
                        <div class="metric-label">üìä Retention Rate</div>
                        <div class="metric-value">${((membershipsData.filter(m => m.Expired !== 'Yes').length / membershipsData.length) * 100).toFixed(1)}%</div>
                        <div class="metric-subtext">${formatNumber(membershipsData.filter(m => m.Expired !== 'Yes').length)} active of ${formatNumber(membershipsData.length)} total</div>
                    </div>
                    ${membershipCancellationsData && membershipCancellationsData.length > 0 ? `
                    <div class="metric-card compact" style="background: linear-gradient(135deg, rgba(244, 67, 54, 0.15), rgba(211, 47, 47, 0.08)); border-left: 4px solid #f44336;">
                        <div class="metric-label">üö´ Total Cancellations</div>
                        <div class="metric-value">${formatNumber(membershipCancellationsData.length)}</div>
                        <div class="metric-subtext">${((membershipCancellationsData.length / membershipsData.length) * 100).toFixed(1)}% of total sales</div>
                    </div>
                    <div class="metric-card compact" style="background: linear-gradient(135deg, rgba(255, 152, 0, 0.15), rgba(230, 81, 0, 0.08)); border-left: 4px solid #ff9800;">
                        <div class="metric-label">üìä Churn Rate</div>
                        <div class="metric-value">${((membershipCancellationsData.length / membershipsData.length) * 100).toFixed(1)}%</div>
                        <div class="metric-subtext">Cancellations vs sales</div>
                    </div>
                    ` : ''}
                    ` : ''}
                </div>
                
                <div class="table-container" style="background: linear-gradient(135deg, rgba(251, 181, 20, 0.05), rgba(251, 181, 20, 0.02)); border-left: 5px solid var(--highlight);">
                    <h2>Financial Performance</h2>
                    <div class="metrics-grid" style="grid-template-columns: repeat(4, 1fr);">
                        <div class="metric-card ${profit > 0 ? 'success' : 'danger'}">
                            <div class="metric-label">Net Profit</div>
                            <div class="metric-value">
                                ${formatCurrency(profit)}
                                ${comparisonData ? getComparisonIndicator(profit, comparisonData.profit, 'currency') : ''}
                            </div>
                            <div class="metric-subtext">${profitMargin.toFixed(1)}% margin</div>
                            ${comparisonData ? `<div class="comparison-details">vs ${formatCurrency(comparisonData.profit)} last period</div>` : ''}
                        </div>
                        <div class="metric-card warning">
                            <div class="metric-label">Total Labor Cost</div>
                            <div class="metric-value">${formatCurrency(totalLaborCost)}</div>
                            <div class="metric-subtext">${((totalLaborCost / totalRevenue) * 100).toFixed(1)}% of revenue</div>
                        </div>
                        <div class="metric-card">
                            <div class="metric-label">Appointment Payouts</div>
                            <div class="metric-value">${formatCurrency(totalPayout)}</div>
                            <div class="metric-subtext">${formatNumber(totalHours)} appt hours</div>
                        </div>
                        ${nonApptHours > 0 ? `
                        <div class="metric-card">
                            <div class="metric-label">Non-Appt Labor</div>
                            <div class="metric-value">${formatCurrency(nonApptLaborCost)}</div>
                            <div class="metric-subtext">${formatNumber(nonApptHours)} hrs @ ${formatCurrency(CONFIG.baseHourlyRate)}/hr</div>
                        </div>
                        ` : ''}
                    </div>
                    ${nonApptHours > 0 ? `
                    <div class="alert info" style="margin-top: 15px;">
                        <h4>üí° Labor Cost Breakdown</h4>
                        <p style="margin: 8px 0;">
                            <strong>Appointment-Based Labor:</strong> ${formatCurrency(totalPayout)} 
                            (${formatNumber(totalHours)} hours at commission rates)<br>
                            <strong>Non-Appointment Labor:</strong> ${formatCurrency(nonApptLaborCost)} 
                            (${formatNumber(nonApptHours)} hours at base rate of ${formatCurrency(CONFIG.baseHourlyRate)}/hr)<br>
                            <strong>Total Labor Cost:</strong> ${formatCurrency(totalLaborCost)} 
                            (${((totalLaborCost / totalRevenue) * 100).toFixed(1)}% of revenue)
                        </p>
                        <p style="margin-top: 10px; font-size: 12px; color: #666;">
                            Non-appointment hours include cleaning, admin work, training, and other clocked time without appointments. 
                            Adjust the base hourly rate in <strong>‚öôÔ∏è Franchise Configuration</strong> for accurate profitability tracking.
                        </p>
                    </div>
                    ` : ''}
                </div>
                
                <div class="table-container" style="background: linear-gradient(135deg, rgba(220, 53, 69, 0.05), rgba(220, 53, 69, 0.02)); border-left: 5px solid var(--danger);">
                    <h2>Franchise Fees</h2>
                    <div class="metrics-grid" style="grid-template-columns: repeat(4, 1fr);">
                        <div class="metric-card danger">
                            <div class="metric-label">üè¢ Franchise Fee</div>
                            <div class="metric-value">${formatCurrency(totalRevenue * CONFIG.franchiseFeePercent / 100)}</div>
                            <div class="metric-subtext">${CONFIG.franchiseFeePercent}% of revenue</div>
                        </div>
                        <div class="metric-card danger">
                            <div class="metric-label">üéØ Brand Fund</div>
                            <div class="metric-value">${formatCurrency(totalRevenue * CONFIG.brandFundPercent / 100)}</div>
                            <div class="metric-subtext">${CONFIG.brandFundPercent}% of revenue</div>
                        </div>
                        <div class="metric-card danger">
                            <div class="metric-label">üí≥ CC Processing</div>
                            <div class="metric-value">${formatCurrency(totalRevenue * CONFIG.ccFeesPercent / 100)}</div>
                            <div class="metric-subtext">${CONFIG.ccFeesPercent}% of revenue</div>
                        </div>
                        <div class="metric-card danger" style="background: linear-gradient(135deg, rgba(220, 53, 69, 0.15), rgba(220, 53, 69, 0.05));">
                            <div class="metric-label">üí∏ Total Fees</div>
                            <div class="metric-value">${formatCurrency(totalRevenue * (CONFIG.franchiseFeePercent + CONFIG.brandFundPercent + CONFIG.ccFeesPercent) / 100)}</div>
                            <div class="metric-subtext">${((CONFIG.franchiseFeePercent + CONFIG.brandFundPercent + CONFIG.ccFeesPercent)).toFixed(1)}% of revenue</div>
                        </div>
                    </div>
                    <div class="alert info" style="margin-top: 15px;">
                        <h4>üí° Fee Impact on Net Profit</h4>
                        <p style="margin: 8px 0;">
                            <strong>Gross Revenue:</strong> ${formatCurrency(totalRevenue)}<br>
                            <strong>Less: Franchise Fees:</strong> -${formatCurrency(totalRevenue * (CONFIG.franchiseFeePercent + CONFIG.brandFundPercent + CONFIG.ccFeesPercent) / 100)} 
                            (${((CONFIG.franchiseFeePercent + CONFIG.brandFundPercent + CONFIG.ccFeesPercent)).toFixed(1)}% total)<br>
                            <strong>Less: Labor Costs:</strong> -${formatCurrency(totalLaborCost)}<br>
                            <strong>Net Profit After Fees & Labor:</strong> ${formatCurrency(totalRevenue - totalLaborCost - (totalRevenue * (CONFIG.franchiseFeePercent + CONFIG.brandFundPercent + CONFIG.ccFeesPercent) / 100))} 
                            (${((totalRevenue - totalLaborCost - (totalRevenue * (CONFIG.franchiseFeePercent + CONFIG.brandFundPercent + CONFIG.ccFeesPercent) / 100)) / totalRevenue * 100).toFixed(1)}% margin)
                        </p>
                        <p style="margin-top: 10px; font-size: 12px; color: #666;">
                            Configure fee percentages in <strong>‚öôÔ∏è Franchise Configuration</strong> to match your franchise agreement.
                        </p>
                    </div>
                </div>
                
                <div class="charts-grid">
                    <div class="chart-container">
                        <h3>Revenue by Location</h3>
                        <div class="chart-wrapper">
                            <canvas id="revenueByLocationChart"></canvas>
                        </div>
                    </div>
                    
                    <div class="chart-container">
                        <div class="interactive-badge" title="Click on any service to see practitioner breakdown"></div>
                        <h3>Revenue by Service</h3>
                        <div class="chart-wrapper">
                            <canvas id="revenueByServiceChart"></canvas>
                        </div>
                    </div>
                    
                    <div class="chart-container">
                        <h3>Introductory Offers</h3>
                        <div class="chart-wrapper">
                            <canvas id="introSessionsChart"></canvas>
                        </div>
                    </div>
                </div>
                
                <div class="table-container">
                    <h2>AI-Powered Recommendations</h2>
                    <p style="margin-bottom: 20px; color: #666;">Smart insights based on your data patterns and industry best practices.</p>
                    ${(() => {
                        const recommendations = generateSmartRecommendations();
                        if (recommendations.length === 0) {
                            return '<div class="alert success"><h4>üéâ Excellent Performance!</h4><p>Your metrics are strong across the board. Keep up the great work!</p></div>';
                        }
                        return recommendations.slice(0, 3).map(rec => `
                            <div class="recommendation-card">
                                <span class="recommendation-priority ${rec.priority}">${rec.priority.toUpperCase()} PRIORITY</span>
                                <div class="recommendation-title">${rec.title}</div>
                                <p style="margin: 10px 0; color: #666;">${rec.description}</p>
                                <p style="margin: 10px 0;"><strong>Recommended Action:</strong> ${rec.action}</p>
                                <div class="recommendation-impact">
                                    <strong>üí∞ Potential Impact:</strong> ${rec.impact}
                                </div>
                            </div>
                        `).join('');
                    })()}
                    <p style="margin-top: 15px; text-align: center; color: #666; font-style: italic;">
                        View more recommendations in the <strong>üí° Insights</strong> tab
                    </p>
                </div>
            `;
            
            document.getElementById('overview').innerHTML = html;
            
            // Render charts
            setTimeout(() => {
                renderRevenueByLocationChart();
                renderRevenueByServiceChart();
                renderIntroSessionsChart();
            }, 100);
        }
        
        // FUNNEL TAB

        // RETENTION TAB
        function renderRetentionTab() {
            const data = filteredAppointments;
            const activeMemberEmails = getActiveMemberEmails();
            
            // Analyze client visits
            const clientVisits = {};
            const clientFirstVisit = {};
            const clientLastVisit = {};
            const clientRevenue = {};
            
            data.forEach(row => {
                const email = (row['Customer Email'] || '').toLowerCase().trim();
                if (!email) return;
                
                const date = parseDate(row['Appointment Date']);
                const revenue = parseFloat(row.Revenue || 0);
                // Only count revenue if customer is NOT an active member
                const revenueToAdd = activeMemberEmails.has(email) ? 0 : revenue;
                
                if (!clientVisits[email]) {
                    clientVisits[email] = 0;
                    clientFirstVisit[email] = date;
                    clientLastVisit[email] = date;
                    clientRevenue[email] = 0;
                }
                
                clientVisits[email]++;
                clientRevenue[email] += revenueToAdd;
                
                if (date < clientFirstVisit[email]) clientFirstVisit[email] = date;
                if (date > clientLastVisit[email]) clientLastVisit[email] = date;
            });
            
            // Calculate metrics
            const uniqueClients = Object.keys(clientVisits).length;
            const returningClients = Object.values(clientVisits).filter(count => count > 1).length;
            const retentionRate = uniqueClients > 0 ? (returningClients / uniqueClients * 100) : 0;
            const avgVisitsPerClient = uniqueClients > 0 ? data.length / uniqueClients : 0;
            
            // Visit frequency distribution
            const visitDist = { '1 visit': 0, '2-3 visits': 0, '4-6 visits': 0, '7-10 visits': 0, '11+ visits': 0 };
            Object.values(clientVisits).forEach(count => {
                if (count === 1) visitDist['1 visit']++;
                else if (count <= 3) visitDist['2-3 visits']++;
                else if (count <= 6) visitDist['4-6 visits']++;
                else if (count <= 10) visitDist['7-10 visits']++;
                else visitDist['11+ visits']++;
            });
            
            // Calculate average days between visits
            let totalDaysBetween = 0;
            let visitPairs = 0;
            
            Object.keys(clientVisits).forEach(email => {
                if (clientVisits[email] > 1) {
                    const daysBetween = (clientLastVisit[email] - clientFirstVisit[email]) / (1000 * 60 * 60 * 24);
                    const avgDaysForClient = daysBetween / (clientVisits[email] - 1);
                    totalDaysBetween += avgDaysForClient;
                    visitPairs++;
                }
            });
            
            const avgDaysBetweenVisits = visitPairs > 0 ? totalDaysBetween / visitPairs : 0;
            
            // Top clients by visits
            const topClientsByVisits = Object.entries(clientVisits)
                .map(([email, visits]) => ({
                    email,
                    visits,
                    revenue: clientRevenue[email],
                    firstVisit: clientFirstVisit[email],
                    lastVisit: clientLastVisit[email]
                }))
                .sort((a, b) => b.visits - a.visits)
                .slice(0, 10);
            
            // Find client names from data
            const clientNames = {};
            data.forEach(row => {
                const email = (row['Customer Email'] || '').toLowerCase().trim();
                if (email && !clientNames[email]) {
                    clientNames[email] = row['Customer Name'] || email;
                }
            });
            
            let html = `
                <div class="metrics-grid" style="grid-template-columns: repeat(4, 1fr);">
                    <div class="metric-card">
                        <div class="metric-label">Total Clients</div>
                        <div class="metric-value">${formatNumber(uniqueClients)}</div>
                        <div class="metric-subtext">Unique individuals</div>
                    </div>
                    <div class="metric-card ${retentionRate >= 50 ? 'success' : retentionRate >= 30 ? 'warning' : 'danger'}">
                        <div class="metric-label">Retention Rate</div>
                        <div class="metric-value">${retentionRate.toFixed(1)}%</div>
                        <div class="metric-subtext">${formatNumber(returningClients)} returning clients</div>
                    </div>
                    <div class="metric-card">
                        <div class="metric-label">Avg Visits</div>
                        <div class="metric-value">${avgVisitsPerClient.toFixed(1)}</div>
                        <div class="metric-subtext">Per client</div>
                    </div>
                    <div class="metric-card">
                        <div class="metric-label">Avg Days Between</div>
                        <div class="metric-value">${avgDaysBetweenVisits.toFixed(0)}</div>
                        <div class="metric-subtext">Days between visits</div>
                    </div>
                </div>
                
                <div class="alert ${retentionRate >= 50 ? 'success' : 'warning'}">
                    <h4>üîÑ Retention Analysis</h4>
                    <p><strong>Current Status:</strong> ${retentionRate.toFixed(0)}% of clients return for additional appointments.</p>
                    <ul style="margin: 10px 0 0 20px; line-height: 1.8;">
                        <li>${visitDist['1 visit']} clients (${((visitDist['1 visit']/uniqueClients)*100).toFixed(0)}%) visited only once</li>
                        <li>Average ${avgDaysBetweenVisits.toFixed(0)} days between visits for returning clients</li>
                        <li>${returningClients} loyal clients generating repeat business</li>
                    </ul>
                    <p style="margin-top: 15px;"><strong>üí° Recommendations:</strong></p>
                    <ul style="margin: 5px 0 0 20px; line-height: 1.8;">
                        <li>Follow up with one-time visitors within ${Math.ceil(avgDaysBetweenVisits/2)} days</li>
                        <li>Create membership packages for ${visitDist['4-6 visits'] + visitDist['7-10 visits'] + visitDist['11+ visits']} frequent visitors</li>
                        <li>Send rebooking reminders every ${Math.floor(avgDaysBetweenVisits * 0.8)} days</li>
                    </ul>
                </div>
                
                <div class="table-container">
                    <h2>Visit Frequency Distribution</h2>
                    <div style="display: grid; grid-template-columns: repeat(auto-fit, minmax(150px, 1fr)); gap: 15px; margin: 20px 0;">
                        ${Object.entries(visitDist).map(([range, count]) => `
                            <div style="background: var(--gray-light); padding: 20px; border-radius: 8px; text-align: center; border-left: 4px solid var(--accent);">
                                <div style="font-size: 2.5em; font-weight: bold; color: var(--primary);">${formatNumber(count)}</div>
                                <div style="color: #666; font-size: 14px; margin-top: 5px;">${range} visit${range === '1' ? '' : 's'}</div>
                                <div style="color: var(--accent); font-size: 12px; margin-top: 3px;">${((count/uniqueClients)*100).toFixed(1)}%</div>
                            </div>
                        `).join('')}
                    </div>
                </div>
                
                <div class="table-container">
                    <h2>Top 10 Clients by Visit Frequency</h2>
                    <table>
                        <thead>
                            <tr>
                                <th>Rank</th>
                                <th>Client</th>
                                <th>Total Visits</th>
                                <th>Total Revenue</th>
                                <th>Avg/Visit</th>
                                <th>First Visit</th>
                                <th>Last Visit</th>
                                <th>Days Between</th>
                            </tr>
                        </thead>
                        <tbody>
                            ${topClientsByVisits.map((client, i) => {
                                const avgPerVisit = client.revenue / client.visits;
                                const daysBetween = client.visits > 1 
                                    ? Math.round((client.lastVisit - client.firstVisit) / (1000 * 60 * 60 * 24) / (client.visits - 1))
                                    : 'N/A';
                                return `
                                    <tr>
                                        <td><strong>${i === 0 ? 'ü•á' : i === 1 ? 'ü•à' : i === 2 ? 'ü•â' : i + 1}</strong></td>
                                        <td>${clientNames[client.email] || client.email}</td>
                                        <td><strong>${client.visits}</strong></td>
                                        <td>${formatCurrency(client.revenue)}</td>
                                        <td>${formatCurrency(avgPerVisit)}</td>
                                        <td>${client.firstVisit.toLocaleDateString()}</td>
                                        <td>${client.lastVisit.toLocaleDateString()}</td>
                                        <td>${daysBetween}</td>
                                    </tr>
                                `;
                            }).join('')}
                        </tbody>
                    </table>
                </div>
                
                <div class="table-container">
                    <h2>At-Risk Clients</h2>
                    <p style="margin-bottom: 15px; color: #666;">Returning clients who haven't visited in over ${Math.floor(avgDaysBetweenVisits * 1.5)} days (1.5x average gap)</p>
                    ${(() => {
                        const today = new Date();
                        const atRiskClients = topClientsByVisits
                            .filter(client => client.visits > 1)
                            .map(client => {
                                const daysSinceLastVisit = Math.floor((today - client.lastVisit) / (1000 * 60 * 60 * 24));
                                return { ...client, daysSinceLastVisit };
                            })
                            .filter(client => client.daysSinceLastVisit > avgDaysBetweenVisits * 1.5)
                            .sort((a, b) => b.revenue - a.revenue)
                            .slice(0, 20);
                        
                        if (atRiskClients.length === 0) {
                            return '<div class="alert success"><h4>üéâ Great News!</h4><p>No at-risk clients identified. All returning clients are visiting regularly!</p></div>';
                        }
                        
                        const totalAtRiskRevenue = atRiskClients.reduce((sum, c) => sum + c.revenue, 0);
                        
                        return `
                            <div class="alert warning">
                                <h4>üìä At-Risk Analysis</h4>
                                <p><strong>${atRiskClients.length} returning clients</strong> haven't visited recently. They represent <strong>${formatCurrency(totalAtRiskRevenue)}</strong> in historical revenue.</p>
                                <p style="margin-top: 10px;"><strong>Action:</strong> Reach out with a "We miss you" message and a special comeback offer.</p>
                            </div>
                            <table>
                                <thead>
                                    <tr>
                                        <th>Client</th>
                                        <th>Total Visits</th>
                                        <th>Revenue</th>
                                        <th>Last Visit</th>
                                        <th>Days Ago</th>
                                        <th>Status</th>
                                    </tr>
                                </thead>
                                <tbody>
                                    ${atRiskClients.map(client => {
                                        const urgency = client.daysSinceLastVisit > avgDaysBetweenVisits * 2 ? 'HIGH' : 'MEDIUM';
                                        const urgencyColor = urgency === 'HIGH' ? '#dc3545' : '#ffc107';
                                        return `
                                            <tr>
                                                <td>${clientNames[client.email] || client.email}</td>
                                                <td>${client.visits}</td>
                                                <td>${formatCurrency(client.revenue)}</td>
                                                <td>${client.lastVisit.toLocaleDateString()}</td>
                                                <td><strong>${client.daysSinceLastVisit}</strong> days</td>
                                                <td><span style="background: ${urgencyColor}; color: white; padding: 4px 12px; border-radius: 12px; font-size: 11px; font-weight: bold;">${urgency}</span></td>
                                            </tr>
                                        `;
                                    }).join('')}
                                </tbody>
                            </table>
                        `;
                    })()}
                </div>
                
                <div class="charts-grid">
                    <div class="chart-container">
                        <div class="interactive-badge" title="Click on any bar to see detailed client list"></div>
                        <h3>Visit Frequency Distribution</h3>
                        <div class="chart-wrapper">
                            <canvas id="visitFrequencyChart"></canvas>
                        </div>
                    </div>
                    
                    <div class="chart-container">
                        <div class="interactive-badge" title="Click on any segment to see client details"></div>
                        <h3>Retention Breakdown</h3>
                        <div class="chart-wrapper">
                            <canvas id="retentionBreakdownChart"></canvas>
                        </div>
                    </div>
                </div>
            `;
            
            document.getElementById('retention').innerHTML = html;
            
            // Render charts
            setTimeout(() => {
                renderVisitFrequencyChart(visitDist);
                renderRetentionBreakdownChart(uniqueClients - returningClients, returningClients);
            }, 100);
        }
        
        // SCHEDULE OPTIMIZATION TAB
        function renderScheduleTab() {
            const data = filteredAppointments;
            
            // Group appointments by practitioner and date
            const scheduleByPractitioner = {};
            
            data.forEach(row => {
                const practitioner = `${row['Practitioner First Name']} ${row['Practitioner Last Name']}`;
                const date = parseDate(row['Appointment Date']);
                const dateKey = date.toLocaleDateString();
                
                if (!scheduleByPractitioner[practitioner]) {
                    scheduleByPractitioner[practitioner] = {};
                }
                
                if (!scheduleByPractitioner[practitioner][dateKey]) {
                    scheduleByPractitioner[practitioner][dateKey] = [];
                }
                
                scheduleByPractitioner[practitioner][dateKey].push({
                    time: date,
                    duration: parseFloat(row['Time (h)'] || 0),
                    revenue: parseFloat(row.Revenue || 0),
                    service: row['Appointment'] || 'Unknown'
                });
            });
            
            // Calculate gaps and efficiency
            const gapAnalysis = [];
            let totalGaps = 0;
            let totalGapMinutes = 0;
            let totalWorkingHours = 0;
            let totalPayout = 0;
            let totalRevenueForPayout = 0;
            
            Object.entries(scheduleByPractitioner).forEach(([practitioner, dates]) => {
                Object.entries(dates).forEach(([date, appointments]) => {
                    // Sort by time
                    appointments.sort((a, b) => a.time - b.time);
                    
                    if (appointments.length < 2) return;
                    
                    let dayGaps = 0;
                    let dayGapMinutes = 0;
                    let dayWorkingHours = 0;
                    
                    // Calculate gaps between appointments
                    for (let i = 0; i < appointments.length - 1; i++) {
                        const current = appointments[i];
                        const next = appointments[i + 1];
                        
                        const currentEnd = new Date(current.time.getTime() + current.duration * 60 * 60 * 1000);
                        const gapMinutes = (next.time - currentEnd) / (1000 * 60);
                        
                        if (gapMinutes > 15) { // Consider gaps over 15 minutes
                            dayGaps++;
                            dayGapMinutes += gapMinutes;
                            totalGaps++;
                            totalGapMinutes += gapMinutes;
                        }
                        
                        dayWorkingHours += current.duration;
                    }
                    
                    if (appointments.length > 0) {
                        dayWorkingHours += appointments[appointments.length - 1].duration;
                    }
                    
                    totalWorkingHours += dayWorkingHours;
                    
                    const utilizationRate = dayWorkingHours > 0 
                        ? ((dayWorkingHours - (dayGapMinutes / 60)) / dayWorkingHours * 100) 
                        : 0;
                    
                    if (dayGaps > 0) {
                        gapAnalysis.push({
                            practitioner,
                            date,
                            appointments: appointments.length,
                            gaps: dayGaps,
                            gapMinutes: dayGapMinutes,
                            workingHours: dayWorkingHours,
                            utilizationRate,
                            potentialRevenue: (dayGapMinutes / 60) * 150
                        });
                    }
                });
            });
            
            // Calculate average hourly payout for lost wages calculation
            data.forEach(row => {
                totalPayout += parseFloat(row['Total Payout'] || 0);
                totalRevenueForPayout += parseFloat(row.Revenue || 0);
            });
            
            const avgPayoutRate = totalRevenueForPayout > 0 ? (totalPayout / totalRevenueForPayout) : 0.5;
            const avgHourlyRevenue = 150; // Assumed from potential revenue calc
            const avgHourlyPayout = avgHourlyRevenue * avgPayoutRate;
            const lostWages = (totalGapMinutes / 60) * avgHourlyPayout;
            
            // Sort by largest gaps
            gapAnalysis.sort((a, b) => b.gapMinutes - a.gapMinutes);
            
            // Calculate overall metrics
            const avgGapMinutes = totalGaps > 0 ? totalGapMinutes / totalGaps : 0;
            const overallUtilization = totalWorkingHours > 0 
                ? ((totalWorkingHours - (totalGapMinutes / 60)) / totalWorkingHours * 100) 
                : 0;
            const potentialRevenue = (totalGapMinutes / 60) * 150;
            const costOfGap = potentialRevenue - lostWages; // Business lost profit (revenue that would have stayed with business)
            
            let html = `
                <div class="metrics-grid" style="grid-template-columns: repeat(6, 1fr);">
                    <div class="metric-card ${overallUtilization >= 80 ? 'success' : overallUtilization >= 60 ? 'warning' : 'danger'}">
                        <div class="metric-label">Schedule Efficiency</div>
                        <div class="metric-value">${overallUtilization.toFixed(1)}%</div>
                        <div class="metric-subtext">Overall utilization</div>
                    </div>
                    <div class="metric-card">
                        <div class="metric-label">Total Gaps</div>
                        <div class="metric-value">${formatNumber(totalGaps)}</div>
                        <div class="metric-subtext">${(totalGapMinutes / 60).toFixed(1)} hours</div>
                    </div>
                    <div class="metric-card">
                        <div class="metric-label">Avg Gap Duration</div>
                        <div class="metric-value">${avgGapMinutes.toFixed(0)} min</div>
                        <div class="metric-subtext">Per gap</div>
                    </div>
                    <div class="metric-card warning">
                        <div class="metric-label">Cost of Gap</div>
                        <div class="metric-value">${formatCurrency(costOfGap)}</div>
                        <div class="metric-subtext">Lost business profit</div>
                    </div>
                    <div class="metric-card danger">
                        <div class="metric-label">Lost Wages</div>
                        <div class="metric-value">${formatCurrency(lostWages)}</div>
                        <div class="metric-subtext">VSP opportunity cost</div>
                    </div>
                    <div class="metric-card success">
                        <div class="metric-label">Potential Revenue</div>
                        <div class="metric-value">${formatCurrency(potentialRevenue)}</div>
                        <div class="metric-subtext">From filling gaps</div>
                    </div>
                </div>
                
                <div class="table-container" style="position: relative;">
                    <div class="interactive-badge" title="Click any day to see detailed breakdown" style="position: absolute; top: 15px; right: 15px; display: flex;"></div>
                    <h2>Appointment Heatmap</h2>
                    <p style="margin-bottom: 15px; color: #666;">Busiest appointment times by day and hour (Monday-Saturday). Click any day to see detailed breakdown.</p>
                    <div id="heatmapContainer"></div>
                </div>
                
                <div class="alert ${overallUtilization >= 80 ? 'success' : overallUtilization >= 60 ? 'warning' : 'info'}">
                    <h4>‚è∞ Schedule Optimization Insights</h4>
                    <p>
                        ${overallUtilization >= 80 
                            ? '‚úÖ Excellent scheduling efficiency! Your practitioners have minimal gaps.' 
                            : overallUtilization >= 60
                            ? '‚ö†Ô∏è Good scheduling, but there are opportunities to fill gaps and increase revenue.'
                            : 'üìà Significant scheduling gaps detected. Optimizing could substantially increase revenue.'}
                    </p>
                    <ul style="margin: 10px 0 0 20px; line-height: 1.8;">
                        <li>Offer discounted "fill-in" appointments for last-minute bookings</li>
                        <li>Block schedule appointments closer together when possible</li>
                        <li>Consider adding express services (30-45 min) to fill small gaps</li>
                        <li>Review practitioner availability patterns to match demand</li>
                        <li><strong>Cost to business:</strong> ${formatCurrency(costOfGap)} in lost profit from scheduling gaps</li>
                        <li><strong>Lost wages for VSPs:</strong> ${formatCurrency(lostWages)} in opportunity cost</li>
                        <li><strong>Potential additional revenue:</strong> ${formatCurrency(potentialRevenue)} by filling all gaps</li>
                    </ul>
                </div>
                
                <div class="table-container">
                    <h2>Top 20 Days with Largest Scheduling Gaps</h2>
                    <p style="margin-bottom: 15px; color: #666;">Opportunities to optimize scheduling and increase revenue</p>
                    <table>
                        <thead>
                            <tr>
                                <th>Practitioner</th>
                                <th>Date</th>
                                <th>Appointments</th>
                                <th>Gaps</th>
                                <th>Gap Time</th>
                                <th>Utilization</th>
                                <th>Opportunity</th>
                            </tr>
                        </thead>
                        <tbody>
                            ${gapAnalysis.slice(0, 20).map(day => `
                                <tr>
                                    <td>${day.practitioner}</td>
                                    <td>${day.date}</td>
                                    <td>${day.appointments}</td>
                                    <td>${day.gaps}</td>
                                    <td>${day.gapMinutes.toFixed(0)} min</td>
                                    <td><span style="color: ${day.utilizationRate >= 80 ? 'var(--success)' : day.utilizationRate >= 60 ? 'var(--warning)' : 'var(--danger)'}">${day.utilizationRate.toFixed(1)}%</span></td>
                                    <td>${formatCurrency(day.potentialRevenue)}</td>
                                </tr>
                            `).join('')}
                        </tbody>
                    </table>
                </div>
            `;
            
            document.getElementById('schedule').innerHTML = html;
            
            // Render heatmap after setting innerHTML
            setTimeout(() => {
                renderHeatmap();
            }, 100);
        }
        
        // CLIENT SEGMENTATION FUNCTIONS
        function calculateClientSegments() {
            const today = new Date();
            const segments = {
                vip: [],
                atRisk: [],
                newClient: [],
                highFrequency: [],
                inactivePaidMember: []
            };
            
            // Create a map of customer data with visit information
            const customerMap = {};
            
            // Aggregate data from leadsData
            filteredLeads.forEach(lead => {
                const email = lead['E-mail'];
                if (email && !customerMap[email]) {
                    customerMap[email] = {
                        firstName: lead['First name'],
                        lastName: lead['Last name'],
                        email: email,
                        type: lead.Type,
                        ltv: parseFloat(lead.LTV || 0),
                        joinDate: lead['Join date'],
                        visits: [],
                        totalVisits: 0,
                        lastVisitDate: null,
                        hasActiveMembership: false,
                        membershipName: null,
                        membershipAmount: 0
                    };
                }
            });
            
            // Add membership information
            filteredMemberships.forEach(membership => {
                const email = membership['Customer Email'];
                const expired = membership.Expired === 'Yes';
                const frozen = membership.Frozen === 'Yes';
                
                if (email && customerMap[email] && !expired && !frozen) {
                    customerMap[email].hasActiveMembership = true;
                    customerMap[email].membershipName = membership['Membership Name'];
                    customerMap[email].membershipAmount = parseFloat(membership['Paid Amount'] || 0);
                }
            });
            
            // Add appointment visit data
            filteredAppointments.forEach(appt => {
                const email = appt['Customer Email'];
                const apptDate = new Date(appt['Appointment Date']);
                
                if (email && customerMap[email]) {
                    customerMap[email].visits.push(apptDate);
                    customerMap[email].totalVisits++;
                    
                    if (!customerMap[email].lastVisitDate || apptDate > customerMap[email].lastVisitDate) {
                        customerMap[email].lastVisitDate = apptDate;
                    }
                }
            });
            
            // Categorize customers into segments
            Object.values(customerMap).forEach(customer => {
                // VIP tier (>$2500 LTV)
                if (customer.ltv > 2500) {
                    segments.vip.push({...customer, segment: 'VIP'});
                }
                
                // Inactive Paid Member (has active membership but no visit in 30+ days)
                if (customer.hasActiveMembership) {
                    const daysSinceLastVisit = customer.lastVisitDate 
                        ? Math.floor((today - customer.lastVisitDate) / (1000 * 60 * 60 * 24))
                        : 999; // Large number if no visit ever
                    
                    if (daysSinceLastVisit >= 30) {
                        segments.inactivePaidMember.push({
                            ...customer, 
                            daysSinceLastVisit, 
                            segment: 'Inactive Paid Member'
                        });
                    }
                }
                
                // At-risk tier (haven't visited in 45+ days, with at least $50 revenue)
                if (customer.lastVisitDate) {
                    const daysSinceLastVisit = Math.floor((today - customer.lastVisitDate) / (1000 * 60 * 60 * 24));
                    if (daysSinceLastVisit >= 45 && customer.totalVisits > 0 && customer.ltv >= 50) {
                        segments.atRisk.push({...customer, daysSinceLastVisit, segment: 'At-Risk'});
                    }
                }
                
                // New client tier (<3 visits, with at least $50 revenue)
                if (customer.totalVisits > 0 && customer.totalVisits < 3 && customer.ltv >= 50) {
                    segments.newClient.push({...customer, segment: 'New Client'});
                }
                
                // High-frequency tier (weekly visitors - 4+ visits per month)
                if (customer.visits.length >= 4) {
                    // Calculate visit frequency
                    const sortedVisits = customer.visits.sort((a, b) => a - b);
                    const firstVisit = sortedVisits[0];
                    const lastVisit = sortedVisits[sortedVisits.length - 1];
                    const daysBetween = Math.floor((lastVisit - firstVisit) / (1000 * 60 * 60 * 24)) || 1;
                    const visitsPerWeek = (customer.visits.length / daysBetween) * 7;
                    
                    if (visitsPerWeek >= 1) {
                        segments.highFrequency.push({...customer, visitsPerWeek, segment: 'High-Frequency'});
                    }
                }
            });
            
            return segments;
        }
        
        function downloadSegmentCSV(segmentName, segmentData) {
            if (segmentData.length === 0) {
                alert('No clients in this segment to download.');
                return;
            }
            
            // Prepare CSV data
            const headers = ['First Name', 'Last Name', 'Email', 'Type', 'LTV', 'Total Visits', 'Last Visit Date', 'Membership', 'Membership Amount', 'Segment Info'];
            const rows = segmentData.map(client => {
                let segmentInfo = '';
                if (client.daysSinceLastVisit !== undefined) {
                    segmentInfo = `${client.daysSinceLastVisit} days since last visit`;
                } else if (client.visitsPerWeek !== undefined) {
                    segmentInfo = `${client.visitsPerWeek.toFixed(1)} visits/week`;
                } else {
                    segmentInfo = client.segment;
                }
                
                return [
                    client.firstName || '',
                    client.lastName || '',
                    client.email || '',
                    client.type || '',
                    client.ltv.toFixed(2),
                    client.totalVisits,
                    client.lastVisitDate ? client.lastVisitDate.toLocaleDateString() : 'N/A',
                    client.membershipName || 'None',
                    client.membershipAmount ? client.membershipAmount.toFixed(2) : '0.00',
                    segmentInfo
                ];
            });
            
            // Create CSV content
            let csvContent = headers.join(',') + '\\n';
            csvContent += rows.map(row => row.map(cell => `"${cell}"`).join(',')).join('\\n');
            
            // Create download link
            const blob = new Blob([csvContent], { type: 'text/csv;charset=utf-8;' });
            const link = document.createElement('a');
            const url = URL.createObjectURL(blob);
            
            link.setAttribute('href', url);
            link.setAttribute('download', `${segmentName.replace(/\\s+/g, '_')}_Segment_${new Date().toISOString().split('T')[0]}.csv`);
            link.style.visibility = 'hidden';
            
            document.body.appendChild(link);
            link.click();
            document.body.removeChild(link);
        }
        
        function showSegmentDetails(segmentName, segmentData) {
            if (segmentData.length === 0) {
                alert('No clients in this segment.');
                return;
            }
            
            // Sort by LTV descending
            const sortedData = [...segmentData].sort((a, b) => b.ltv - a.ltv);
            const totalLTV = sortedData.reduce((sum, c) => sum + c.ltv, 0);
            const avgLTV = totalLTV / sortedData.length;
            const totalVisits = sortedData.reduce((sum, c) => sum + c.totalVisits, 0);
            const totalMembershipRevenue = sortedData.reduce((sum, c) => sum + (c.membershipAmount || 0), 0);
            
            // Determine if this is the inactive paid member segment
            const isInactivePaidSegment = segmentName.includes('Inactive Paid');
            
            let tableRows = sortedData.slice(0, 100).map((client, i) => {
                let extraInfo = '';
                if (client.daysSinceLastVisit !== undefined) {
                    extraInfo = `${client.daysSinceLastVisit} days ago`;
                } else if (client.visitsPerWeek !== undefined) {
                    extraInfo = `${client.visitsPerWeek.toFixed(1)}/week`;
                } else {
                    extraInfo = client.lastVisitDate ? client.lastVisitDate.toLocaleDateString() : 'N/A';
                }
                
                const membershipInfo = client.membershipName ? `${client.membershipName}<br><small>${formatCurrency(client.membershipAmount)}/mo</small>` : 'None';
                
                return `
                    <tr>
                        <td>${i + 1}</td>
                        <td>${client.firstName} ${client.lastName}</td>
                        <td>${client.email}</td>
                        <td><strong>${formatCurrency(client.ltv)}</strong></td>
                        <td>${client.totalVisits}</td>
                        ${isInactivePaidSegment ? `<td>${membershipInfo}</td>` : ''}
                        <td>${extraInfo}</td>
                    </tr>
                `;
            }).join('');
            
            if (sortedData.length > 100) {
                tableRows += `<tr><td colspan="${isInactivePaidSegment ? 7 : 6}" style="text-align: center; color: #666; font-style: italic;">Showing first 100 of ${sortedData.length} clients. Download CSV for complete list.</td></tr>`;
            }
            
            const modalBody = `
                <div class="modal-section">
                    <h4>üìä ${segmentName} Segment Overview</h4>
                    <div class="modal-highlight">
                        <strong>Total Clients:</strong> ${formatNumber(sortedData.length)}<br>
                        <strong>Total LTV:</strong> ${formatCurrency(totalLTV)}<br>
                        <strong>Average LTV:</strong> ${formatCurrency(avgLTV)}<br>
                        <strong>Total Visits:</strong> ${formatNumber(totalVisits)}
                        ${isInactivePaidSegment ? `<br><strong>Monthly Membership Revenue:</strong> ${formatCurrency(totalMembershipRevenue)}` : ''}
                    </div>
                </div>
                
                <div class="modal-section">
                    <h4>üë• Client List</h4>
                    <button class="csv-export-btn" onclick="downloadSegmentCSV('${segmentName}', currentSegmentData)" style="margin-bottom: 15px;">
                        Download Complete List
                    </button>
                    <table class="modal-table">
                        <thead>
                            <tr>
                                <th>#</th>
                                <th>Name</th>
                                <th>Email</th>
                                <th>LTV</th>
                                <th>Visits</th>
                                ${isInactivePaidSegment ? '<th>Membership</th>' : ''}
                                <th>Additional Info</th>
                            </tr>
                        </thead>
                        <tbody>
                            ${tableRows}
                        </tbody>
                    </table>
                </div>
            `;
            
            // Store current segment data globally for download
            window.currentSegmentData = segmentData;
            
            document.getElementById('modalTitle').textContent = `${segmentName} Segment Details`;
            document.getElementById('modalBody').innerHTML = modalBody;
            document.getElementById('dataModal').classList.add('show');
        }
        
        function renderClientSegmentation() {
            const segments = calculateClientSegments();
            
            // Calculate summary stats
            const totalSegmented = segments.vip.length + segments.atRisk.length + 
                                   segments.newClient.length + segments.highFrequency.length +
                                   segments.inactivePaidMember.length;
            const vipRevenue = segments.vip.reduce((sum, c) => sum + c.ltv, 0);
            const atRiskRevenue = segments.atRisk.reduce((sum, c) => sum + c.ltv, 0);
            const inactiveMemberRevenue = segments.inactivePaidMember.reduce((sum, c) => sum + c.membershipAmount, 0);
            const newClientPotential = segments.newClient.length * (filteredLeads.reduce((sum, l) => sum + parseFloat(l.LTV || 0), 0) / filteredLeads.length);
            
            return `
                <div class="segmentation-container">
                    <div class="segmentation-header">
                        <h2>Advanced Client Segmentation</h2>
                        <p style="color: #666; font-size: 14px;">Strategic client groups for targeted engagement and retention</p>
                    </div>
                    
                    <div class="segmentation-grid">
                        <!-- VIP Tier -->
                        <div class="segment-card vip">
                            <div class="segment-icon">üëë</div>
                            <div class="segment-title">VIP Clients</div>
                            <div class="segment-description">High-value clients with >$2,500 lifetime value</div>
                            <div class="segment-count">${formatNumber(segments.vip.length)}</div>
                            <div class="segment-stats">
                                <div class="segment-stats-row">
                                    <span>Total Revenue:</span>
                                    <strong>${formatCurrency(vipRevenue)}</strong>
                                </div>
                                <div class="segment-stats-row">
                                    <span>Avg LTV:</span>
                                    <strong>${segments.vip.length > 0 ? formatCurrency(vipRevenue / segments.vip.length) : '$0'}</strong>
                                </div>
                            </div>
                            <div class="segment-actions">
                                <button class="segment-btn view" onclick="showSegmentDetails('VIP Clients', currentSegments.vip)">
                                    üëÅÔ∏è View
                                </button>
                                <button class="segment-btn download" onclick="downloadSegmentCSV('VIP_Clients', currentSegments.vip)">
                                    üì• Export
                                </button>
                            </div>
                        </div>
                        
                        <!-- Inactive Paid Member Tier -->
                        <div class="segment-card inactive-paid">
                            <div class="segment-icon">üí≥</div>
                            <div class="segment-title">Inactive Paid Members</div>
                            <div class="segment-description">Active membership, no visit in 30+ days</div>
                            <div class="segment-count">${formatNumber(segments.inactivePaidMember.length)}</div>
                            <div class="segment-stats">
                                <div class="segment-stats-row">
                                    <span>Monthly Revenue:</span>
                                    <strong>${formatCurrency(inactiveMemberRevenue)}</strong>
                                </div>
                                <div class="segment-stats-row">
                                    <span>Avg Days Absent:</span>
                                    <strong>${segments.inactivePaidMember.length > 0 ? Math.round(segments.inactivePaidMember.reduce((sum, c) => sum + c.daysSinceLastVisit, 0) / segments.inactivePaidMember.length) : 0}</strong>
                                </div>
                            </div>
                            <div class="segment-actions">
                                <button class="segment-btn view" onclick="showSegmentDetails('Inactive Paid Members', currentSegments.inactivePaidMember)">
                                    üëÅÔ∏è View
                                </button>
                                <button class="segment-btn download" onclick="downloadSegmentCSV('Inactive_Paid_Members', currentSegments.inactivePaidMember)">
                                    üì• Export
                                </button>
                            </div>
                        </div>
                        
                        <!-- At-Risk Tier -->
                        <div class="segment-card at-risk">
                            <div class="segment-icon">‚ö†Ô∏è</div>
                            <div class="segment-title">At-Risk Clients</div>
                            <div class="segment-description">No visit in 45+ days, needs re-engagement</div>
                            <div class="segment-count">${formatNumber(segments.atRisk.length)}</div>
                            <div class="segment-stats">
                                <div class="segment-stats-row">
                                    <span>Revenue at Risk:</span>
                                    <strong>${formatCurrency(atRiskRevenue)}</strong>
                                </div>
                                <div class="segment-stats-row">
                                    <span>Avg Days Absent:</span>
                                    <strong>${segments.atRisk.length > 0 ? Math.round(segments.atRisk.reduce((sum, c) => sum + c.daysSinceLastVisit, 0) / segments.atRisk.length) : 0}</strong>
                                </div>
                            </div>
                            <div class="segment-actions">
                                <button class="segment-btn view" onclick="showSegmentDetails('At-Risk Clients', currentSegments.atRisk)">
                                    üëÅÔ∏è View
                                </button>
                                <button class="segment-btn download" onclick="downloadSegmentCSV('At_Risk_Clients', currentSegments.atRisk)">
                                    üì• Export
                                </button>
                            </div>
                        </div>
                        
                        <!-- New Client Tier -->
                        <div class="segment-card new-client">
                            <div class="segment-icon">üå±</div>
                            <div class="segment-title">New Clients</div>
                            <div class="segment-description">Less than 3 visits, high growth potential</div>
                            <div class="segment-count">${formatNumber(segments.newClient.length)}</div>
                            <div class="segment-stats">
                                <div class="segment-stats-row">
                                    <span>Current LTV:</span>
                                    <strong>${formatCurrency(segments.newClient.reduce((sum, c) => sum + c.ltv, 0))}</strong>
                                </div>
                                <div class="segment-stats-row">
                                    <span>Growth Potential:</span>
                                    <strong>${formatCurrency(newClientPotential)}</strong>
                                </div>
                            </div>
                            <div class="segment-actions">
                                <button class="segment-btn view" onclick="showSegmentDetails('New Clients', currentSegments.newClient)">
                                    üëÅÔ∏è View
                                </button>
                                <button class="segment-btn download" onclick="downloadSegmentCSV('New_Clients', currentSegments.newClient)">
                                    üì• Export
                                </button>
                            </div>
                        </div>
                        
                        <!-- High-Frequency Tier -->
                        <div class="segment-card high-frequency">
                            <div class="segment-icon">‚ö°</div>
                            <div class="segment-title">High-Frequency</div>
                            <div class="segment-description">Weekly visitors, highly engaged clients</div>
                            <div class="segment-count">${formatNumber(segments.highFrequency.length)}</div>
                            <div class="segment-stats">
                                <div class="segment-stats-row">
                                    <span>Total Revenue:</span>
                                    <strong>${formatCurrency(segments.highFrequency.reduce((sum, c) => sum + c.ltv, 0))}</strong>
                                </div>
                                <div class="segment-stats-row">
                                    <span>Total Visits:</span>
                                    <strong>${formatNumber(segments.highFrequency.reduce((sum, c) => sum + c.totalVisits, 0))}</strong>
                                </div>
                            </div>
                            <div class="segment-actions">
                                <button class="segment-btn view" onclick="showSegmentDetails('High-Frequency Clients', currentSegments.highFrequency)">
                                    üëÅÔ∏è View
                                </button>
                                <button class="segment-btn download" onclick="downloadSegmentCSV('High_Frequency_Clients', currentSegments.highFrequency)">
                                    üì• Export
                                </button>
                            </div>
                        </div>
                    </div>
                    
                    <div class="segment-summary">
                        <h3>üìä Segmentation Summary</h3>
                        <div class="summary-grid">
                            <div class="summary-item">
                                <div class="summary-label">Total Segmented</div>
                                <div class="summary-value">${formatNumber(totalSegmented)}</div>
                            </div>
                            <div class="summary-item">
                                <div class="summary-label">VIP Revenue</div>
                                <div class="summary-value">${formatCurrency(vipRevenue)}</div>
                            </div>
                            <div class="summary-item">
                                <div class="summary-label">Unused Memberships</div>
                                <div class="summary-value" style="color: #ff9800;">${formatCurrency(inactiveMemberRevenue)}/mo</div>
                            </div>
                            <div class="summary-item">
                                <div class="summary-label">At-Risk Revenue</div>
                                <div class="summary-value" style="color: #dc3545;">${formatCurrency(atRiskRevenue)}</div>
                            </div>
                            <div class="summary-item">
                                <div class="summary-label">Growth Potential</div>
                                <div class="summary-value" style="color: #28a745;">${formatCurrency(newClientPotential)}</div>
                            </div>
                        </div>
                    </div>
                </div>
            `;
        }
        
        // CUSTOMERS TAB
        function renderCustomersTab() {
            if (filteredLeads.length === 0) {
                document.getElementById('customers').innerHTML = `
                    <div class="alert info">
                        <h4>üìä Customer Analytics</h4>
                        <p>Upload the Leads & Customers CSV file to unlock customer lifetime value analysis, conversion tracking, and segmentation insights.</p>
                    </div>
                `;
                return;
            }
            
            // Store segments globally for access in button clicks
            window.currentSegments = calculateClientSegments();
            
            // Calculate LTV metrics
            const ltvs = filteredLeads.map(row => parseFloat(row.LTV || 0));
            const totalLTV = ltvs.reduce((sum, ltv) => sum + ltv, 0);
            const avgLTV = totalLTV / ltvs.length;
            const maxLTV = Math.max(...ltvs);
            
            const customers = filteredLeads.filter(row => row.Type === 'Customer').length;
            const leads = filteredLeads.filter(row => row.Type === 'Lead').length;
            const conversionRate = ((customers / (customers + leads)) * 100).toFixed(1);
            
            const zeroLTV = ltvs.filter(ltv => ltv === 0).length;
            const tier1 = ltvs.filter(ltv => ltv > 0 && ltv <= 100).length;
            const tier2 = ltvs.filter(ltv => ltv > 100 && ltv <= 250).length;
            const tier3 = ltvs.filter(ltv => ltv > 250 && ltv <= 500).length;
            const tier4 = ltvs.filter(ltv => ltv > 500 && ltv <= 1000).length;
            const tier5 = ltvs.filter(ltv => ltv > 1000 && ltv <= 2000).length;
            const tier6 = ltvs.filter(ltv => ltv > 2000 && ltv <= 3000).length;
            const tier7 = ltvs.filter(ltv => ltv > 3000).length;
            
            // Top customers
            const sortedByLTV = [...filteredLeads]
                .sort((a, b) => parseFloat(b.LTV || 0) - parseFloat(a.LTV || 0))
                .slice(0, 10);
            
            let html = `
                <div class="alert ${zeroLTV > filteredLeads.length * 0.3 ? 'warning' : 'info'}">
                    <h3>üí∞ Revenue Opportunity</h3>
                    <p><strong>${formatNumber(zeroLTV)}</strong> customers have $0 lifetime value (${((zeroLTV/filteredLeads.length)*100).toFixed(1)}% of total).</p>
                    <p style="margin-top: 10px;"><strong>Potential Revenue:</strong> ${formatCurrency(zeroLTV * avgLTV)} if converted at average LTV</p>
                </div>
                
                ${renderClientSegmentation()}
                
                <div class="metrics-grid" style="grid-template-columns: repeat(4, 1fr);">
                    <div class="metric-card">
                        <div class="metric-label">Total LTV</div>
                        <div class="metric-value">${formatCurrency(totalLTV)}</div>
                        <div class="metric-subtext">All customers</div>
                    </div>
                    <div class="metric-card">
                        <div class="metric-label">Average LTV</div>
                        <div class="metric-value">${formatCurrency(avgLTV)}</div>
                        <div class="metric-subtext">Per customer</div>
                    </div>
                    <div class="metric-card">
                        <div class="metric-label">Conversion Rate</div>
                        <div class="metric-value">${conversionRate}%</div>
                        <div class="metric-subtext">${customers} customers | ${leads} leads</div>
                    </div>
                    <div class="metric-card">
                        <div class="metric-label">VIP Customers</div>
                        <div class="metric-value">${formatNumber(tier7)}</div>
                        <div class="metric-subtext">>$3,000 LTV</div>
                    </div>
                </div>
                
                <div style="background: #f8f9fa; padding: 20px; border-radius: 10px; margin-bottom: 30px; border-left: 4px solid #dc3545;">
                    <div style="display: flex; justify-content: space-between; align-items: center;">
                        <div>
                            <h3 style="margin: 0 0 5px 0; color: #dc3545;">‚ö†Ô∏è ${formatNumber(zeroLTV)} Customers at $0 LTV</h3>
                            <p style="margin: 0; color: #666;">These customers represent untapped revenue potential</p>
                        </div>
                        <div style="text-align: right;">
                            <div style="font-size: 12px; color: #666;">Percentage of Total</div>
                            <div style="font-size: 32px; font-weight: bold; color: #dc3545;">${((zeroLTV/filteredLeads.length)*100).toFixed(1)}%</div>
                        </div>
                    </div>
                </div>
                
                <div class="charts-grid">
                    <div class="chart-container">
                        <div class="interactive-badge" title="Click on any bar to see customer list"></div>
                        <h3>LTV Distribution (Customers with Revenue)</h3>
                        <div class="chart-wrapper">
                            <canvas id="ltvDistributionChart"></canvas>
                        </div>
                    </div>
                    
                    <div class="chart-container">
                        <h3>Customer Types</h3>
                        <div class="chart-wrapper">
                            <canvas id="customerTypesChart"></canvas>
                        </div>
                    </div>
                </div>
                
                <div class="table-container">
                    <h2>Top 10 Customers by Lifetime Value</h2>
                    <table>
                        <thead>
                            <tr>
                                <th>Rank</th>
                                <th>Name</th>
                                <th>Email</th>
                                <th>Type</th>
                                <th>First Purchase</th>
                                <th>LTV</th>
                            </tr>
                        </thead>
                        <tbody>
                            ${sortedByLTV.map((c, i) => `
                                <tr>
                                    <td><strong>${i === 0 ? 'ü•á' : i === 1 ? 'ü•à' : i === 2 ? 'ü•â' : i + 1}</strong></td>
                                    <td>${c['First name']} ${c['Last name']}</td>
                                    <td>${c['E-mail']}</td>
                                    <td>${c.Type}</td>
                                    <td>${c['First purchase'] || 'N/A'}</td>
                                    <td><strong>${formatCurrency(parseFloat(c.LTV || 0))}</strong></td>
                                </tr>
                            `).join('')}
                        </tbody>
                    </table>
                </div>
            `;
            
            document.getElementById('customers').innerHTML = html;
            
            // Render charts
            setTimeout(() => {
                renderLTVDistributionChart(tier1, tier2, tier3, tier4, tier5, tier6, tier7);
                renderCustomerTypesChart(customers, leads);
            }, 100);
        }
        
        // PRACTITIONERS TAB
        function renderPractitionersTab() {
            const data = filteredAppointments;
            const activeMemberEmails = getActiveMemberEmails();
            
            // Calculate comprehensive metrics for each practitioner (from leaderboard)
            const practitionerStats = {};
            
            data.forEach(row => {
                const name = `${row['Practitioner First Name']} ${row['Practitioner Last Name']}`.trim();
                if (!name) return;
                
                if (!practitionerStats[name]) {
                    practitionerStats[name] = {
                        revenue: 0,
                        appointments: 0,
                        clients: new Set(),
                        hours: 0,
                        payout: 0,
                        lateCancel: 0,
                        services: new Set()
                    };
                }
                
                const email = (row['Customer Email'] || '').toLowerCase().trim();
                const revenue = parseFloat(row.Revenue || 0);
                // Only count revenue if customer is NOT an active member
                const revenueToAdd = activeMemberEmails.has(email) ? 0 : revenue;
                
                practitionerStats[name].revenue += revenueToAdd;
                practitionerStats[name].appointments++;
                practitionerStats[name].clients.add(email);
                practitionerStats[name].hours += parseFloat(row['Time (h)'] || 0);
                practitionerStats[name].payout += parseFloat(row['Total Payout'] || 0);
                if (row['Late cancellations'] && row['Late cancellations'].toLowerCase() === 'yes') {
                    practitionerStats[name].lateCancel++;
                }
                practitionerStats[name].services.add(row.Appointment);
            });
            
            // Calculate scores and rankings
            const practitioners = Object.entries(practitionerStats).map(([name, stats]) => {
                const clientCount = stats.clients.size;
                const revenuePerHour = stats.hours > 0 ? stats.revenue / stats.hours : 0;
                const revenuePerAppt = stats.appointments > 0 ? stats.revenue / stats.appointments : 0;
                const lateCancelRate = stats.appointments > 0 ? (stats.lateCancel / stats.appointments) * 100 : 0;
                const profit = stats.revenue - stats.payout;
                const profitMargin = stats.revenue > 0 ? (profit / stats.revenue) * 100 : 0;
                
                // Get utilization data if available from zip file
                const employeeName = name.toLowerCase().replace(/\s+/g, ' ');
                let utilization = null;
                let clockedHours = 0;
                let shiftCount = 0;
                
                if (window.employeeUtilization) {
                    for (const [empName, empData] of Object.entries(window.employeeUtilization)) {
                        if (empName.toLowerCase().replace(/\s+/g, ' ') === employeeName) {
                            utilization = empData.utilization;
                            clockedHours = empData.totalClockedHours;
                            shiftCount = empData.shiftCount;
                            break;
                        }
                    }
                }
                
                // Get commission data if available (Membership & Product only)
                let commissions = 0;
                let commissionCount = 0;
                if (window.filteredCommissions && window.filteredCommissions.length > 0) {
                    const employeeCommissions = window.filteredCommissions.filter(c => {
                        const commEmpName = (c['Employee Name'] || '').toLowerCase().replace(/\s+/g, ' ');
                        return commEmpName === employeeName;
                    });
                    
                    commissions = employeeCommissions.reduce((sum, c) => {
                        return sum + (parseFloat(c['Commissions earned']) || 0);
                    }, 0);
                    commissionCount = employeeCommissions.length;
                }
                
                // Calculate overall score (weighted)
                const revenueScore = stats.revenue / 100; // $100 = 1 point
                const efficiencyScore = revenuePerHour * 2; // $1/hr = 2 points
                const clientScore = clientCount * 5; // 1 client = 5 points
                const consistencyScore = stats.appointments * 2; // 1 appt = 2 points
                const qualityScore = (100 - lateCancelRate) * 0.5; // Low cancellations = high score
                const utilizationScore = utilization !== null ? utilization * 0.5 : 0; // 1% utilization = 0.5 points
                const commissionScore = commissions / 10; // $10 commission = 1 point
                
                const totalScore = revenueScore + efficiencyScore + clientScore + consistencyScore + qualityScore + utilizationScore + commissionScore;
                
                return {
                    name,
                    revenue: stats.revenue,
                    appointments: stats.appointments,
                    clients: clientCount,
                    hours: stats.hours,
                    revenuePerHour,
                    revenuePerAppt,
                    lateCancelRate,
                    profit,
                    profitMargin,
                    services: stats.services.size,
                    score: totalScore,
                    payout: stats.payout,
                    utilization,
                    clockedHours,
                    shiftCount,
                    commissions,
                    commissionCount
                };
            });
            
            // Sort by score for leaderboard
            practitioners.sort((a, b) => b.score - a.score);
            
            // Create simplified practitionerData for existing charts
            const practitionerData = {};
            practitioners.forEach(p => {
                practitionerData[p.name] = {
                    appointments: p.appointments,
                    revenue: p.revenue,
                    payout: p.payout,
                    hours: p.hours
                };
            });
            
            let html = `
                <div class="alert info">
                    <h3>‚öïÔ∏è VSP Performance & Leaderboard</h3>
                    <p>Comprehensive performance metrics and rankings based on revenue, efficiency, client satisfaction, and consistency.</p>
                </div>
                
                <div class="metrics-grid" style="grid-template-columns: repeat(${practitioners.some(p => p.utilization !== null) ? (practitioners.some(p => p.commissions > 0) ? '6' : '5') : (practitioners.some(p => p.commissions > 0) ? '5' : '4')}, 1fr);">
                    <div class="metric-card">
                        <div class="metric-label">Top Performer</div>
                        <div class="metric-value" style="font-size: 1.5em;">${practitioners[0]?.name || 'N/A'}</div>
                        <div class="metric-subtext">${practitioners[0] ? formatNumber(practitioners[0].score) + ' points' : ''}</div>
                    </div>
                    <div class="metric-card">
                        <div class="metric-label">Highest Revenue</div>
                        <div class="metric-value">${formatCurrency(Math.max(...practitioners.map(p => p.revenue)))}</div>
                        <div class="metric-subtext">${practitioners.sort((a,b) => b.revenue - a.revenue)[0]?.name || 'N/A'}</div>
                    </div>
                    <div class="metric-card">
                        <div class="metric-label">Best Efficiency</div>
                        <div class="metric-value">${formatCurrency(Math.max(...practitioners.map(p => p.revenuePerHour)))}/hr</div>
                        <div class="metric-subtext">${practitioners.sort((a,b) => b.revenuePerHour - a.revenuePerHour)[0]?.name || 'N/A'}</div>
                    </div>
                    <div class="metric-card">
                        <div class="metric-label">Most Clients</div>
                        <div class="metric-value">${Math.max(...practitioners.map(p => p.clients))}</div>
                        <div class="metric-subtext">${practitioners.sort((a,b) => b.clients - a.clients)[0]?.name || 'N/A'}</div>
                    </div>
                    ${practitioners.some(p => p.utilization !== null) ? `
                    <div class="metric-card success">
                        <div class="metric-label">Avg Utilization</div>
                        <div class="metric-value">${(practitioners.filter(p => p.utilization !== null).reduce((sum, p) => sum + p.utilization, 0) / practitioners.filter(p => p.utilization !== null).length).toFixed(1)}%</div>
                        <div class="metric-subtext">Table time efficiency</div>
                    </div>
                    ` : ''}
                    ${practitioners.some(p => p.commissions > 0) ? `
                    <div class="metric-card" style="background: linear-gradient(135deg, rgba(40, 167, 69, 0.1), rgba(32, 201, 151, 0.05)); border-left: 4px solid #28a745;">
                        <div class="metric-label">Total Commissions</div>
                        <div class="metric-value">${formatCurrency(practitioners.reduce((sum, p) => sum + p.commissions, 0))}</div>
                        <div class="metric-subtext">Memberships & Products</div>
                    </div>
                    ` : ''}
                </div>
                
                <div class="charts-grid">
                    <div class="chart-container">
                        <div class="interactive-badge" title="Click on any VSP to see full details"></div>
                        <h3>Revenue by VSP</h3>
                        <div class="chart-wrapper">
                            <canvas id="practitionerRevenueChart"></canvas>
                        </div>
                    </div>
                    
                    <div class="chart-container">
                        <div class="interactive-badge" title="Click on any VSP to see full details"></div>
                        <h3>Appointments by VSP</h3>
                        <div class="chart-wrapper">
                            <canvas id="practitionerApptsChart"></canvas>
                        </div>
                    </div>
                </div>
            `;
            
            // Re-sort by score for leaderboard display
            practitioners.sort((a, b) => b.score - a.score);
            
            // Add leaderboard cards
            practitioners.forEach((p, index) => {
                const rank = index + 1;
                const rankClass = rank === 1 ? 'gold' : rank === 2 ? 'silver' : rank === 3 ? 'bronze' : 'other';
                const medal = rank === 1 ? 'ü•á' : rank === 2 ? 'ü•à' : rank === 3 ? 'ü•â' : rank;
                
                html += `
                    <div class="leaderboard-card">
                        <div class="leaderboard-content">
                            <div style="display: flex; align-items: center;">
                                <div class="leaderboard-rank ${rankClass}">${medal}</div>
                                <div class="leaderboard-info">
                                    <div class="leaderboard-name">${p.name}</div>
                                    <div class="leaderboard-stats">
                                        <div class="leaderboard-stat">
                                            <strong>${formatCurrency(p.revenue)}</strong> Revenue
                                        </div>
                                        <div class="leaderboard-stat">
                                            <strong>${formatNumber(p.appointments)}</strong> Appointments
                                        </div>
                                        <div class="leaderboard-stat">
                                            <strong>${formatNumber(p.clients)}</strong> Clients
                                        </div>
                                        <div class="leaderboard-stat">
                                            <strong>${formatCurrency(p.revenuePerHour)}/hr</strong> Efficiency
                                        </div>
                                        ${p.utilization !== null ? `
                                        <div class="leaderboard-stat">
                                            <strong>${p.utilization.toFixed(1)}%</strong> Utilization
                                        </div>
                                        ` : ''}
                                        ${p.commissions > 0 ? `
                                        <div class="leaderboard-stat">
                                            <strong>${formatCurrency(p.commissions)}</strong> Commissions
                                        </div>
                                        ` : ''}
                                        <div class="leaderboard-stat">
                                            <strong>${p.profitMargin.toFixed(0)}%</strong> Margin
                                        </div>
                                        <div class="leaderboard-stat">
                                            <strong>${p.lateCancelRate.toFixed(1)}%</strong> Late Cancel
                                        </div>
                                    </div>
                                </div>
                            </div>
                            <div class="leaderboard-score">
                                <div class="leaderboard-score-label">Score</div>
                                <div class="leaderboard-score-value">${formatNumber(p.score)}</div>
                            </div>
                        </div>
                    </div>
                `;
            });
            
            html += `
                <div class="table-container">
                    <h2>Detailed Performance Metrics</h2>
                    <table>
                        <thead>
                            <tr>
                                <th>Rank</th>
                                <th>VSP</th>
                                <th>Score</th>
                                <th>Revenue</th>
                                <th>Appts</th>
                                <th>$/Hour</th>
                                <th>$/Appt</th>
                                <th>Clients</th>
                                ${practitioners.some(p => p.utilization !== null) ? '<th>Utilization</th>' : ''}
                                ${practitioners.some(p => p.commissions > 0) ? '<th>Commissions</th>' : ''}
                                <th>Profit %</th>
                            </tr>
                        </thead>
                        <tbody>
                            ${practitioners.map((p, i) => `
                                <tr>
                                    <td><strong>${i + 1}</strong></td>
                                    <td>${p.name}</td>
                                    <td><strong>${formatNumber(p.score)}</strong></td>
                                    <td>${formatCurrency(p.revenue)}</td>
                                    <td>${formatNumber(p.appointments)}</td>
                                    <td>${formatCurrency(p.revenuePerHour)}</td>
                                    <td>${formatCurrency(p.revenuePerAppt)}</td>
                                    <td>${formatNumber(p.clients)}</td>
                                    ${p.utilization !== null ? `<td>${p.utilization.toFixed(1)}%</td>` : (practitioners.some(pr => pr.utilization !== null) ? '<td>-</td>' : '')}
                                    ${p.commissions > 0 ? `<td>${formatCurrency(p.commissions)}</td>` : (practitioners.some(pr => pr.commissions > 0) ? '<td>-</td>' : '')}
                                    <td>${p.profitMargin.toFixed(1)}%</td>
                                </tr>
                            `).join('')}
                        </tbody>
                    </table>
                </div>
                
                <div class="alert success">
                    <h4>üéØ Performance Insights</h4>
                    <ul style="margin: 10px 0 0 20px; line-height: 1.8;">
                        <li><strong>Top Performer:</strong> ${practitioners[0]?.name} leads with ${formatNumber(practitioners[0]?.score)} points, excelling in overall performance.</li>
                        <li><strong>Revenue Leader:</strong> ${practitioners.sort((a,b) => b.revenue - a.revenue)[0]?.name} generated ${formatCurrency(practitioners.sort((a,b) => b.revenue - a.revenue)[0]?.revenue)} in revenue.</li>
                        <li><strong>Efficiency Champion:</strong> ${practitioners.sort((a,b) => b.revenuePerHour - a.revenuePerHour)[0]?.name} achieves ${formatCurrency(practitioners.sort((a,b) => b.revenuePerHour - a.revenuePerHour)[0]?.revenuePerHour)}/hour.</li>
                        <li><strong>Client Favorite:</strong> ${practitioners.sort((a,b) => b.clients - a.clients)[0]?.name} serves ${practitioners.sort((a,b) => b.clients - a.clients)[0]?.clients} unique clients.</li>
                    </ul>
                </div>
            `;
            
            document.getElementById('practitioners').innerHTML = html;
            
            // Render charts
            setTimeout(() => {
                renderPractitionerCharts(practitionerData);
            }, 100);
        }
        
        // TIMELINE TAB
        function renderTimelineTab() {
            const data = filteredAppointments;
            const activeMemberEmails = getActiveMemberEmails();
            
            // Group by date with comprehensive metrics
            const dailyData = {};
            const clientsByDate = {};
            
            data.forEach(row => {
                const date = parseDate(row['Appointment Date']).toLocaleDateString();
                if (!dailyData[date]) {
                    dailyData[date] = { 
                        revenue: 0, 
                        appointments: 0, 
                        hours: 0,
                        payout: 0,
                        profit: 0,
                        newClients: new Set(),
                        returningClients: new Set(),
                        apptHours: 0,  // For utilization calculation
                        clockedHours: 0  // For utilization calculation
                    };
                    clientsByDate[date] = new Set();
                }
                
                const revenue = parseFloat(row.Revenue || 0);
                const payout = parseFloat(row['Total Payout'] || 0);
                const email = (row['Customer Email'] || '').toLowerCase().trim();
                
                // Only count revenue if customer is NOT an active member
                const revenueToAdd = activeMemberEmails.has(email) ? 0 : revenue;
                
                dailyData[date].revenue += revenueToAdd;
                dailyData[date].appointments++;
                dailyData[date].hours += parseFloat(row['Time (h)'] || 0);
                dailyData[date].apptHours += parseFloat(row['Time (h)'] || 0);  // Track appointment hours
                dailyData[date].payout += payout;
                dailyData[date].profit += (revenueToAdd - payout);
                
                // Track new vs returning clients
                if (email) {
                    clientsByDate[date].add(email);
                    // Check if this client had appointments before this date
                    const priorAppointments = data.filter(r => {
                        const rDate = parseDate(r['Appointment Date']).toLocaleDateString();
                        const rEmail = (r['Customer Email'] || '').toLowerCase().trim();
                        return rEmail === email && new Date(rDate) < new Date(date);
                    });
                    
                    if (priorAppointments.length === 0) {
                        dailyData[date].newClients.add(email);
                    } else {
                        dailyData[date].returningClients.add(email);
                    }
                }
            });
            
            // Add clocked hours to daily data if time tracking is available
            if (window.timeTrackingData && window.timeTrackingData.length > 0) {
                window.timeTrackingData.forEach(row => {
                    const clockedIn = row['Clocked in'] ? new Date(row['Clocked in']) : null;
                    if (clockedIn) {
                        const date = clockedIn.toLocaleDateString();
                        if (dailyData[date]) {
                            dailyData[date].clockedHours += parseFloat(row['Duration (h)'] || 0);
                        }
                    }
                });
                
                // Calculate utilization for each day
                Object.keys(dailyData).forEach(date => {
                    if (dailyData[date].clockedHours > 0) {
                        dailyData[date].utilization = (dailyData[date].apptHours / dailyData[date].clockedHours) * 100;
                    } else {
                        dailyData[date].utilization = null;
                    }
                });
            }
            
            const dates = Object.keys(dailyData).sort((a, b) => new Date(a) - new Date(b));
            const avgDailyRevenue = dates.length > 0 
                ? Object.values(dailyData).reduce((sum, d) => sum + d.revenue, 0) / dates.length 
                : 0;
            const avgDailyAppointments = dates.length > 0
                ? Object.values(dailyData).reduce((sum, d) => sum + d.appointments, 0) / dates.length
                : 0;
            const avgDailyProfit = dates.length > 0
                ? Object.values(dailyData).reduce((sum, d) => sum + d.profit, 0) / dates.length
                : 0;
            
            // Calculate average daily utilization
            const daysWithUtilization = Object.values(dailyData).filter(d => d.utilization !== null && d.utilization !== undefined);
            const avgDailyUtilization = daysWithUtilization.length > 0
                ? daysWithUtilization.reduce((sum, d) => sum + d.utilization, 0) / daysWithUtilization.length
                : null;
            
            const bestDay = dates.reduce((best, date) => {
                return dailyData[date].revenue > (dailyData[best]?.revenue || 0) ? date : best;
            }, dates[0]);
            
            const totalRevenue = Object.values(dailyData).reduce((sum, d) => sum + d.revenue, 0);
            
            let html = `
                <div class="metrics-grid" style="grid-template-columns: repeat(${avgDailyUtilization !== null ? '5' : '4'}, 1fr);">
                    <div class="metric-card">
                        <div class="metric-label">Avg Daily Revenue</div>
                        <div class="metric-value">${formatCurrency(avgDailyRevenue)}</div>
                        <div class="metric-subtext">Per business day</div>
                    </div>
                    <div class="metric-card">
                        <div class="metric-label">Avg Daily Appointments</div>
                        <div class="metric-value">${avgDailyAppointments.toFixed(1)}</div>
                        <div class="metric-subtext">Per business day</div>
                    </div>
                    <div class="metric-card">
                        <div class="metric-label">Avg Daily Profit</div>
                        <div class="metric-value">${formatCurrency(avgDailyProfit)}</div>
                        <div class="metric-subtext">After payouts</div>
                    </div>
                    ${avgDailyUtilization !== null ? `
                    <div class="metric-card success">
                        <div class="metric-label">Avg Daily Utilization</div>
                        <div class="metric-value">${avgDailyUtilization.toFixed(1)}%</div>
                        <div class="metric-subtext">Table time efficiency</div>
                    </div>
                    ` : ''}
                    <div class="metric-card">
                        <div class="metric-label">Best Day</div>
                        <div class="metric-value">${formatCurrency(dailyData[bestDay]?.revenue || 0)}</div>
                        <div class="metric-subtext">${bestDay}</div>
                    </div>
                </div>
                
                <div class="charts-grid">
                    <div class="chart-container full-width">
                        <h3>Daily Revenue Trend</h3>
                        <div class="chart-wrapper">
                            <canvas id="dailyRevenueChart"></canvas>
                        </div>
                    </div>
                    
                    <div class="chart-container full-width">
                        <h3>Daily Appointments</h3>
                        <div class="chart-wrapper">
                            <canvas id="dailyAppointmentsChart"></canvas>
                        </div>
                    </div>
                    
                    ${avgDailyUtilization !== null ? `
                    <div class="chart-container full-width">
                        <h3>Daily Utilization Trend</h3>
                        <div class="chart-wrapper">
                            <canvas id="dailyUtilizationChart"></canvas>
                        </div>
                    </div>
                    ` : ''}
                    
                    <div class="chart-container full-width">
                        <h3>Cumulative Revenue Over Time</h3>
                        <div class="chart-wrapper">
                            <canvas id="cumulativeRevenueChart"></canvas>
                        </div>
                    </div>
                    
                    <div class="chart-container full-width">
                        <h3>Daily Profit Trend</h3>
                        <div class="chart-wrapper">
                            <canvas id="dailyProfitChart"></canvas>
                        </div>
                    </div>
                    
                    <div class="chart-container full-width">
                        <h3>Daily Revenue per Appointment (Efficiency)</h3>
                        <div class="chart-wrapper">
                            <canvas id="dailyRevenuePerApptChart"></canvas>
                        </div>
                    </div>
                    
                    <div class="chart-container full-width">
                        <h3>New vs Returning Clients Per Day</h3>
                        <div class="chart-wrapper">
                            <canvas id="dailyClientTypeChart"></canvas>
                        </div>
                    </div>
                    
                    <div class="chart-container full-width">
                        <h3>Daily Hours Worked</h3>
                        <div class="chart-wrapper">
                            <canvas id="dailyHoursChart"></canvas>
                        </div>
                    </div>
                    
                    <div class="chart-container full-width">
                        <h3>Weekly Membership Sales Trend</h3>
                        <div class="chart-wrapper">
                            <canvas id="membershipWeeklyChart"></canvas>
                        </div>
                    </div>
                    
                    <div class="chart-container full-width">
                        <h3>Weekly Average Membership Sale Value</h3>
                        <div class="chart-wrapper">
                            <canvas id="membershipAvgValueChart"></canvas>
                        </div>
                    </div>
                    
                    <div class="chart-container full-width">
                        <h3>üí∏ Franchise Fees Timeline (Stacked)</h3>
                        <div class="chart-wrapper">
                            <canvas id="feesTimelineChart"></canvas>
                        </div>
                        <div style="margin-top: 15px; padding: 15px; background: var(--gray-light); border-radius: 8px;">
                            <div style="display: grid; grid-template-columns: repeat(auto-fit, minmax(150px, 1fr)); gap: 15px;">
                                <div style="text-align: center;">
                                    <div style="font-size: 12px; color: #666;">Franchise Fee</div>
                                    <div style="font-size: 16px; font-weight: bold; color: var(--primary);">${formatCurrency(totalRevenue * CONFIG.franchiseFeePercent / 100)}</div>
                                    <div style="font-size: 11px; color: #999;">${CONFIG.franchiseFeePercent}% of revenue</div>
                                </div>
                                <div style="text-align: center;">
                                    <div style="font-size: 12px; color: #666;">Brand Fund</div>
                                    <div style="font-size: 16px; font-weight: bold; color: var(--accent);">${formatCurrency(totalRevenue * CONFIG.brandFundPercent / 100)}</div>
                                    <div style="font-size: 11px; color: #999;">${CONFIG.brandFundPercent}% of revenue</div>
                                </div>
                                <div style="text-align: center;">
                                    <div style="font-size: 12px; color: #666;">CC Processing</div>
                                    <div style="font-size: 16px; font-weight: bold; color: var(--highlight);">${formatCurrency(totalRevenue * CONFIG.ccFeesPercent / 100)}</div>
                                    <div style="font-size: 11px; color: #999;">${CONFIG.ccFeesPercent}% of revenue</div>
                                </div>
                                <div style="text-align: center;">
                                    <div style="font-size: 12px; color: #666;">Total Fees</div>
                                    <div style="font-size: 18px; font-weight: bold; color: var(--danger);">${formatCurrency(totalRevenue * (CONFIG.franchiseFeePercent + CONFIG.brandFundPercent + CONFIG.ccFeesPercent) / 100)}</div>
                                    <div style="font-size: 11px; color: #999;">${((CONFIG.franchiseFeePercent + CONFIG.brandFundPercent + CONFIG.ccFeesPercent)).toFixed(1)}% of revenue</div>
                                </div>
                            </div>
                        </div>
                    </div>
                </div>
            `;
            
            document.getElementById('timeline').innerHTML = html;
            
            // Render charts
            setTimeout(() => {
                renderTimelineCharts(dailyData, dates);
                renderMembershipTimelineCharts();
            }, 100);
        }
        
        // INSIGHTS TAB (with monthly goal tracking)
        function renderInsightsTab() {
            const data = filteredAppointments;
            
            // Calculate various insights - exclude active member revenue
            const totalRevenue = calculateAppointmentRevenue(data);
            const totalPayout = data.reduce((sum, row) => sum + parseFloat(row['Total Payout'] || 0), 0);
            const totalHours = data.reduce((sum, row) => sum + parseFloat(row['Time (h)'] || 0), 0);
            
            // Calculate total labor costs including non-appointment work
            let totalLaborCost = totalPayout;
            let nonApptHours = 0;
            let nonApptLaborCost = 0;
            
            if (filteredTimeTracking && filteredTimeTracking.length > 0) {
                const totalClockedHours = filteredTimeTracking.reduce((sum, t) => {
                    const hours = parseFloat(t['Duration (h)'] || 0);
                    return sum + hours;
                }, 0);
                
                // Non-appointment hours = clocked hours - appointment hours
                nonApptHours = Math.max(0, totalClockedHours - totalHours);
                nonApptLaborCost = nonApptHours * CONFIG.baseHourlyRate;
                totalLaborCost = totalPayout + nonApptLaborCost;
            }
            
            const profit = totalRevenue - totalLaborCost;
            const profitMargin = totalRevenue > 0 ? (profit / totalRevenue * 100) : 0;
            
            // Client retention
            const clientVisits = {};
            data.forEach(row => {
                const email = (row['Customer Email'] || '').toLowerCase().trim();
                if (email) {
                    clientVisits[email] = (clientVisits[email] || 0) + 1;
                }
            });
            
            const uniqueClients = Object.keys(clientVisits).length;
            const returningClients = Object.values(clientVisits).filter(count => count > 1).length;
            const retentionRate = uniqueClients > 0 ? (returningClients / uniqueClients * 100) : 0;
            
            // Service analysis
            const serviceRevenue = {};
            const serviceCount = {};
            data.forEach(row => {
                const service = row['Appointment'] || 'Unknown';
                serviceRevenue[service] = (serviceRevenue[service] || 0) + parseFloat(row.Revenue || 0);
                serviceCount[service] = (serviceCount[service] || 0) + 1;
            });
            
            const topService = Object.entries(serviceRevenue)
                .sort((a, b) => b[1] - a[1])[0];
            
            // Goals tracking - Monthly basis
            const revenueGoal = CONFIG.goals.monthlyRevenue;
            const appointmentsGoal = CONFIG.goals.monthlyAppointments;
            const revenueProgress = (totalRevenue / revenueGoal) * 100;
            const appointmentsProgress = (data.length / appointmentsGoal) * 100;
            
            const currentPeriod = getCurrentPeriod();
            
            // Calculate intro appointments
            const introAppointments = data.filter(row => isIntroOffer(row['Appointment'])).length;
            const introGoal = CONFIG.goals.monthlyIntroAppointments;
            const introProgress = (introAppointments / introGoal) * 100;
            
            let html = `
                <div class="table-container">
                    <h2>Goal Tracking - ${currentPeriod}</h2>
                    <p style="margin-bottom: 20px; color: #666;">Monthly goals: ${formatCurrency(revenueGoal)} revenue | ${formatNumber(appointmentsGoal)} appointments | ${formatNumber(introGoal)} intro appointments</p>
                    
                    <div class="charts-grid" style="grid-template-columns: 1fr 1fr 1fr;">
                        <div class="chart-container">
                            <h3>üìä Monthly Revenue vs Goal</h3>
                            <div class="chart-wrapper" style="height: 300px;">
                                <canvas id="monthlyRevenueGoalChart"></canvas>
                            </div>
                        </div>
                        <div class="chart-container">
                            <h3>üìä Monthly Paid Appointments vs Goal</h3>
                            <div class="chart-wrapper" style="height: 300px;">
                                <canvas id="monthlyAppointmentsGoalChart"></canvas>
                            </div>
                        </div>
                        <div class="chart-container">
                            <h3>üÜï Monthly Intro Appointments vs Goal</h3>
                            <div class="chart-wrapper" style="height: 300px;">
                                <canvas id="monthlyIntroGoalChart"></canvas>
                            </div>
                        </div>
                    </div>
                    
                    ${revenueProgress < 100 || introProgress < 100 ? `
                        <div class="alert ${revenueProgress >= 70 && introProgress >= 70 ? 'warning' : 'danger'}" style="margin-top: 20px;">
                            <h4>üìä Progress Update</h4>
                            ${revenueProgress < 100 ? `<p><strong>Revenue Gap:</strong> ${formatCurrency(revenueGoal - totalRevenue)} remaining to reach goal</p>` : ''}
                            ${appointmentsProgress < 100 ? `<p><strong>Appointments Gap:</strong> ${formatNumber(appointmentsGoal - data.length)} more appointments needed</p>` : ''}
                            ${introProgress < 100 ? `<p><strong>Intro Appointments Gap:</strong> ${formatNumber(introGoal - introAppointments)} more intro appointments needed</p>` : ''}
                            ${revenueProgress < 100 ? `<p style="margin-top: 10px;"><strong>To reach goal:</strong> Need ${formatCurrency((revenueGoal - totalRevenue)/(appointmentsGoal - data.length || 1))} per appointment</p>` : ''}
                        </div>
                    ` : `
                        <div class="alert success" style="margin-top: 20px;">
                            <h4>üéâ Goals Achieved!</h4>
                            <p>Congratulations! You've met your monthly targets. Keep up the excellent work!</p>
                        </div>
                    `}
                </div>
                
                <div class="metrics-grid" style="grid-template-columns: repeat(4, 1fr);">
                    <div class="metric-card">
                        <div class="metric-label">Profit Margin</div>
                        <div class="metric-value">${profitMargin.toFixed(1)}%</div>
                        <div class="metric-subtext">${formatCurrency(profit)} profit</div>
                    </div>
                    <div class="metric-card ${retentionRate >= 50 ? 'success' : retentionRate >= 30 ? 'warning' : 'danger'}">
                        <div class="metric-label">Client Retention</div>
                        <div class="metric-value">${retentionRate.toFixed(1)}%</div>
                        <div class="metric-subtext">${returningClients} returning clients</div>
                    </div>
                    <div class="metric-card">
                        <div class="metric-label">Top Service</div>
                        <div class="metric-value">${formatCurrency(topService ? topService[1] : 0)}</div>
                        <div class="metric-subtext">${topService ? topService[0].substring(0, 30) : 'N/A'}</div>
                    </div>
                    <div class="metric-card">
                        <div class="metric-label">Unique Clients</div>
                        <div class="metric-value">${formatNumber(uniqueClients)}</div>
                        <div class="metric-subtext">${(data.length/uniqueClients).toFixed(1)} avg visits</div>
                    </div>
                </div>
                
                <div class="alert ${retentionRate >= 50 ? 'success' : 'warning'}">
                    <h4>üí° Key Insights & Recommendations</h4>
                    <ul style="margin: 10px 0 0 20px; line-height: 1.8;">
                        <li><strong>Revenue:</strong> You're at ${revenueProgress.toFixed(0)}% of your monthly goal. ${revenueProgress >= 80 ? 'Great progress! Consider upselling premium services to exceed your target.' : 'To reach goal faster, focus on booking ${Math.ceil((appointmentsGoal - data.length)/7)} more appointments per week.'}</li>
                        <li><strong>Retention:</strong> ${retentionRate.toFixed(0)}% of clients return for multiple visits. ${retentionRate >= 50 ? 'Excellent retention! Consider launching a VIP membership program for your most loyal clients.' : 'Create a 3-visit intro package and follow up within 48 hours of first appointments to boost retention.'}</li>
                        <li><strong>Profitability:</strong> Your profit margin is ${profitMargin.toFixed(1)}%. ${profitMargin >= 30 ? 'Healthy margins! Consider reinvesting 10-15% into marketing to scale growth.' : 'Review practitioner payout structure and optimize scheduling to reduce idle time and improve margins.'}</li>
                        <li><strong>Service Mix:</strong> "${topService ? topService[0] : 'N/A'}" generates the most revenue. Create package deals combining your top service with complementary services to increase average transaction value.</li>
                        <li><strong>Client Engagement:</strong> ${uniqueClients > 0 ? `With ${(data.length/uniqueClients).toFixed(1)} average visits per client, there's opportunity to increase visit frequency. Implement a rebooking incentive (e.g., "Book your next session today and save 10%").` : 'Focus on building your client base through referral programs and local partnerships.'}</li>
                        <li><strong>Revenue Per Client:</strong> ${uniqueClients > 0 ? `Current average is ${formatCurrency(totalRevenue/uniqueClients)} per client. Aim to increase this by 20% through package deals and membership options.` : 'Track this metric as your client base grows to optimize pricing strategy.'}</li>
                    </ul>
                </div>
                
                <div class="table-container">
                    <h2>Action Items</h2>
                    <div style="background: var(--gray-light); padding: 20px; border-radius: 10px; border-left: 4px solid var(--accent);">
                        <h4 style="margin-bottom: 15px; color: var(--primary);">Recommended Actions This Week:</h4>
                        <ol style="margin: 0 0 0 20px; line-height: 2;">
                            <li><strong>Follow-up Campaign:</strong> Contact all one-time visitors from the past 30 days with a special "We miss you" discount offer.</li>
                            <li><strong>Package Creation:</strong> Bundle your top 3 services into an attractive package deal priced 15% below individual session rates.</li>
                            <li><strong>Schedule Optimization:</strong> Review your Schedule tab to identify gaps and opportunities to add 2-3 more appointments per week.</li>
                            <li><strong>Client Feedback:</strong> Send a quick survey to your top 10 clients asking what they love and what could be improved.</li>
                            <li><strong>Referral Program:</strong> Launch a "Bring a Friend" promotion where both the referrer and new client get a discount.</li>
                            ${retentionRate < 50 ? '<li><strong>Retention Focus:</strong> Create an automated email sequence that goes out 7, 14, and 30 days after first visit to encourage rebooking.</li>' : ''}
                            ${profitMargin < 30 ? '<li><strong>Cost Analysis:</strong> Review your top expenses and identify 1-2 areas where you can reduce costs without impacting quality.</li>' : ''}
                        </ol>
                    </div>
                </div>
                
                <div class="table-container">
                    <h2>Complete AI Recommendations Report</h2>
                    <p style="margin-bottom: 20px; color: #666;">All personalized recommendations ranked by potential impact.</p>
                    ${(() => {
                        const recommendations = generateSmartRecommendations();
                        if (recommendations.length === 0) {
                            return '<div class="alert success"><h4>üéâ Outstanding Performance!</h4><p>Your business is operating at peak efficiency across all metrics. Continue your current strategies!</p></div>';
                        }
                        return recommendations.map((rec, index) => `
                            <div class="recommendation-card">
                                <div style="display: flex; justify-content: space-between; align-items: start;">
                                    <div style="flex: 1;">
                                        <span class="recommendation-priority ${rec.priority}">#${index + 1} ${rec.priority.toUpperCase()} PRIORITY</span>
                                        <div class="recommendation-title">${rec.title}</div>
                                        <p style="margin: 10px 0; color: #666; line-height: 1.6;">${rec.description}</p>
                                        <p style="margin: 10px 0; padding: 12px; background: rgba(113, 190, 210, 0.1); border-radius: 8px; border-left: 3px solid var(--accent);">
                                            <strong>üìã Action Plan:</strong> ${rec.action}
                                        </p>
                                        <div class="recommendation-impact">
                                            <strong>üí∞ Estimated Impact:</strong> ${rec.impact}
                                        </div>
                                    </div>
                                </div>
                            </div>
                        `).join('');
                    })()}
                </div>
            `;
            
            document.getElementById('insights').innerHTML = html;
            
            // Render monthly goal charts
            renderMonthlyGoalCharts(data, revenueGoal, appointmentsGoal);
        }
        
        // Render monthly goal charts
        function renderMonthlyGoalCharts(appointmentsData, revenueGoal, appointmentsGoal) {
            // Group data by month
            const monthlyData = {};
            const introGoal = CONFIG.goals.monthlyIntroAppointments;
            
            appointmentsData.forEach(row => {
                const date = parseDate(row['Appointment Date']);
                if (date) {
                    const monthKey = `${date.getFullYear()}-${String(date.getMonth() + 1).padStart(2, '0')}`;
                    if (!monthlyData[monthKey]) {
                        monthlyData[monthKey] = {
                            revenue: 0,
                            appointments: 0,
                            introAppointments: 0
                        };
                    }
                    monthlyData[monthKey].revenue += parseFloat(row.Revenue) || 0;
                    
                    // Only count paid (non-intro) appointments toward the appointments goal
                    if (isIntroOffer(row['Appointment'])) {
                        monthlyData[monthKey].introAppointments++;
                    } else {
                        monthlyData[monthKey].appointments++;
                    }
                }
            });
            
            const sortedMonths = Object.keys(monthlyData).sort();
            const monthLabels = sortedMonths.map(month => {
                const [year, mon] = month.split('-');
                const date = new Date(year, mon - 1);
                return date.toLocaleDateString('en-US', { month: 'short', year: 'numeric' });
            });
            
            // Revenue Goal Chart
            const revenueCanvas = document.getElementById('monthlyRevenueGoalChart');
            if (revenueCanvas) {
                destroyChart('monthlyRevenueGoal');
                const ctx = revenueCanvas.getContext('2d');
                
                allCharts.monthlyRevenueGoal = new Chart(ctx, {
                    type: 'bar',
                    data: {
                        labels: monthLabels,
                        datasets: [
                            {
                                label: 'Actual Revenue',
                                data: sortedMonths.map(m => monthlyData[m].revenue),
                                backgroundColor: '#71BED2',
                                borderColor: '#5aa8bf',
                                borderWidth: 2
                            },
                            {
                                label: 'Goal',
                                data: sortedMonths.map(() => revenueGoal),
                                backgroundColor: 'rgba(251, 181, 20, 0.3)',
                                borderColor: '#FBB514',
                                borderWidth: 2,
                                borderDash: [5, 5],
                                type: 'line',
                                fill: false
                            }
                        ]
                    },
                    options: {
                        responsive: true,
                        maintainAspectRatio: false,
                        plugins: {
                            legend: {
                                display: true,
                                position: 'top'
                            },
                            tooltip: {
                                callbacks: {
                                    label: function(context) {
                                        return context.dataset.label + ': ' + formatCurrency(context.parsed.y);
                                    }
                                }
                            }
                        },
                        scales: {
                            y: {
                                beginAtZero: true,
                                ticks: {
                                    callback: function(value) {
                                        return formatCurrency(value);
                                    }
                                }
                            }
                        }
                    }
                });
            }
            
            // Appointments Goal Chart
            const appointmentsCanvas = document.getElementById('monthlyAppointmentsGoalChart');
            if (appointmentsCanvas) {
                destroyChart('monthlyAppointmentsGoal');
                const ctx = appointmentsCanvas.getContext('2d');
                
                allCharts.monthlyAppointmentsGoal = new Chart(ctx, {
                    type: 'bar',
                    data: {
                        labels: monthLabels,
                        datasets: [
                            {
                                label: 'Actual Paid Appointments',
                                data: sortedMonths.map(m => monthlyData[m].appointments),
                                backgroundColor: '#013160',
                                borderColor: '#001a3a',
                                borderWidth: 2
                            },
                            {
                                label: 'Goal',
                                data: sortedMonths.map(() => appointmentsGoal),
                                backgroundColor: 'rgba(251, 181, 20, 0.3)',
                                borderColor: '#FBB514',
                                borderWidth: 2,
                                borderDash: [5, 5],
                                type: 'line',
                                fill: false
                            }
                        ]
                    },
                    options: {
                        responsive: true,
                        maintainAspectRatio: false,
                        plugins: {
                            legend: {
                                display: true,
                                position: 'top'
                            },
                            tooltip: {
                                callbacks: {
                                    label: function(context) {
                                        return context.dataset.label + ': ' + formatNumber(context.parsed.y);
                                    }
                                }
                            }
                        },
                        scales: {
                            y: {
                                beginAtZero: true,
                                ticks: {
                                    stepSize: 10
                                }
                            }
                        }
                    }
                });
            }
            
            // Intro Appointments Goal Chart
            const introCanvas = document.getElementById('monthlyIntroGoalChart');
            if (introCanvas) {
                destroyChart('monthlyIntroGoal');
                const ctx = introCanvas.getContext('2d');
                
                allCharts.monthlyIntroGoal = new Chart(ctx, {
                    type: 'bar',
                    data: {
                        labels: monthLabels,
                        datasets: [
                            {
                                label: 'Actual Intro Appointments',
                                data: sortedMonths.map(m => monthlyData[m].introAppointments),
                                backgroundColor: '#FBB514',
                                borderColor: '#e5a313',
                                borderWidth: 2
                            },
                            {
                                label: 'Goal',
                                data: sortedMonths.map(() => introGoal),
                                backgroundColor: 'rgba(1, 49, 96, 0.3)',
                                borderColor: '#013160',
                                borderWidth: 2,
                                borderDash: [5, 5],
                                type: 'line',
                                fill: false
                            }
                        ]
                    },
                    options: {
                        responsive: true,
                        maintainAspectRatio: false,
                        plugins: {
                            legend: {
                                display: true,
                                position: 'top'
                            },
                            tooltip: {
                                callbacks: {
                                    label: function(context) {
                                        return context.dataset.label + ': ' + formatNumber(context.parsed.y);
                                    }
                                }
                            }
                        },
                        scales: {
                            y: {
                                beginAtZero: true,
                                ticks: {
                                    stepSize: 5
                                }
                            }
                        }
                    }
                });
            }
        }
        
        // PERIOD COMPARISON FUNCTIONS
        let comparisonData = null;
        
        function toggleComparison() {
            const comparisonType = document.getElementById('comparisonPeriod').value;
            if (comparisonType !== 'none') {
                calculateComparisonData();
            } else {
                comparisonData = null;
            }
            renderAllTabs();
        }
        
        function calculateComparisonData() {
            const comparisonType = document.getElementById('comparisonPeriod').value;
            if (comparisonType === 'none') {
                comparisonData = null;
                return;
            }
            
            // Check if appointments data is available
            if (!appointmentsData || appointmentsData.length === 0) {
                comparisonData = null;
                return;
            }
            
            // Get date range from inputs, or calculate from filtered data
            let startDate = document.getElementById('startDate').value ? new Date(document.getElementById('startDate').value) : null;
            let endDate = document.getElementById('endDate').value ? new Date(document.getElementById('endDate').value) : null;
            
            // If no dates specified, use the date range from filtered appointments
            if (!startDate || !endDate) {
                if (filteredAppointments.length === 0) {
                    comparisonData = null;
                    return;
                }
                
                const dates = filteredAppointments
                    .map(row => parseDate(row['Appointment Date']))
                    .filter(date => date)
                    .sort((a, b) => a - b);
                
                if (dates.length === 0) {
                    comparisonData = null;
                    return;
                }
                
                startDate = dates[0];
                endDate = dates[dates.length - 1];
            }
            
            const daysDiff = Math.ceil((endDate - startDate) / (1000 * 60 * 60 * 24));
            let compStart, compEnd;
            
            switch(comparisonType) {
                case 'previous':
                    compStart = new Date(startDate);
                    compStart.setDate(compStart.getDate() - daysDiff);
                    compEnd = new Date(startDate);
                    compEnd.setDate(compEnd.getDate() - 1);
                    break;
                case 'lastMonth':
                    compStart = new Date(startDate);
                    compStart.setMonth(compStart.getMonth() - 1);
                    compEnd = new Date(endDate);
                    compEnd.setMonth(compEnd.getMonth() - 1);
                    break;
                case 'lastQuarter':
                    compStart = new Date(startDate);
                    compStart.setMonth(compStart.getMonth() - 3);
                    compEnd = new Date(endDate);
                    compEnd.setMonth(compEnd.getMonth() - 3);
                    break;
                case 'lastYear':
                    compStart = new Date(startDate);
                    compStart.setFullYear(compStart.getFullYear() - 1);
                    compEnd = new Date(endDate);
                    compEnd.setFullYear(compEnd.getFullYear() - 1);
                    break;
            }
            
            // Filter comparison data from the global appointmentsData
            const compData = appointmentsData.filter(row => {
                const date = parseDate(row['Appointment Date']);
                return date && date >= compStart && date <= compEnd;
            });
            
            comparisonData = {
                revenue: compData.reduce((sum, row) => sum + parseFloat(row.Revenue || 0), 0),
                appointments: compData.length,
                clients: new Set(compData.map(r => r['Customer Email']).filter(e => e)).size,
                profit: compData.reduce((sum, row) => sum + parseFloat(row.Revenue || 0) - parseFloat(row['Total Payout'] || 0), 0),
                period: `${compStart.toLocaleDateString()} - ${compEnd.toLocaleDateString()}`
            };
        }
        
        function getComparisonIndicator(current, previous, format = 'number') {
            if (!comparisonData || previous === 0) return '';
            
            const change = ((current - previous) / previous) * 100;
            const isPositive = change > 0;
            const isNegative = change < 0;
            const arrow = isPositive ? '‚Üë' : isNegative ? '‚Üì' : '‚Üí';
            const className = isPositive ? 'positive' : isNegative ? 'negative' : 'neutral';
            
            let displayValue;
            if (format === 'currency') {
                displayValue = formatCurrency(Math.abs(current - previous));
            } else if (format === 'percent') {
                displayValue = `${Math.abs(change).toFixed(1)}%`;
            } else {
                displayValue = `${Math.abs(change).toFixed(1)}%`;
            }
            
            return `<span class="comparison-indicator ${className}"><span class="comparison-arrow">${arrow}</span>${displayValue}</span>`;
        }
        
        // MEMBERSHIPS TAB
        function renderMembershipsTab() {
            if (!membershipsData || membershipsData.length === 0) {
                document.getElementById('memberships').innerHTML = `
                    <div class="alert info">
                        <h4>üí≥ Membership Analytics</h4>
                        <p>Upload the <strong>Membership Sales CSV</strong> file to unlock comprehensive membership analytics including revenue tracking, retention analysis, and sales performance.</p>
                    </div>
                `;
                return;
            }
            
            // Parse membership data
            const now = new Date();
            const activeMemberships = [];
            const expiredMemberships = [];
            membershipTypes = {}; // Using global variable
            const dailyRevenue = {};
            const monthlyRevenue = {};
            salesByStaff = {}; // Using global variable
            const frozenCount = filteredMemberships.filter(m => m.Frozen === 'Yes').length;
            const refundedCount = filteredMemberships.filter(m => parseFloat(m.Refunded) > 0).length;
            
            let totalRevenue = 0;
            let avgMembershipValue = 0;
            let newSalesCount = 0;
            let renewalsCount = 0;
            let newSalesRevenue = 0;
            let renewalsRevenue = 0;
            
            // First pass: Group memberships by customer to find first VSP and identify new vs renewal
            const customerFirstVSP = {};
            const customerPurchaseCount = {};
            
            // Sort memberships by date to properly identify first purchase
            const sortedMemberships = [...filteredMemberships].sort((a, b) => {
                const dateA = a['Bought Date/Time (GMT)'] ? new Date(a['Bought Date/Time (GMT)']) : new Date(0);
                const dateB = b['Bought Date/Time (GMT)'] ? new Date(b['Bought Date/Time (GMT)']) : new Date(0);
                return dateA - dateB;
            });
            
            sortedMemberships.forEach(membership => {
                const email = (membership['Customer Email'] || '').toLowerCase().trim();
                if (!email) return;
                
                const boughtDate = membership['Bought Date/Time (GMT)'] ? new Date(membership['Bought Date/Time (GMT)']) : null;
                const soldBy = membership['Sold by'] || '';
                
                // Track customer purchase count
                if (!customerPurchaseCount[email]) {
                    customerPurchaseCount[email] = 0;
                }
                customerPurchaseCount[email]++;
                
                // Track first VSP
                if (!customerFirstVSP[email]) {
                    customerFirstVSP[email] = {
                        vsp: soldBy,
                        date: boughtDate,
                        purchaseId: membership['Purchase ID']
                    };
                }
            });
            
            // Second pass: Process all memberships
            filteredMemberships.forEach(membership => {
                const paidAmount = parseFloat(membership['Paid Amount']) || 0;
                totalRevenue += paidAmount;
                
                // Determine if new sale or renewal
                const email = (membership['Customer Email'] || '').toLowerCase().trim();
                const purchaseId = membership['Purchase ID'];
                const isFirstPurchase = email && customerFirstVSP[email] && customerFirstVSP[email].purchaseId === purchaseId;
                
                if (isFirstPurchase) {
                    newSalesCount++;
                    newSalesRevenue += paidAmount;
                    membership._isNewSale = true;
                } else if (email && customerFirstVSP[email]) {
                    renewalsCount++;
                    renewalsRevenue += paidAmount;
                    membership._isRenewal = true;
                }
                
                // Parse dates
                const boughtDate = membership['Bought Date/Time (GMT)'] ? new Date(membership['Bought Date/Time (GMT)']) : null;
                const expiryDate = membership['Remaining/ Expiry/ Renewal'] ? new Date(membership['Remaining/ Expiry/ Renewal']) : null;
                const isExpired = membership.Expired === 'Yes';
                
                // Categorize active vs expired
                if (isExpired || (expiryDate && expiryDate < now)) {
                    expiredMemberships.push(membership);
                } else {
                    activeMemberships.push(membership);
                }
                
                // Track membership types
                const type = membership['Membership Name'] || 'Unknown';
                if (!membershipTypes[type]) {
                    membershipTypes[type] = { count: 0, revenue: 0, active: 0, newSales: 0, renewals: 0 };
                }
                membershipTypes[type].count++;
                membershipTypes[type].revenue += paidAmount;
                if (!isExpired && (!expiryDate || expiryDate >= now)) {
                    membershipTypes[type].active++;
                }
                if (membership._isNewSale) {
                    membershipTypes[type].newSales++;
                } else if (membership._isRenewal) {
                    membershipTypes[type].renewals++;
                }
                
                // Track daily revenue
                if (boughtDate) {
                    const dateKey = boughtDate.toISOString().split('T')[0];
                    if (!dailyRevenue[dateKey]) {
                        dailyRevenue[dateKey] = 0;
                    }
                    dailyRevenue[dateKey] += paidAmount;
                    
                    // Track monthly revenue
                    const monthKey = `${boughtDate.getFullYear()}-${String(boughtDate.getMonth() + 1).padStart(2, '0')}`;
                    if (!monthlyRevenue[monthKey]) {
                        monthlyRevenue[monthKey] = 0;
                    }
                    monthlyRevenue[monthKey] += paidAmount;
                }
                
                // Track sales by staff - credit to FIRST VSP for this customer
                let soldBy = membership['Sold by'] || '';
                
                // If customer has a first VSP recorded and this sale has no VSP, credit the first VSP
                if (email && customerFirstVSP[email]) {
                    soldBy = customerFirstVSP[email].vsp || soldBy;
                }
                
                // If still empty, mark as Direct/Online
                if (!soldBy) {
                    soldBy = 'Direct/Online';
                }
                
                if (!salesByStaff[soldBy]) {
                    salesByStaff[soldBy] = { count: 0, revenue: 0, newSales: 0, renewals: 0 };
                }
                salesByStaff[soldBy].count++;
                salesByStaff[soldBy].revenue += paidAmount;
                if (membership._isNewSale) {
                    salesByStaff[soldBy].newSales++;
                } else if (membership._isRenewal) {
                    salesByStaff[soldBy].renewals++;
                }
            });
            
            avgMembershipValue = totalRevenue / membershipsData.length;
            
            // Calculate MRR (Monthly Recurring Revenue) from active subscriptions
            let mrr = 0;
            activeMemberships.forEach(m => {
                if (m['Membership Type'] === 'subscription') {
                    const amount = parseFloat(m['Paid Amount']) || 0;
                    mrr += amount;
                }
            });
            
            // Sort data for charts
            const sortedDates = Object.keys(dailyRevenue).sort();
            const sortedMonths = Object.keys(monthlyRevenue).sort();
            
            // Calculate cumulative revenue
            const cumulativeRevenue = [];
            let cumSum = 0;
            sortedDates.forEach(date => {
                cumSum += dailyRevenue[date];
                cumulativeRevenue.push({ date, value: cumSum });
            });
            
            // Calculate retention rate
            const totalMemberships = membershipsData.length;
            const retentionRate = ((activeMemberships.length / totalMemberships) * 100).toFixed(1);
            const churnRate = ((expiredMemberships.length / totalMemberships) * 100).toFixed(1);
            
            // Sort membership types by revenue
            const sortedTypes = Object.entries(membershipTypes)
                .sort((a, b) => b[1].revenue - a[1].revenue)
                .slice(0, 10);
            
            // Sort sales staff by count
            const sortedStaff = Object.entries(salesByStaff)
                .sort((a, b) => b[1].count - a[1].count)
                .slice(0, 10);
            
            let html = `
                <div class="section">
                    <h2>Membership Analytics Overview</h2>
                    
                    <!-- Compact Metrics Grid -->
                    <div class="metrics-grid" style="grid-template-columns: repeat(6, 1fr); margin-bottom: 40px;">
                        <div class="metric-card compact" style="background: linear-gradient(135deg, rgba(40, 167, 69, 0.1), rgba(32, 201, 151, 0.05)); border-left: 4px solid #28a745;">
                            <div class="metric-label">üÜï New Sales</div>
                            <div class="metric-value">${formatNumber(newSalesCount)}</div>
                            <div class="metric-subtext">${formatCurrency(newSalesRevenue)} revenue<br>Avg: ${formatCurrency(newSalesRevenue/newSalesCount)}</div>
                        </div>
                        
                        <div class="metric-card compact" style="background: linear-gradient(135deg, rgba(0, 123, 255, 0.1), rgba(0, 86, 179, 0.05)); border-left: 4px solid #007bff;">
                            <div class="metric-label">üîÑ Renewals</div>
                            <div class="metric-value">${formatNumber(renewalsCount)}</div>
                            <div class="metric-subtext">${formatCurrency(renewalsRevenue)} revenue<br>Avg: ${formatCurrency(renewalsRevenue/renewalsCount)}</div>
                        </div>
                        
                        <div class="metric-card compact" style="background: linear-gradient(135deg, rgba(156, 39, 176, 0.1), rgba(123, 31, 162, 0.05)); border-left: 4px solid #9c27b0;">
                            <div class="metric-label">üí∞ Total Revenue</div>
                            <div class="metric-value" style="font-size: 1.4em;">${formatCurrency(totalRevenue)}</div>
                            <div class="metric-subtext">${formatNumber(totalMemberships)} total memberships<br>Avg: ${formatCurrency(avgMembershipValue)}</div>
                        </div>
                        
                        <div class="metric-card compact" style="background: linear-gradient(135deg, rgba(255, 99, 132, 0.1), rgba(255, 56, 96, 0.05)); border-left: 4px solid #ff6384;">
                            <div class="metric-label">üìä Renewal Rate</div>
                            <div class="metric-value">${((renewalsCount / totalMemberships) * 100).toFixed(1)}%</div>
                            <div class="metric-subtext">${formatNumber(activeMemberships.length)} active<br>${retentionRate}% retention</div>
                        </div>
                        
                        <div class="metric-card compact" style="background: linear-gradient(135deg, rgba(33, 150, 243, 0.1), rgba(13, 71, 161, 0.05)); border-left: 4px solid #2196f3;">
                            <div class="metric-label">‚ùÑÔ∏è Frozen</div>
                            <div class="metric-value">${formatNumber(frozenCount)}</div>
                            <div class="metric-subtext">${((frozenCount / totalMemberships) * 100).toFixed(1)}% of total<br>memberships frozen</div>
                        </div>
                        
                        <div class="metric-card compact" style="background: linear-gradient(135deg, rgba(244, 67, 54, 0.1), rgba(211, 47, 47, 0.05)); border-left: 4px solid #f44336;">
                            <div class="metric-label">üí∏ Refunded</div>
                            <div class="metric-value">${formatNumber(refundedCount)}</div>
                            <div class="metric-subtext">${((refundedCount / totalMemberships) * 100).toFixed(1)}% refund rate<br>${formatCurrency(filteredMemberships.reduce((sum, m) => sum + (parseFloat(m.Refunded) || 0), 0))} total</div>
                        </div>
                    </div>
                </div>
                
                <!-- New vs Renewal Analysis -->
                <div class="section">
                    <h2>New Sales vs Renewals</h2>
                    <div class="charts-grid">
                        <div class="chart-container">
                            <h3>Sales Mix (Count)</h3>
                            <div class="chart-wrapper">
                                <canvas id="membershipSalesMixChart"></canvas>
                            </div>
                        </div>
                        
                        <div class="chart-container">
                            <h3>Revenue Mix</h3>
                            <div class="chart-wrapper">
                                <canvas id="membershipRevenueMixChart"></canvas>
                            </div>
                        </div>
                    </div>
                </div>
                
                <!-- Revenue Charts -->
                <div class="section">
                    <h2>Revenue Analysis</h2>
                    <div class="chart-grid">
                        <div class="chart-container">
                            <h3>Cumulative Membership Revenue</h3>
                            <div class="chart-wrapper">
                                <canvas id="membershipCumulativeRevenueChart"></canvas>
                            </div>
                        </div>
                        
                        <div class="chart-container">
                            <h3>Monthly Membership Revenue</h3>
                            <div class="chart-wrapper">
                                <canvas id="membershipMonthlyRevenueChart"></canvas>
                            </div>
                        </div>
                    </div>
                </div>
                
                <!-- Membership Type Breakdown -->
                <div class="section">
                    <h2>Membership Type Analysis</h2>
                    <div class="chart-grid">
                        <div class="chart-container">
                            <h3>Memberships by Type</h3>
                            <div class="chart-wrapper">
                                <canvas id="membershipTypeCountChart"></canvas>
                            </div>
                        </div>
                        
                        <div class="chart-container">
                            <h3>Revenue by Membership Type</h3>
                            <div class="chart-wrapper">
                                <canvas id="membershipTypeRevenueChart"></canvas>
                            </div>
                        </div>
                    </div>
                    
                    <!-- Membership Type Table -->
                    <div class="table-container">
                        <h3>Membership Type Details</h3>
                        <button onclick="exportMembershipTypeData()" style="float: right; padding: 8px 16px; background: var(--accent); color: white; border: none; border-radius: 5px; cursor: pointer; margin-bottom: 10px;">üì• Export to CSV</button>
                        <table>
                            <thead>
                                <tr>
                                    <th>Membership Type</th>
                                    <th>Total</th>
                                    <th>New Sales</th>
                                    <th>Renewals</th>
                                    <th>Active</th>
                                    <th>Expired</th>
                                    <th>Revenue</th>
                                    <th>Avg Value</th>
                                </tr>
                            </thead>
                            <tbody>
                                ${sortedTypes.map(([type, data]) => `
                                    <tr>
                                        <td><strong>${type}</strong></td>
                                        <td>${formatNumber(data.count)}</td>
                                        <td style="color: #28a745;">${formatNumber(data.newSales || 0)}</td>
                                        <td style="color: #007bff;">${formatNumber(data.renewals || 0)}</td>
                                        <td style="color: var(--success);">${formatNumber(data.active)}</td>
                                        <td style="color: var(--danger);">${formatNumber(data.count - data.active)}</td>
                                        <td><strong>${formatCurrency(data.revenue)}</strong></td>
                                        <td>${formatCurrency(data.revenue / data.count)}</td>
                                    </tr>
                                `).join('')}
                            </tbody>
                        </table>
                    </div>
                </div>
                
                <!-- Sales Performance -->
                <div class="section">
                    <h2>Sales Performance by Staff</h2>
                    <div class="chart-grid">
                        <div class="chart-container">
                            <h3>Memberships Sold by Staff</h3>
                            <div class="chart-wrapper">
                                <canvas id="membershipStaffCountChart"></canvas>
                            </div>
                        </div>
                        
                        <div class="chart-container">
                            <h3>Revenue by Staff</h3>
                            <div class="chart-wrapper">
                                <canvas id="membershipStaffRevenueChart"></canvas>
                            </div>
                        </div>
                    </div>
                    
                    <!-- Staff Performance Table -->
                    <div class="table-container">
                        <h3>Staff Sales Details</h3>
                        <button onclick="exportStaffSalesData()" style="float: right; padding: 8px 16px; background: var(--accent); color: white; border: none; border-radius: 5px; cursor: pointer; margin-bottom: 10px;">üì• Export to CSV</button>
                        <table>
                            <thead>
                                <tr>
                                    <th>Staff Member</th>
                                    <th>Total Sales</th>
                                    <th>New Sales</th>
                                    <th>Renewals</th>
                                    <th>Revenue Generated</th>
                                    <th>Avg Sale Value</th>
                                </tr>
                            </thead>
                            <tbody>
                                ${sortedStaff.map(([staff, data]) => `
                                    <tr>
                                        <td><strong>${staff}</strong></td>
                                        <td>${formatNumber(data.count)}</td>
                                        <td style="color: #28a745;">${formatNumber(data.newSales || 0)}</td>
                                        <td style="color: #007bff;">${formatNumber(data.renewals || 0)}</td>
                                        <td><strong>${formatCurrency(data.revenue)}</strong></td>
                                        <td>${formatCurrency(data.revenue / data.count)}</td>
                                    </tr>
                                `).join('')}
                            </tbody>
                        </table>
                    </div>
                </div>
                
                <!-- Active vs Expired -->
                <div class="section">
                    <h2>Membership Status Analysis</h2>
                    <div class="chart-grid">
                        <div class="chart-container">
                            <h3>Active vs Expired Memberships</h3>
                            <div class="chart-wrapper">
                                <canvas id="membershipStatusChart"></canvas>
                            </div>
                        </div>
                        
                        <div class="chart-container">
                            <h3>MRR Growth Over Time</h3>
                            <div class="chart-wrapper">
                                <canvas id="membershipMRRChart"></canvas>
                            </div>
                        </div>
                    </div>
                </div>
                
                <!-- Timeline Analysis -->
                <div class="section">
                    <h2>Timeline &amp; Trends</h2>
                    <div class="chart-grid">
                        <div class="chart-container full-width">
                            <h3>Daily New Memberships: New Sales vs Renewals</h3>
                            <div class="chart-wrapper">
                                <canvas id="membershipTimelineChart"></canvas>
                            </div>
                        </div>
                        
                        <div class="chart-container">
                            <h3>Sales by Day of Week</h3>
                            <div class="chart-wrapper">
                                <canvas id="membershipDayOfWeekChart"></canvas>
                            </div>
                        </div>
                    </div>
                </div>
            `;
            
            document.getElementById('memberships').innerHTML = html;
            
            // Render charts
            setTimeout(() => {
                // Sales Mix Chart (New vs Renewal count)
                const salesMixCanvas = document.getElementById('membershipSalesMixChart');
                if (salesMixCanvas) {
                    destroyChart('membershipSalesMix');
                    const ctx = salesMixCanvas.getContext('2d');
                    allCharts.membershipSalesMix = new Chart(ctx, {
                        type: 'doughnut',
                        data: {
                            labels: ['New Sales', 'Renewals'],
                            datasets: [{
                                data: [newSalesCount, renewalsCount],
                                backgroundColor: ['#28a745', '#007bff'],
                                borderWidth: 2,
                                borderColor: '#fff'
                            }]
                        },
                        options: {
                            responsive: true,
                            maintainAspectRatio: false,
                            plugins: {
                                legend: {
                                    position: 'bottom'
                                },
                                tooltip: {
                                    callbacks: {
                                        label: function(context) {
                                            const label = context.label || '';
                                            const value = context.parsed || 0;
                                            const total = newSalesCount + renewalsCount;
                                            const percentage = ((value / total) * 100).toFixed(1);
                                            return label + ': ' + formatNumber(value) + ' (' + percentage + '%)';
                                        }
                                    }
                                }
                            }
                        }
                    });
                }
                
                // Revenue Mix Chart (New vs Renewal revenue)
                const revenueMixCanvas = document.getElementById('membershipRevenueMixChart');
                if (revenueMixCanvas) {
                    destroyChart('membershipRevenueMix');
                    const ctx = revenueMixCanvas.getContext('2d');
                    allCharts.membershipRevenueMix = new Chart(ctx, {
                        type: 'doughnut',
                        data: {
                            labels: ['New Sales', 'Renewals'],
                            datasets: [{
                                data: [newSalesRevenue, renewalsRevenue],
                                backgroundColor: ['#28a745', '#007bff'],
                                borderWidth: 2,
                                borderColor: '#fff'
                            }]
                        },
                        options: {
                            responsive: true,
                            maintainAspectRatio: false,
                            plugins: {
                                legend: {
                                    position: 'bottom'
                                },
                                tooltip: {
                                    callbacks: {
                                        label: function(context) {
                                            const label = context.label || '';
                                            const value = context.parsed || 0;
                                            const percentage = ((value / totalRevenue) * 100).toFixed(1);
                                            return label + ': ' + formatCurrency(value) + ' (' + percentage + '%)';
                                        }
                                    }
                                }
                            }
                        }
                    });
                }
                
                // Cumulative revenue chart
                const cumRevenueCanvas = document.getElementById('membershipCumulativeRevenueChart');
                if (cumRevenueCanvas) {
                    destroyChart('membershipCumulativeRevenue');
                    const ctx = cumRevenueCanvas.getContext('2d');
                    allCharts.membershipCumulativeRevenue = new Chart(ctx, {
                        type: 'line',
                        data: {
                            labels: cumulativeRevenue.map(d => d.date),
                            datasets: [{
                                label: 'Cumulative Revenue',
                                data: cumulativeRevenue.map(d => d.value),
                                borderColor: '#28a745',
                                backgroundColor: 'rgba(40, 167, 69, 0.1)',
                                borderWidth: 3,
                                fill: true,
                                tension: 0.4
                            }]
                        },
                        options: {
                            responsive: true,
                            maintainAspectRatio: false,
                            plugins: { legend: { display: false } },
                            scales: {
                                y: {
                                    beginAtZero: true,
                                    ticks: {
                                        callback: function(value) {
                                            return formatCurrency(value);
                                        }
                                    }
                                }
                            }
                        }
                    });
                }
                
                // Monthly revenue chart
                const monthlyCanvas = document.getElementById('membershipMonthlyRevenueChart');
                if (monthlyCanvas) {
                    destroyChart('membershipMonthlyRevenue');
                    const ctx = monthlyCanvas.getContext('2d');
                    allCharts.membershipMonthlyRevenue = new Chart(ctx, {
                        type: 'bar',
                        data: {
                            labels: sortedMonths.map(m => {
                                const [year, month] = m.split('-');
                                const date = new Date(year, month - 1);
                                return date.toLocaleDateString('en-US', { month: 'short', year: 'numeric' });
                            }),
                            datasets: [{
                                label: 'Monthly Revenue',
                                data: sortedMonths.map(m => monthlyRevenue[m]),
                                backgroundColor: '#007bff',
                                borderColor: '#0056b3',
                                borderWidth: 1
                            }]
                        },
                        options: {
                            responsive: true,
                            maintainAspectRatio: false,
                            plugins: { legend: { display: false } },
                            scales: {
                                y: {
                                    beginAtZero: true,
                                    ticks: {
                                        callback: function(value) {
                                            return formatCurrency(value);
                                        }
                                    }
                                }
                            }
                        }
                    });
                }
                
                // Membership type count chart
                const typeCountCanvas = document.getElementById('membershipTypeCountChart');
                if (typeCountCanvas) {
                    destroyChart('membershipTypeCount');
                    const ctx = typeCountCanvas.getContext('2d');
                    allCharts.membershipTypeCount = new Chart(ctx, {
                        type: 'doughnut',
                        data: {
                            labels: sortedTypes.map(([type]) => type),
                            datasets: [{
                                data: sortedTypes.map(([, data]) => data.count),
                                backgroundColor: [
                                    '#007bff', '#28a745', '#ffc107', '#dc3545', '#6c757d',
                                    '#17a2b8', '#fd7e14', '#6610f2', '#e83e8c', '#20c997'
                                ]
                            }]
                        },
                        options: {
                            responsive: true,
                            maintainAspectRatio: false,
                            onClick: (event, elements) => {
                                if (elements.length > 0) {
                                    const index = elements[0].index;
                                    const [typeName, typeData] = sortedTypes[index];
                                    const typeMembers = filteredMemberships.filter(m => m['Membership Name'] === typeName);
                                    
                                    let modalContent = `
                                        <h4>${typeName}</h4>
                                        <p><strong>Total:</strong> ${typeData.count} memberships | <strong>Revenue:</strong> ${formatCurrency(typeData.revenue)}</p>
                                        <p><strong>Active:</strong> ${typeData.active} | <strong>Expired:</strong> ${typeData.count - typeData.active}</p>
                                        <p><strong>Average Value:</strong> ${formatCurrency(typeData.revenue / typeData.count)}</p>
                                        <hr>
                                        <h5>Recent Members:</h5>
                                        <table style="width: 100%; font-size: 0.9em;">
                                            <thead>
                                                <tr>
                                                    <th>Customer</th>
                                                    <th>Purchased</th>
                                                    <th>Amount</th>
                                                    <th>Status</th>
                                                </tr>
                                            </thead>
                                            <tbody>
                                                ${typeMembers.slice(0, 10).map(m => `
                                                    <tr>
                                                        <td>${m['First Name']} ${m['Last Name']}</td>
                                                        <td>${new Date(m['Bought Date/Time (GMT)']).toLocaleDateString()}</td>
                                                        <td>${formatCurrency(parseFloat(m['Paid Amount']))}</td>
                                                        <td style="color: ${m.Expired === 'Yes' ? '#dc3545' : '#28a745'}">${m.Expired === 'Yes' ? 'Expired' : 'Active'}</td>
                                                    </tr>
                                                `).join('')}
                                            </tbody>
                                        </table>
                                    `;
                                    
                                    // Prepare export data
                                    const exportData = typeMembers.map(m => ({
                                        'Customer Name': `${m['First Name']} ${m['Last Name']}`,
                                        'Email': m['Customer Email'],
                                        'Membership Type': m['Membership Name'],
                                        'Purchase Date': new Date(m['Bought Date/Time (GMT)']).toLocaleDateString(),
                                        'Amount Paid': parseFloat(m['Paid Amount']).toFixed(2),
                                        'Status': m.Expired === 'Yes' ? 'Expired' : 'Active',
                                        'Type': m._isNewSale ? 'New Sale' : (m._isRenewal ? 'Renewal' : 'Unknown')
                                    }));
                                    
                                    showModal(`Membership Type: ${typeName}`, modalContent, exportData);
                                }
                            },
                            plugins: {
                                legend: {
                                    position: 'right'
                                }
                            }
                        }
                    });
                }
                
                // Membership type revenue chart (DOUGHNUT with drilldown)
                const typeRevenueCanvas = document.getElementById('membershipTypeRevenueChart');
                if (typeRevenueCanvas) {
                    destroyChart('membershipTypeRevenue');
                    const ctx = typeRevenueCanvas.getContext('2d');
                    allCharts.membershipTypeRevenue = new Chart(ctx, {
                        type: 'doughnut',
                        data: {
                            labels: sortedTypes.map(([type]) => type),
                            datasets: [{
                                data: sortedTypes.map(([, data]) => data.revenue),
                                backgroundColor: [
                                    '#28a745', '#007bff', '#ffc107', '#dc3545', '#6c757d',
                                    '#17a2b8', '#fd7e14', '#6610f2', '#e83e8c', '#20c997'
                                ]
                            }]
                        },
                        options: {
                            responsive: true,
                            maintainAspectRatio: false,
                            onClick: (event, elements) => {
                                if (elements.length > 0) {
                                    const index = elements[0].index;
                                    const [typeName, typeData] = sortedTypes[index];
                                    const typeMembers = filteredMemberships.filter(m => m['Membership Name'] === typeName);
                                    
                                    let modalContent = `
                                        <h4>${typeName}</h4>
                                        <p><strong>Total:</strong> ${typeData.count} memberships | <strong>Revenue:</strong> ${formatCurrency(typeData.revenue)}</p>
                                        <p><strong>Active:</strong> ${typeData.active} | <strong>Expired:</strong> ${typeData.count - typeData.active}</p>
                                        <p><strong>Average Value:</strong> ${formatCurrency(typeData.revenue / typeData.count)}</p>
                                        <hr>
                                        <h5>Recent Members:</h5>
                                        <table style="width: 100%; font-size: 0.9em;">
                                            <thead>
                                                <tr>
                                                    <th>Customer</th>
                                                    <th>Purchased</th>
                                                    <th>Amount</th>
                                                    <th>Status</th>
                                                </tr>
                                            </thead>
                                            <tbody>
                                                ${typeMembers.slice(0, 10).map(m => `
                                                    <tr>
                                                        <td>${m['First Name']} ${m['Last Name']}</td>
                                                        <td>${new Date(m['Bought Date/Time (GMT)']).toLocaleDateString()}</td>
                                                        <td>${formatCurrency(parseFloat(m['Paid Amount']))}</td>
                                                        <td style="color: ${m.Expired === 'Yes' ? '#dc3545' : '#28a745'}">${m.Expired === 'Yes' ? 'Expired' : 'Active'}</td>
                                                    </tr>
                                                `).join('')}
                                            </tbody>
                                        </table>
                                    `;
                                    
                                    // Prepare export data
                                    const exportData = typeMembers.map(m => ({
                                        'Customer Name': `${m['First Name']} ${m['Last Name']}`,
                                        'Email': m['Customer Email'],
                                        'Membership Type': m['Membership Name'],
                                        'Purchase Date': new Date(m['Bought Date/Time (GMT)']).toLocaleDateString(),
                                        'Amount Paid': parseFloat(m['Paid Amount']).toFixed(2),
                                        'Status': m.Expired === 'Yes' ? 'Expired' : 'Active',
                                        'Type': m._isNewSale ? 'New Sale' : (m._isRenewal ? 'Renewal' : 'Unknown')
                                    }));
                                    
                                    showModal(`Membership Type Revenue: ${typeName}`, modalContent, exportData);
                                }
                            },
                            plugins: {
                                legend: {
                                    position: 'right'
                                },
                                tooltip: {
                                    callbacks: {
                                        label: function(context) {
                                            return context.label + ': ' + formatCurrency(context.parsed);
                                        }
                                    }
                                }
                            }
                        }
                    });
                }
                
                // Staff count chart
                const staffCountCanvas = document.getElementById('membershipStaffCountChart');
                if (staffCountCanvas) {
                    destroyChart('membershipStaffCount');
                    const ctx = staffCountCanvas.getContext('2d');
                    allCharts.membershipStaffCount = new Chart(ctx, {
                        type: 'bar',
                        data: {
                            labels: sortedStaff.map(([staff]) => staff),
                            datasets: [{
                                label: 'Memberships Sold',
                                data: sortedStaff.map(([, data]) => data.count),
                                backgroundColor: '#9c27b0',
                                borderColor: '#7b1fa2',
                                borderWidth: 1
                            }]
                        },
                        options: {
                            responsive: true,
                            maintainAspectRatio: false,
                            indexAxis: 'y',
                            onClick: (event, elements) => {
                                if (elements.length > 0) {
                                    const index = elements[0].index;
                                    const [staffName, staffData] = sortedStaff[index];
                                    const staffMembers = filteredMemberships.filter(m => {
                                        const email = (m['Customer Email'] || '').toLowerCase().trim();
                                        if (email && customerFirstVSP[email]) {
                                            return customerFirstVSP[email].vsp === staffName;
                                        }
                                        return (m['Sold by'] || 'Direct/Online') === staffName;
                                    });
                                    
                                    let modalContent = `
                                        <h4>Sales Performance: ${staffName}</h4>
                                        <p><strong>Memberships Sold:</strong> ${staffData.count}</p>
                                        <p><strong>Revenue Generated:</strong> ${formatCurrency(staffData.revenue)}</p>
                                        <p><strong>Average Sale:</strong> ${formatCurrency(staffData.revenue / staffData.count)}</p>
                                        <hr>
                                        <h5>Recent Sales:</h5>
                                        <table style="width: 100%; font-size: 0.9em;">
                                            <thead>
                                                <tr>
                                                    <th>Customer</th>
                                                    <th>Membership</th>
                                                    <th>Date</th>
                                                    <th>Amount</th>
                                                </tr>
                                            </thead>
                                            <tbody>
                                                ${staffMembers.slice(0, 15).map(m => `
                                                    <tr>
                                                        <td>${m['First Name']} ${m['Last Name']}</td>
                                                        <td>${m['Membership Name']}</td>
                                                        <td>${new Date(m['Bought Date/Time (GMT)']).toLocaleDateString()}</td>
                                                        <td>${formatCurrency(parseFloat(m['Paid Amount']))}</td>
                                                    </tr>
                                                `).join('')}
                                            </tbody>
                                        </table>
                                    `;
                                    
                                    // Prepare export data
                                    const exportData = staffMembers.map(m => ({
                                        'Staff Member': staffName,
                                        'Customer Name': `${m['First Name']} ${m['Last Name']}`,
                                        'Email': m['Customer Email'],
                                        'Membership Type': m['Membership Name'],
                                        'Purchase Date': new Date(m['Bought Date/Time (GMT)']).toLocaleDateString(),
                                        'Amount Paid': parseFloat(m['Paid Amount']).toFixed(2),
                                        'Sale Type': m._isNewSale ? 'New Sale' : (m._isRenewal ? 'Renewal' : 'Unknown')
                                    }));
                                    
                                    showModal(`Staff Member: ${staffName}`, modalContent, exportData);
                                }
                            },
                            plugins: { legend: { display: false } },
                            scales: {
                                x: {
                                    beginAtZero: true,
                                    ticks: { stepSize: 1 }
                                }
                            }
                        }
                    });
                }
                
                // Staff revenue chart
                const staffRevenueCanvas = document.getElementById('membershipStaffRevenueChart');
                if (staffRevenueCanvas) {
                    destroyChart('membershipStaffRevenue');
                    const ctx = staffRevenueCanvas.getContext('2d');
                    allCharts.membershipStaffRevenue = new Chart(ctx, {
                        type: 'bar',
                        data: {
                            labels: sortedStaff.map(([staff]) => staff),
                            datasets: [{
                                label: 'Revenue',
                                data: sortedStaff.map(([, data]) => data.revenue),
                                backgroundColor: '#ff6384',
                                borderColor: '#ff3860',
                                borderWidth: 1
                            }]
                        },
                        options: {
                            responsive: true,
                            maintainAspectRatio: false,
                            indexAxis: 'y',
                            onClick: (event, elements) => {
                                if (elements.length > 0) {
                                    const index = elements[0].index;
                                    const [staffName, staffData] = sortedStaff[index];
                                    const staffMembers = filteredMemberships.filter(m => {
                                        const email = (m['Customer Email'] || '').toLowerCase().trim();
                                        if (email && customerFirstVSP[email]) {
                                            return customerFirstVSP[email].vsp === staffName;
                                        }
                                        return (m['Sold by'] || 'Direct/Online') === staffName;
                                    });
                                    
                                    let modalContent = `
                                        <h4>Revenue Performance: ${staffName}</h4>
                                        <p><strong>Total Revenue:</strong> ${formatCurrency(staffData.revenue)}</p>
                                        <p><strong>Memberships Sold:</strong> ${staffData.count}</p>
                                        <p><strong>Average Sale:</strong> ${formatCurrency(staffData.revenue / staffData.count)}</p>
                                        <hr>
                                        <h5>Top Sales:</h5>
                                        <table style="width: 100%; font-size: 0.9em;">
                                            <thead>
                                                <tr>
                                                    <th>Customer</th>
                                                    <th>Membership</th>
                                                    <th>Date</th>
                                                    <th>Amount</th>
                                                </tr>
                                            </thead>
                                            <tbody>
                                                ${staffMembers.sort((a, b) => parseFloat(b['Paid Amount']) - parseFloat(a['Paid Amount'])).slice(0, 15).map(m => `
                                                    <tr>
                                                        <td>${m['First Name']} ${m['Last Name']}</td>
                                                        <td>${m['Membership Name']}</td>
                                                        <td>${new Date(m['Bought Date/Time (GMT)']).toLocaleDateString()}</td>
                                                        <td><strong>${formatCurrency(parseFloat(m['Paid Amount']))}</strong></td>
                                                    </tr>
                                                `).join('')}
                                            </tbody>
                                        </table>
                                    `;
                                    
                                    // Prepare export data (sorted by amount)
                                    const sortedStaffMembers = staffMembers.sort((a, b) => parseFloat(b['Paid Amount']) - parseFloat(a['Paid Amount']));
                                    const exportData = sortedStaffMembers.map(m => ({
                                        'Staff Member': staffName,
                                        'Customer Name': `${m['First Name']} ${m['Last Name']}`,
                                        'Email': m['Customer Email'],
                                        'Membership Type': m['Membership Name'],
                                        'Purchase Date': new Date(m['Bought Date/Time (GMT)']).toLocaleDateString(),
                                        'Amount Paid': parseFloat(m['Paid Amount']).toFixed(2),
                                        'Sale Type': m._isNewSale ? 'New Sale' : (m._isRenewal ? 'Renewal' : 'Unknown')
                                    }));
                                    
                                    showModal(`Staff Member: ${staffName}`, modalContent, exportData);
                                }
                            },
                            plugins: { legend: { display: false } },
                            scales: {
                                x: {
                                    beginAtZero: true,
                                    ticks: {
                                        callback: function(value) {
                                            return formatCurrency(value);
                                        }
                                    }
                                }
                            }
                        }
                    });
                }
                
                // Status chart
                const statusCanvas = document.getElementById('membershipStatusChart');
                if (statusCanvas) {
                    destroyChart('membershipStatus');
                    const ctx = statusCanvas.getContext('2d');
                    allCharts.membershipStatus = new Chart(ctx, {
                        type: 'doughnut',
                        data: {
                            labels: ['Active', 'Expired'],
                            datasets: [{
                                data: [activeMemberships.length, expiredMemberships.length],
                                backgroundColor: ['#28a745', '#dc3545']
                            }]
                        },
                        options: {
                            responsive: true,
                            maintainAspectRatio: false,
                            onClick: (event, elements) => {
                                if (elements.length > 0) {
                                    const index = elements[0].index;
                                    const isActive = index === 0;
                                    const statusMembers = isActive ? activeMemberships : expiredMemberships;
                                    const status = isActive ? 'Active' : 'Expired';
                                    
                                    let modalContent = `
                                        <h4>${status} Memberships</h4>
                                        <p><strong>Count:</strong> ${statusMembers.length}</p>
                                        <p><strong>Total Revenue:</strong> ${formatCurrency(statusMembers.reduce((sum, m) => sum + parseFloat(m['Paid Amount'] || 0), 0))}</p>
                                        <hr>
                                        <h5>Recent ${status} Memberships:</h5>
                                        <table style="width: 100%; font-size: 0.9em;">
                                            <thead>
                                                <tr>
                                                    <th>Customer</th>
                                                    <th>Type</th>
                                                    <th>Purchased</th>
                                                    <th>Amount</th>
                                                    ${!isActive ? '<th>Expired</th>' : ''}
                                                </tr>
                                            </thead>
                                            <tbody>
                                                ${statusMembers.slice(0, 15).map(m => `
                                                    <tr>
                                                        <td>${m['First Name']} ${m['Last Name']}</td>
                                                        <td>${m['Membership Name']}</td>
                                                        <td>${new Date(m['Bought Date/Time (GMT)']).toLocaleDateString()}</td>
                                                        <td>${formatCurrency(parseFloat(m['Paid Amount']))}</td>
                                                        ${!isActive ? `<td>${m['Remaining/ Expiry/ Renewal'] ? new Date(m['Remaining/ Expiry/ Renewal']).toLocaleDateString() : 'N/A'}</td>` : ''}
                                                    </tr>
                                                `).join('')}
                                            </tbody>
                                        </table>
                                    `;
                                    
                                    // Prepare export data
                                    const exportData = statusMembers.map(m => ({
                                        'Status': status,
                                        'Customer Name': `${m['First Name']} ${m['Last Name']}`,
                                        'Email': m['Customer Email'],
                                        'Membership Type': m['Membership Name'],
                                        'Purchase Date': new Date(m['Bought Date/Time (GMT)']).toLocaleDateString(),
                                        'Amount Paid': parseFloat(m['Paid Amount']).toFixed(2),
                                        'Expiry Date': m['Remaining/ Expiry/ Renewal'] ? new Date(m['Remaining/ Expiry/ Renewal']).toLocaleDateString() : 'N/A',
                                        'Sale Type': m._isNewSale ? 'New Sale' : (m._isRenewal ? 'Renewal' : 'Unknown'),
                                        'Frozen': m.Frozen || 'No',
                                        'Refunded': parseFloat(m.Refunded) > 0 ? 'Yes' : 'No'
                                    }));
                                    
                                    showModal(`${status} Memberships`, modalContent, exportData);
                                }
                            },
                            plugins: {
                                legend: {
                                    position: 'bottom'
                                }
                            }
                        }
                    });
                }
                
                // MRR Growth Chart
                const mrrCanvas = document.getElementById('membershipMRRChart');
                if (mrrCanvas) {
                    destroyChart('membershipMRR');
                    const ctx = mrrCanvas.getContext('2d');
                    
                    // Calculate MRR by month
                    const monthlyMRR = {};
                    sortedMonths.forEach(month => {
                        const monthStart = new Date(month + '-01');
                        const monthEnd = new Date(monthStart.getFullYear(), monthStart.getMonth() + 1, 0);
                        
                        let mrrValue = 0;
                        membershipsData.forEach(m => {
                            if (m['Membership Type'] === 'subscription') {
                                const boughtDate = m['Bought Date/Time (GMT)'] ? new Date(m['Bought Date/Time (GMT)']) : null;
                                const expiryDate = m['Remaining/ Expiry/ Renewal'] ? new Date(m['Remaining/ Expiry/ Renewal']) : null;
                                const isExpired = m.Expired === 'Yes';
                                
                                // If subscription was active during this month
                                if (boughtDate && boughtDate <= monthEnd && (!isExpired || (expiryDate && expiryDate >= monthStart))) {
                                    mrrValue += parseFloat(m['Paid Amount']) || 0;
                                }
                            }
                        });
                        monthlyMRR[month] = mrrValue;
                    });
                    
                    allCharts.membershipMRR = new Chart(ctx, {
                        type: 'line',
                        data: {
                            labels: sortedMonths.map(m => {
                                const [year, month] = m.split('-');
                                const date = new Date(year, month - 1);
                                return date.toLocaleDateString('en-US', { month: 'short', year: 'numeric' });
                            }),
                            datasets: [{
                                label: 'MRR',
                                data: sortedMonths.map(m => monthlyMRR[m]),
                                borderColor: '#9c27b0',
                                backgroundColor: 'rgba(156, 39, 176, 0.1)',
                                borderWidth: 3,
                                fill: true,
                                tension: 0.4
                            }]
                        },
                        options: {
                            responsive: true,
                            maintainAspectRatio: false,
                            plugins: { legend: { display: false } },
                            scales: {
                                y: {
                                    beginAtZero: true,
                                    ticks: {
                                        callback: function(value) {
                                            return formatCurrency(value);
                                        }
                                    }
                                }
                            }
                        }
                    });
                }
                
                // Timeline chart (daily new memberships - split by new vs renewal)
                const dailyNewSales = {};
                const dailyRenewals = {};
                membershipsData.forEach(m => {
                    const boughtDate = m['Bought Date/Time (GMT)'] ? new Date(m['Bought Date/Time (GMT)']) : null;
                    if (boughtDate) {
                        const dateKey = boughtDate.toISOString().split('T')[0];
                        if (m._isNewSale) {
                            dailyNewSales[dateKey] = (dailyNewSales[dateKey] || 0) + 1;
                        } else if (m._isRenewal) {
                            dailyRenewals[dateKey] = (dailyRenewals[dateKey] || 0) + 1;
                        }
                    }
                });
                const sortedDailyDates = [...new Set([...Object.keys(dailyNewSales), ...Object.keys(dailyRenewals)])].sort();
                
                const timelineCanvas = document.getElementById('membershipTimelineChart');
                if (timelineCanvas) {
                    destroyChart('membershipTimeline');
                    const ctx = timelineCanvas.getContext('2d');
                    allCharts.membershipTimeline = new Chart(ctx, {
                        type: 'bar',
                        data: {
                            labels: sortedDailyDates,
                            datasets: [
                                {
                                    label: 'New Sales',
                                    data: sortedDailyDates.map(d => dailyNewSales[d] || 0),
                                    backgroundColor: '#28a745',
                                    borderColor: '#218838',
                                    borderWidth: 1
                                },
                                {
                                    label: 'Renewals',
                                    data: sortedDailyDates.map(d => dailyRenewals[d] || 0),
                                    backgroundColor: '#007bff',
                                    borderColor: '#0056b3',
                                    borderWidth: 1
                                }
                            ]
                        },
                        options: {
                            responsive: true,
                            maintainAspectRatio: false,
                            plugins: { 
                                legend: { 
                                    display: true,
                                    position: 'top'
                                } 
                            },
                            scales: {
                                x: { stacked: true },
                                y: {
                                    stacked: true,
                                    beginAtZero: true,
                                    ticks: { stepSize: 1 }
                                }
                            }
                        }
                    });
                }
                
                // Weekly Sales Trend
                const weeklyCanvas = document.getElementById('membershipWeeklyChart');
                if (weeklyCanvas) {
                    destroyChart('membershipWeekly');
                    const ctx = weeklyCanvas.getContext('2d');
                    
                    // Group by week
                    const weeklyData = {};
                    filteredMemberships.forEach(m => {
                        const boughtDate = m['Bought Date/Time (GMT)'] ? new Date(m['Bought Date/Time (GMT)']) : null;
                        if (boughtDate) {
                            const year = boughtDate.getFullYear();
                            const week = Math.ceil((boughtDate - new Date(year, 0, 1)) / (7 * 24 * 60 * 60 * 1000));
                            const weekKey = `${year}-W${String(week).padStart(2, '0')}`;
                            if (!weeklyData[weekKey]) {
                                weeklyData[weekKey] = { count: 0, revenue: 0 };
                            }
                            weeklyData[weekKey].count++;
                            weeklyData[weekKey].revenue += parseFloat(m['Paid Amount']) || 0;
                        }
                    });
                    
                    const sortedWeeks = Object.keys(weeklyData).sort();
                    
                    allCharts.membershipWeekly = new Chart(ctx, {
                        type: 'line',
                        data: {
                            labels: sortedWeeks,
                            datasets: [
                                {
                                    label: 'Weekly Sales Count',
                                    data: sortedWeeks.map(w => weeklyData[w].count),
                                    borderColor: '#007bff',
                                    backgroundColor: 'rgba(0, 123, 255, 0.1)',
                                    borderWidth: 2,
                                    fill: true,
                                    tension: 0.4,
                                    yAxisID: 'y'
                                },
                                {
                                    label: 'Weekly Revenue',
                                    data: sortedWeeks.map(w => weeklyData[w].revenue),
                                    borderColor: '#28a745',
                                    backgroundColor: 'rgba(40, 167, 69, 0.1)',
                                    borderWidth: 2,
                                    fill: true,
                                    tension: 0.4,
                                    yAxisID: 'y1'
                                }
                            ]
                        },
                        options: {
                            responsive: true,
                            maintainAspectRatio: false,
                            plugins: {
                                legend: {
                                    display: true,
                                    position: 'top'
                                }
                            },
                            scales: {
                                y: {
                                    type: 'linear',
                                    display: true,
                                    position: 'left',
                                    beginAtZero: true,
                                    ticks: { stepSize: 1 }
                                },
                                y1: {
                                    type: 'linear',
                                    display: true,
                                    position: 'right',
                                    beginAtZero: true,
                                    grid: {
                                        drawOnChartArea: false
                                    },
                                    ticks: {
                                        callback: function(value) {
                                            return formatCurrency(value);
                                        }
                                    }
                                }
                            }
                        }
                    });
                }
                
                // Day of Week Chart
                const dayOfWeekCanvas = document.getElementById('membershipDayOfWeekChart');
                if (dayOfWeekCanvas) {
                    destroyChart('membershipDayOfWeek');
                    const ctx = dayOfWeekCanvas.getContext('2d');
                    
                    const dayNames = ['Sunday', 'Monday', 'Tuesday', 'Wednesday', 'Thursday', 'Friday', 'Saturday'];
                    const dayData = {};
                    dayNames.forEach(day => dayData[day] = 0);
                    
                    membershipsData.forEach(m => {
                        const boughtDate = m['Bought Date/Time (GMT)'] ? new Date(m['Bought Date/Time (GMT)']) : null;
                        if (boughtDate) {
                            const dayName = dayNames[boughtDate.getDay()];
                            dayData[dayName]++;
                        }
                    });
                    
                    allCharts.membershipDayOfWeek = new Chart(ctx, {
                        type: 'bar',
                        data: {
                            labels: dayNames,
                            datasets: [{
                                label: 'Memberships Sold',
                                data: dayNames.map(d => dayData[d]),
                                backgroundColor: '#ffc107',
                                borderColor: '#ff9800',
                                borderWidth: 1
                            }]
                        },
                        options: {
                            responsive: true,
                            maintainAspectRatio: false,
                            plugins: { legend: { display: false } },
                            scales: {
                                y: {
                                    beginAtZero: true,
                                    ticks: { stepSize: 1 }
                                }
                            }
                        }
                    });
                }
                
                // Average Sale Value Over Time
                const avgValueCanvas = document.getElementById('membershipAvgValueChart');
                if (avgValueCanvas) {
                    destroyChart('membershipAvgValue');
                    const ctx = avgValueCanvas.getContext('2d');
                    
                    // Calculate average value per month
                    const monthlyAvg = {};
                    sortedMonths.forEach(month => {
                        const monthMemberships = filteredMemberships.filter(m => {
                            const boughtDate = m['Bought Date/Time (GMT)'] ? new Date(m['Bought Date/Time (GMT)']) : null;
                            if (boughtDate) {
                                const memberMonth = `${boughtDate.getFullYear()}-${String(boughtDate.getMonth() + 1).padStart(2, '0')}`;
                                return memberMonth === month;
                            }
                            return false;
                        });
                        
                        if (monthMemberships.length > 0) {
                            const totalValue = monthMemberships.reduce((sum, m) => sum + (parseFloat(m['Paid Amount']) || 0), 0);
                            monthlyAvg[month] = totalValue / monthMemberships.length;
                        } else {
                            monthlyAvg[month] = 0;
                        }
                    });
                    
                    allCharts.membershipAvgValue = new Chart(ctx, {
                        type: 'line',
                        data: {
                            labels: sortedMonths.map(m => {
                                const [year, month] = m.split('-');
                                const date = new Date(year, month - 1);
                                return date.toLocaleDateString('en-US', { month: 'short', year: 'numeric' });
                            }),
                            datasets: [{
                                label: 'Average Sale Value',
                                data: sortedMonths.map(m => monthlyAvg[m]),
                                borderColor: '#ff6384',
                                backgroundColor: 'rgba(255, 99, 132, 0.1)',
                                borderWidth: 2,
                                fill: true,
                                tension: 0.4
                            }]
                        },
                        options: {
                            responsive: true,
                            maintainAspectRatio: false,
                            plugins: { legend: { display: false } },
                            scales: {
                                y: {
                                    beginAtZero: true,
                                    ticks: {
                                        callback: function(value) {
                                            return formatCurrency(value);
                                        }
                                    }
                                }
                            }
                        }
                    });
                }
            }, 100);
        }
        
        // Export functions for membership data
        function exportMembershipTypeData() {
            const data = [];
            Object.entries(membershipTypes).forEach(([type, stats]) => {
                data.push({
                    'Membership Type': type,
                    'Total Count': stats.count,
                    'New Sales': stats.newSales || 0,
                    'Renewals': stats.renewals || 0,
                    'Active': stats.active,
                    'Expired': stats.count - stats.active,
                    'Revenue': stats.revenue.toFixed(2),
                    'Average Value': (stats.revenue / stats.count).toFixed(2)
                });
            });
            exportToCSV(data, 'membership-types-' + new Date().toISOString().split('T')[0] + '.csv');
        }
        
        function exportStaffSalesData() {
            const data = [];
            Object.entries(salesByStaff).forEach(([staff, stats]) => {
                data.push({
                    'Staff Member': staff,
                    'Total Sales': stats.count,
                    'New Sales': stats.newSales || 0,
                    'Renewals': stats.renewals || 0,
                    'Revenue Generated': stats.revenue.toFixed(2),
                    'Average Sale Value': (stats.revenue / stats.count).toFixed(2)
                });
            });
            exportToCSV(data, 'staff-sales-' + new Date().toISOString().split('T')[0] + '.csv');
        }
        
        // MEMBERSHIP CANCELLATIONS TAB
        function renderCancellationsTab() {
            console.log('renderCancellationsTab called');
            console.log('membershipCancellationsData length:', membershipCancellationsData ? membershipCancellationsData.length : 0);
            console.log('filteredCancellations length:', filteredCancellations ? filteredCancellations.length : 0);
            
            if (!membershipCancellationsData || membershipCancellationsData.length === 0) {
                console.log('No cancellation data, showing empty state');
                document.getElementById('cancellations').innerHTML = `
                    <div class="alert info">
                        <h4>üö´ Cancellation Analytics</h4>
                        <p>Upload the <strong>Membership Cancellations CSV</strong> file to unlock comprehensive cancellation analytics including churn reasons, trends, and retention insights.</p>
                    </div>
                `;
                return;
            }
            
            // Parse cancellation data
            const cancellationsByType = {};
            const cancellationsByMonth = {};
            const cancellationReasons = {};
            const cancellationsByLocation = {};
            const dailyCancellations = {};
            const cancellationsByDayOfWeek = {
                'Sunday': 0, 'Monday': 0, 'Tuesday': 0, 'Wednesday': 0,
                'Thursday': 0, 'Friday': 0, 'Saturday': 0
            };
            const cancellationsByHour = {};
            const cancellationRateByMonth = {};
            
            let totalCancellations = filteredCancellations.length;
            let withReasons = 0;
            let withImprovements = 0;
            let mostRecentCancellation = null;
            let oldestCancellation = null;
            let totalCancellationValue = 0;
            
            // For financial calculations
            const typeChurnRates = {};
            const locationChurnRates = {};
            
            filteredCancellations.forEach(cancellation => {
                // Count cancellations with reasons
                const reason = (cancellation['Reason'] || '').trim();
                const improvements = (cancellation['Possible improvements'] || '').trim();
                
                // Track cancellation value by matching Customer Email to membership sales data
                const customerEmail = (cancellation['Email'] || cancellation['E-mail'] || cancellation['Customer Email'] || '').toLowerCase().trim();
                if (customerEmail && membershipsData) {
                    // Find the most recent membership for this customer
                    const matchingMemberships = membershipsData.filter(m => 
                        (m['Customer Email'] || '').toLowerCase().trim() === customerEmail
                    );
                    if (matchingMemberships.length > 0) {
                        // Sort by date and get most recent
                        const sortedMemberships = matchingMemberships.sort((a, b) => {
                            const dateA = a['Bought Date/Time (GMT)'] ? new Date(a['Bought Date/Time (GMT)']) : new Date(0);
                            const dateB = b['Bought Date/Time (GMT)'] ? new Date(b['Bought Date/Time (GMT)']) : new Date(0);
                            return dateB - dateA;
                        });
                        // Use Paid Amount as monthly value (these are monthly subscriptions)
                        totalCancellationValue += parseFloat(sortedMemberships[0]['Paid Amount']) || 0;
                    }
                }
                
                if (reason) {
                    withReasons++;
                    // Categorize reasons
                    const reasonKey = reason.split('>')[0].trim() || reason;
                    if (!cancellationReasons[reasonKey]) {
                        cancellationReasons[reasonKey] = 0;
                    }
                    cancellationReasons[reasonKey]++;
                }
                
                if (improvements) withImprovements++;
                
                // Parse cancellation date
                const cancelledAt = cancellation['Cancelled at'];
                let cancelDate = null;
                
                if (cancelledAt) {
                    // Try parsing the date (format: "2025-10-28, 1:53 PM")
                    const dateParts = cancelledAt.split(',')[0];
                    const timePart = cancelledAt.split(',')[1];
                    cancelDate = new Date(dateParts);
                    
                    if (!isNaN(cancelDate.getTime())) {
                        // Track most recent and oldest
                        if (!mostRecentCancellation || cancelDate > mostRecentCancellation) {
                            mostRecentCancellation = cancelDate;
                        }
                        if (!oldestCancellation || cancelDate < oldestCancellation) {
                            oldestCancellation = cancelDate;
                        }
                        
                        // Track by day of week
                        const dayNames = ['Sunday', 'Monday', 'Tuesday', 'Wednesday', 'Thursday', 'Friday', 'Saturday'];
                        const dayOfWeek = dayNames[cancelDate.getDay()];
                        cancellationsByDayOfWeek[dayOfWeek]++;
                        
                        // Track by hour (if time available)
                        if (timePart) {
                            const timeStr = timePart.trim();
                            const hourMatch = timeStr.match(/(\d+):/);
                            if (hourMatch) {
                                let hour = parseInt(hourMatch[1]);
                                // Convert to 24-hour if PM
                                if (timeStr.includes('PM') && hour !== 12) hour += 12;
                                if (timeStr.includes('AM') && hour === 12) hour = 0;
                                
                                if (!cancellationsByHour[hour]) {
                                    cancellationsByHour[hour] = 0;
                                }
                                cancellationsByHour[hour]++;
                            }
                        }
                        
                        // Track by month
                        const monthKey = `${cancelDate.getFullYear()}-${String(cancelDate.getMonth() + 1).padStart(2, '0')}`;
                        if (!cancellationsByMonth[monthKey]) {
                            cancellationsByMonth[monthKey] = 0;
                        }
                        cancellationsByMonth[monthKey]++;
                        
                        // Track by day
                        const dateKey = cancelDate.toISOString().split('T')[0];
                        if (!dailyCancellations[dateKey]) {
                            dailyCancellations[dateKey] = 0;
                        }
                        dailyCancellations[dateKey]++;
                    }
                }
                
                // Track by membership type
                const type = cancellation['Membership'] || 'Unknown';
                if (!cancellationsByType[type]) {
                    cancellationsByType[type] = 0;
                }
                cancellationsByType[type]++;
                
                // Track by location
                const location = cancellation['Home location'] || 'Unknown';
                if (!cancellationsByLocation[location]) {
                    cancellationsByLocation[location] = 0;
                }
                cancellationsByLocation[location]++;
            });
            
            // Calculate churn rates by type and location if we have sales data
            if (membershipsData && membershipsData.length > 0) {
                // Build customer location mapping from cancellations data
                const customerLocationMap = {};
                filteredCancellations.forEach(c => {
                    const email = c['Email'] || c['E-mail'] || c['Customer Email'];
                    const location = c['Home location'];
                    if (email && location) {
                        customerLocationMap[email.toLowerCase()] = location;
                    }
                });
                
                // Count sales by type
                const salesByType = {};
                membershipsData.forEach(m => {
                    const type = m['Membership Name'] || 'Unknown';
                    if (!salesByType[type]) salesByType[type] = 0;
                    salesByType[type]++;
                });
                
                // Calculate churn rate for each type
                Object.keys(cancellationsByType).forEach(type => {
                    if (salesByType[type]) {
                        typeChurnRates[type] = ((cancellationsByType[type] / salesByType[type]) * 100).toFixed(1);
                    }
                });
                
                // Count sales by location using customer location mapping
                const salesByLocation = {};
                membershipsData.forEach(m => {
                    const email = m['Customer Email'];
                    if (email) {
                        const loc = customerLocationMap[email.toLowerCase()] || m['Customer Home Location'] || 'Unknown';
                        if (!salesByLocation[loc]) salesByLocation[loc] = 0;
                        salesByLocation[loc]++;
                    } else {
                        const loc = m['Customer Home Location'] || 'Unknown';
                        if (!salesByLocation[loc]) salesByLocation[loc] = 0;
                        salesByLocation[loc]++;
                    }
                });
                
                // Calculate churn rate for each location
                Object.keys(cancellationsByLocation).forEach(loc => {
                    if (salesByLocation[loc] && salesByLocation[loc] > 0) {
                        locationChurnRates[loc] = ((cancellationsByLocation[loc] / salesByLocation[loc]) * 100).toFixed(1);
                    }
                });
                
                // Calculate cancellation rate by month
                const salesByMonth = {};
                membershipsData.forEach(m => {
                    const dateStr = m['Bought Date/Time (GMT)'];
                    if (dateStr) {
                        const date = new Date(dateStr);
                        if (!isNaN(date.getTime())) {
                            const monthKey = `${date.getFullYear()}-${String(date.getMonth() + 1).padStart(2, '0')}`;
                            if (!salesByMonth[monthKey]) salesByMonth[monthKey] = 0;
                            salesByMonth[monthKey]++;
                        }
                    }
                });
                
                Object.keys(cancellationsByMonth).forEach(month => {
                    if (salesByMonth[month]) {
                        cancellationRateByMonth[month] = ((cancellationsByMonth[month] / salesByMonth[month]) * 100).toFixed(1);
                    }
                });
            }
            
            // Sort data for charts
            const sortedTypes = Object.entries(cancellationsByType)
                .sort((a, b) => b[1] - a[1])
                .slice(0, 10);
            
            const sortedReasons = Object.entries(cancellationReasons)
                .sort((a, b) => b[1] - a[1])
                .slice(0, 10);
            
            const sortedLocations = Object.entries(cancellationsByLocation)
                .sort((a, b) => b[1] - a[1])
                .slice(0, 10);
            
            const sortedMonths = Object.keys(cancellationsByMonth).sort();
            const sortedDates = Object.keys(dailyCancellations).sort();
            
            // Find most common day of week
            const mostCommonDay = Object.entries(cancellationsByDayOfWeek)
                .sort((a, b) => b[1] - a[1])[0];
            
            // Find peak cancellation month
            const peakMonth = sortedMonths.length > 0 ? 
                Object.entries(cancellationsByMonth)
                    .sort((a, b) => b[1] - a[1])[0] : null;
            
            // Most at-risk type (highest churn rate)
            const atRiskType = Object.entries(typeChurnRates)
                .sort((a, b) => parseFloat(b[1]) - parseFloat(a[1]))[0];
            
            // Calculate churn rate
            let churnRateText = 'N/A';
            let churnRateValue = 0;
            if (membershipsData && membershipsData.length > 0) {
                churnRateValue = (totalCancellations / membershipsData.length) * 100;
                churnRateText = `${churnRateValue.toFixed(1)}%`;
            }
            
            // Calculate time span
            let timeSpanDays = 0;
            if (mostRecentCancellation && oldestCancellation) {
                timeSpanDays = Math.floor((mostRecentCancellation - oldestCancellation) / (1000 * 60 * 60 * 24));
            }
            
            console.log('Cancellations data processed:');
            console.log('- Total cancellations:', totalCancellations);
            console.log('- With reasons:', withReasons);
            console.log('- Churn rate:', churnRateText);
            console.log('- By type:', sortedTypes);
            console.log('- By location:', sortedLocations);
            console.log('- Most common day:', mostCommonDay);
            
            let html = `
                <div class="section">
                    <h2>Membership Cancellations Overview</h2>
                    
                    <!-- Primary Metrics Grid -->
                    <div class="metrics-grid" style="grid-template-columns: repeat(7, 1fr); margin-bottom: 30px;">
                        <div class="metric-card compact" style="background: linear-gradient(135deg, rgba(244, 67, 54, 0.1), rgba(211, 47, 47, 0.05)); border-left: 4px solid #f44336;">
                            <div class="metric-label">üö´ Total Cancellations</div>
                            <div class="metric-value">${formatNumber(totalCancellations)}</div>
                            <div class="metric-subtext">Total memberships<br>cancelled</div>
                        </div>
                        
                        <div class="metric-card compact" style="background: linear-gradient(135deg, rgba(220, 53, 69, 0.1), rgba(200, 35, 51, 0.05)); border-left: 4px solid #dc3545;">
                            <div class="metric-label">üí∞ Lost Value</div>
                            <div class="metric-value">${formatCurrency(totalCancellationValue)}</div>
                            <div class="metric-subtext">Total revenue<br>from cancelled</div>
                        </div>
                        
                        <div class="metric-card compact" style="background: linear-gradient(135deg, rgba(255, 152, 0, 0.1), rgba(230, 81, 0, 0.05)); border-left: 4px solid #ff9800;">
                            <div class="metric-label">üìä Churn Rate</div>
                            <div class="metric-value">${churnRateText}</div>
                            <div class="metric-subtext">Cancellations vs<br>total sales</div>
                        </div>
                        
                        <div class="metric-card compact" style="background: linear-gradient(135deg, rgba(156, 39, 176, 0.1), rgba(123, 31, 162, 0.05)); border-left: 4px solid #9c27b0;">
                            <div class="metric-label">üí¨ With Reasons</div>
                            <div class="metric-value">${formatNumber(withReasons)}</div>
                            <div class="metric-subtext">${((withReasons / totalCancellations) * 100).toFixed(1)}% provided<br>cancellation reason</div>
                        </div>
                        
                        <div class="metric-card compact" style="background: linear-gradient(135deg, rgba(33, 150, 243, 0.1), rgba(13, 71, 161, 0.05)); border-left: 4px solid #2196f3;">
                            <div class="metric-label">üí° Feedback</div>
                            <div class="metric-value">${formatNumber(withImprovements)}</div>
                            <div class="metric-subtext">${((withImprovements / totalCancellations) * 100).toFixed(1)}% provided<br>improvement ideas</div>
                        </div>
                        
                        <div class="metric-card compact" style="background: linear-gradient(135deg, rgba(76, 175, 80, 0.1), rgba(56, 142, 60, 0.05)); border-left: 4px solid #4caf50;">
                            <div class="metric-label">üìà Avg/Month</div>
                            <div class="metric-value">${(totalCancellations / Math.max(sortedMonths.length, 1)).toFixed(1)}</div>
                            <div class="metric-subtext">Average cancellations<br>per month</div>
                        </div>
                        
                        <div class="metric-card compact" style="background: linear-gradient(135deg, rgba(103, 58, 183, 0.1), rgba(81, 45, 168, 0.05)); border-left: 4px solid #673ab7;">
                            <div class="metric-label">üìÖ Time Span</div>
                            <div class="metric-value">${timeSpanDays}</div>
                            <div class="metric-subtext">Days between<br>first & last</div>
                        </div>
                    </div>
                    
                    <!-- Key Insights Cards -->
                    <div class="metrics-grid" style="grid-template-columns: repeat(4, 1fr); margin-bottom: 40px;">
                        <div class="metric-card" style="background: linear-gradient(135deg, rgba(255, 87, 34, 0.1), rgba(244, 67, 54, 0.05)); border-left: 4px solid #ff5722;">
                            <div class="metric-label">üìÜ Most Common Day</div>
                            <div class="metric-value" style="font-size: 1.3em;">${mostCommonDay ? mostCommonDay[0] : 'N/A'}</div>
                            <div class="metric-subtext">${mostCommonDay ? formatNumber(mostCommonDay[1]) : 0} cancellations<br>on ${mostCommonDay ? mostCommonDay[0] + 's' : 'N/A'}</div>
                        </div>
                        
                        <div class="metric-card" style="background: linear-gradient(135deg, rgba(233, 30, 99, 0.1), rgba(194, 24, 91, 0.05)); border-left: 4px solid #e91e63;">
                            <div class="metric-label">üìä Peak Month</div>
                            <div class="metric-value" style="font-size: 1.1em;">${peakMonth ? new Date(peakMonth[0]).toLocaleDateString('en-US', { month: 'short', year: '2-digit' }) : 'N/A'}</div>
                            <div class="metric-subtext">${peakMonth ? formatNumber(peakMonth[1]) : 0} cancellations<br>in peak month</div>
                        </div>
                        
                        <div class="metric-card" style="background: linear-gradient(135deg, rgba(255, 193, 7, 0.1), rgba(255, 160, 0, 0.05)); border-left: 4px solid #ffc107;">
                            <div class="metric-label">‚ö†Ô∏è At-Risk Type</div>
                            <div class="metric-value" style="font-size: 1.1em;">${atRiskType ? atRiskType[0].substring(0, 15) + (atRiskType[0].length > 15 ? '...' : '') : 'N/A'}</div>
                            <div class="metric-subtext">${atRiskType ? atRiskType[1] + '% churn' : 'N/A'}<br>highest churn rate</div>
                        </div>
                        
                        <div class="metric-card" style="background: linear-gradient(135deg, rgba(0, 150, 136, 0.1), rgba(0, 121, 107, 0.05)); border-left: 4px solid #009688;">
                            <div class="metric-label">üìã Top Reason</div>
                            <div class="metric-value" style="font-size: 1.1em;">${sortedReasons.length > 0 ? sortedReasons[0][0].substring(0, 12) + '...' : 'N/A'}</div>
                            <div class="metric-subtext">${sortedReasons.length > 0 ? formatNumber(sortedReasons[0][1]) : 0} mentions<br>most common</div>
                        </div>
                    </div>
                </div>
                
                <!-- Cancellation Trends -->
                <div class="section">
                    <h2>Cancellation Trends Over Time</h2>
                    <div class="chart-grid" style="grid-template-columns: repeat(3, 1fr);">
                        <div class="chart-container">
                            <h3>Monthly Cancellations</h3>
                            <div class="chart-wrapper">
                                <canvas id="cancellationsMonthlyChart"></canvas>
                            </div>
                        </div>
                        
                        <div class="chart-container">
                            <h3>Cumulative Cancellations</h3>
                            <div class="chart-wrapper">
                                <canvas id="cancellationsCumulativeChart"></canvas>
                            </div>
                        </div>
                        
                        <div class="chart-container">
                            <h3>Cancellation Rate by Month</h3>
                            <div class="chart-wrapper">
                                <canvas id="cancellationRateChart"></canvas>
                            </div>
                        </div>
                    </div>
                </div>
                
                <!-- Day & Time Patterns -->
                <div class="section">
                    <h2>Cancellation Patterns by Day &amp; Time</h2>
                    <div class="chart-grid">
                        <div class="chart-container">
                            <h3>Cancellations by Day of Week</h3>
                            <div class="chart-wrapper">
                                <canvas id="cancellationsByDayChart"></canvas>
                            </div>
                        </div>
                        
                        <div class="chart-container">
                            <h3>Daily Cancellation Activity</h3>
                            <div class="chart-wrapper">
                                <canvas id="cancellationsDailyLineChart"></canvas>
                            </div>
                        </div>
                    </div>
                </div>
                
                <!-- Cancellation Reasons Analysis -->
                <div class="section">
                    <h2>Why Customers Cancel</h2>
                    <div class="charts-grid">
                        <div class="chart-container">
                            <h3>Top 10 Cancellation Reasons</h3>
                            <div id="cancellationReasonsList" style="padding: 10px;"></div>
                        </div>
                        
                        <div class="chart-container">
                            <h3>Feedback Response Rate</h3>
                            <div class="chart-wrapper">
                                <canvas id="feedbackRateChart"></canvas>
                            </div>
                        </div>
                    </div>
                </div>
                
                <!-- Membership Type Deep Dive -->
                <div class="section">
                    <h2>Cancellations by Membership Type</h2>
                    <div class="charts-grid">
                        <div class="chart-container">
                            <h3>Cancellations Count by Type</h3>
                            <div class="chart-wrapper">
                                <canvas id="cancellationsByTypeChart"></canvas>
                            </div>
                        </div>
                        
                        <div class="chart-container">
                            <h3>Churn Rate by Type</h3>
                            <div class="chart-wrapper">
                                <canvas id="churnRateByTypeChart"></canvas>
                            </div>
                        </div>
                    </div>
                </div>
                
                <!-- Location Analysis -->
                <div class="section">
                    <h2>Geographic Cancellation Analysis</h2>
                    <div class="chart-grid" style="grid-template-columns: repeat(3, 1fr);">
                        <div class="chart-container">
                            <h3>Cancellations by Location</h3>
                            <div class="chart-wrapper">
                                <canvas id="cancellationsByLocationChart"></canvas>
                            </div>
                        </div>
                        
                        <div class="chart-container">
                            <h3>Location Distribution</h3>
                            <div class="chart-wrapper">
                                <canvas id="cancellationsByLocationPieChart"></canvas>
                            </div>
                        </div>
                        
                        <div class="chart-container">
                            <h3>Churn Rate by Location</h3>
                            <div class="chart-wrapper">
                                <canvas id="churnRateByLocationChart"></canvas>
                            </div>
                        </div>
                    </div>
                </div>
                
                <!-- Comparison: Sales vs Cancellations -->
                <div class="section">
                    <h2>Sales vs Cancellations Comparison</h2>
                    <div class="chart-grid">
                        <div class="chart-container">
                            <h3>Monthly Sales vs Cancellations</h3>
                            <div class="chart-wrapper">
                                <canvas id="salesVsCancellationsChart"></canvas>
                            </div>
                        </div>
                        
                        <div class="chart-container">
                            <h3>Net Membership Growth</h3>
                            <div class="chart-wrapper">
                                <canvas id="netGrowthChart"></canvas>
                            </div>
                        </div>
                    </div>
                </div>
                
                <!-- Risk Analysis -->
                <div class="section">
                    <h2>Risk Analysis &amp; Insights</h2>
                    <div class="metrics-grid" style="grid-template-columns: repeat(3, 1fr); margin-bottom: 30px;">
                        <div class="metric-card" style="background: linear-gradient(135deg, rgba(244, 67, 54, 0.15), rgba(211, 47, 47, 0.08)); border: 2px solid #f44336;">
                            <div class="metric-label" style="font-size: 16px; font-weight: 700; color: #f44336;">üî¥ HIGH RISK</div>
                            <div class="metric-value" style="font-size: 1.5em; color: #f44336;">
                                ${Object.entries(typeChurnRates).filter(([t, r]) => parseFloat(r) > 20).length}
                            </div>
                            <div class="metric-subtext">Membership types with<br>churn rate > 20%</div>
                        </div>
                        
                        <div class="metric-card" style="background: linear-gradient(135deg, rgba(255, 152, 0, 0.15), rgba(230, 81, 0, 0.08)); border: 2px solid #ff9800;">
                            <div class="metric-label" style="font-size: 16px; font-weight: 700; color: #ff9800;">üü° MEDIUM RISK</div>
                            <div class="metric-value" style="font-size: 1.5em; color: #ff9800;">
                                ${Object.entries(typeChurnRates).filter(([t, r]) => parseFloat(r) >= 10 && parseFloat(r) <= 20).length}
                            </div>
                            <div class="metric-subtext">Membership types with<br>10-20% churn rate</div>
                        </div>
                        
                        <div class="metric-card" style="background: linear-gradient(135deg, rgba(76, 175, 80, 0.15), rgba(56, 142, 60, 0.08)); border: 2px solid #4caf50;">
                            <div class="metric-label" style="font-size: 16px; font-weight: 700; color: #4caf50;">üü¢ LOW RISK</div>
                            <div class="metric-value" style="font-size: 1.5em; color: #4caf50;">
                                ${Object.entries(typeChurnRates).filter(([t, r]) => parseFloat(r) < 10).length}
                            </div>
                            <div class="metric-subtext">Membership types with<br>churn rate < 10%</div>
                        </div>
                    </div>
                    
                    <div class="chart-grid">
                        <div class="chart-container">
                            <h3>Risk Matrix: Type Performance</h3>
                            <div class="chart-wrapper">
                                <canvas id="riskMatrixChart"></canvas>
                            </div>
                        </div>
                        
                        <div class="chart-container">
                            <h3>Cancellation Velocity (Trend)</h3>
                            <div class="chart-wrapper">
                                <canvas id="cancellationVelocityChart"></canvas>
                            </div>
                        </div>
                    </div>
                </div>
            `;
            
            document.getElementById('cancellations').innerHTML = html;
            
            // Render Monthly Cancellations Chart
            const monthlyCanvas = document.getElementById('cancellationsMonthlyChart');
            if (monthlyCanvas) {
                destroyChart('cancellationsMonthly');
                const ctx = monthlyCanvas.getContext('2d');
                allCharts.cancellationsMonthly = new Chart(ctx, {
                    type: 'bar',
                    data: {
                        labels: sortedMonths.map(m => {
                            const [year, month] = m.split('-');
                            const date = new Date(year, parseInt(month) - 1);
                            return date.toLocaleDateString('en-US', { month: 'short', year: 'numeric' });
                        }),
                        datasets: [{
                            label: 'Cancellations',
                            data: sortedMonths.map(m => cancellationsByMonth[m]),
                            backgroundColor: 'rgba(244, 67, 54, 0.7)',
                            borderColor: 'rgba(244, 67, 54, 1)',
                            borderWidth: 2
                        }]
                    },
                    options: {
                        responsive: true,
                        maintainAspectRatio: false,
                        onClick: (event, elements) => {
                            if (elements.length > 0) {
                                const index = elements[0].index;
                                const month = sortedMonths[index];
                                const count = cancellationsByMonth[month];
                                showCancellationMonthDetails(month, count);
                            }
                        },
                        plugins: {
                            legend: { display: false }
                        },
                        scales: {
                            y: {
                                beginAtZero: true,
                                ticks: { precision: 0 }
                            }
                        }
                    }
                });
            }
            
            // Render Cumulative Cancellations Chart
            const cumulativeCanvas = document.getElementById('cancellationsCumulativeChart');
            if (cumulativeCanvas) {
                destroyChart('cancellationsCumulative');
                const ctx = cumulativeCanvas.getContext('2d');
                
                let cumulative = 0;
                const cumulativeData = sortedDates.map(date => {
                    cumulative += dailyCancellations[date];
                    return cumulative;
                });
                
                allCharts.cancellationsCumulative = new Chart(ctx, {
                    type: 'line',
                    data: {
                        labels: sortedDates,
                        datasets: [{
                            label: 'Cumulative Cancellations',
                            data: cumulativeData,
                            borderColor: 'rgba(244, 67, 54, 1)',
                            backgroundColor: 'rgba(244, 67, 54, 0.1)',
                            fill: true,
                            tension: 0.4,
                            borderWidth: 3
                        }]
                    },
                    options: {
                        responsive: true,
                        maintainAspectRatio: false,
                        plugins: {
                            legend: { display: false }
                        },
                        scales: {
                            y: {
                                beginAtZero: true,
                                ticks: { precision: 0 }
                            }
                        }
                    }
                });
            }
            
            // Sentiment Analysis Function
            function analyzeSentiment(reason) {
                const lowerReason = reason.toLowerCase();
                
                // Negative sentiment keywords
                const negativeWords = ['expensive', 'cost', 'price', 'afford', 'too much', 'financial', 'money', 
                                      'disappointed', 'unhappy', 'poor', 'bad', 'worst', 'terrible', 'horrible',
                                      'pain', 'hurt', 'injury', 'problem', 'issue', 'dissatisfied', 'frustrat',
                                      'rude', 'unprofessional', 'late', 'cancel', 'wait', 'inconvenient'];
                
                // Neutral sentiment keywords
                const neutralWords = ['moving', 'relocated', 'schedule', 'time', 'busy', 'travel', 'distance',
                                     'far', 'changed', 'switch', 'prefer', 'different', 'other', 'work', 'job'];
                
                // Positive sentiment keywords (rare but possible)
                const positiveWords = ['achieved', 'goal', 'success', 'better', 'improved', 'healed', 'recovered'];
                
                let negativeScore = 0;
                let neutralScore = 0;
                let positiveScore = 0;
                
                negativeWords.forEach(word => {
                    if (lowerReason.includes(word)) negativeScore++;
                });
                
                neutralWords.forEach(word => {
                    if (lowerReason.includes(word)) neutralScore++;
                });
                
                positiveWords.forEach(word => {
                    if (lowerReason.includes(word)) positiveScore++;
                });
                
                // Determine overall sentiment
                if (positiveScore > negativeScore && positiveScore > neutralScore) {
                    return { sentiment: 'Positive', emoji: 'üòä', color: '#28a745' };
                } else if (negativeScore > neutralScore) {
                    return { sentiment: 'Negative', emoji: 'üòû', color: '#dc3545' };
                } else {
                    return { sentiment: 'Neutral', emoji: 'üòê', color: '#ffc107' };
                }
            }
            
            // Render Cancellation Reasons List with Sentiment
            const reasonsList = document.getElementById('cancellationReasonsList');
            if (reasonsList && sortedReasons.length > 0) {
                const top10 = sortedReasons.slice(0, 10);
                let html = '<div style="max-height: 500px; overflow-y: auto;">';
                
                top10.forEach((reason, index) => {
                    const [reasonText, count] = reason;
                    const sentiment = analyzeSentiment(reasonText);
                    const percentage = totalCancellations > 0 ? ((count / totalCancellations) * 100).toFixed(1) : 0;
                    
                    html += `
                        <div style="padding: 12px; margin-bottom: 10px; background: ${index % 2 === 0 ? '#f8f9fa' : 'white'}; border-radius: 8px; border-left: 4px solid ${sentiment.color}; cursor: pointer;" 
                             onclick="showCancellationReasonDetails('${reasonText.replace(/'/g, "\\'")}', ${count})">
                            <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 5px;">
                                <div style="flex: 1;">
                                    <span style="font-weight: bold; color: #013160;">#${index + 1}</span>
                                    <span style="font-size: 14px; color: #333; margin-left: 10px;">${reasonText.length > 50 ? reasonText.substring(0, 47) + '...' : reasonText}</span>
                                </div>
                                <div style="display: flex; align-items: center; gap: 15px;">
                                    <span style="font-size: 20px;" title="${sentiment.sentiment}">${sentiment.emoji}</span>
                                    <div style="text-align: right;">
                                        <div style="font-size: 18px; font-weight: bold; color: ${sentiment.color};">${count}</div>
                                        <div style="font-size: 11px; color: #666;">${percentage}%</div>
                                    </div>
                                </div>
                            </div>
                            <div style="margin-top: 5px;">
                                <div style="background: #e0e0e0; height: 6px; border-radius: 3px; overflow: hidden;">
                                    <div style="background: ${sentiment.color}; height: 100%; width: ${percentage}%; transition: width 0.3s ease;"></div>
                                </div>
                            </div>
                        </div>
                    `;
                });
                
                html += '</div>';
                html += '<p style="margin-top: 15px; font-size: 12px; color: #666; font-style: italic;">üí° Click on any reason to see detailed customer information and feedback</p>';
                reasonsList.innerHTML = html;
            }
            
            // Render Cancellation Reasons Pie Chart
            const reasonsPieCanvas = document.getElementById('cancellationReasonsPieChart');
            if (reasonsPieCanvas && sortedReasons.length > 0) {
                destroyChart('cancellationReasonsPie');
                const ctx = reasonsPieCanvas.getContext('2d');
                
                const colors = [
                    'rgba(244, 67, 54, 0.8)',
                    'rgba(233, 30, 99, 0.8)',
                    'rgba(156, 39, 176, 0.8)',
                    'rgba(103, 58, 183, 0.8)',
                    'rgba(63, 81, 181, 0.8)',
                    'rgba(33, 150, 243, 0.8)',
                    'rgba(3, 169, 244, 0.8)',
                    'rgba(0, 188, 212, 0.8)',
                    'rgba(0, 150, 136, 0.8)',
                    'rgba(76, 175, 80, 0.8)'
                ];
                
                allCharts.cancellationReasonsPie = new Chart(ctx, {
                    type: 'doughnut',
                    data: {
                        labels: sortedReasons.map(r => {
                            const label = r[0];
                            return label.length > 30 ? label.substring(0, 27) + '...' : label;
                        }),
                        datasets: [{
                            data: sortedReasons.map(r => r[1]),
                            backgroundColor: colors.slice(0, sortedReasons.length),
                            borderWidth: 2,
                            borderColor: '#fff'
                        }]
                    },
                    options: {
                        responsive: true,
                        maintainAspectRatio: false,
                        plugins: {
                            legend: {
                                position: 'right',
                                labels: { boxWidth: 15, padding: 10 }
                            }
                        }
                    }
                });
            }
            
            // Render Cancellations by Type Bar Chart
            const typeCanvas = document.getElementById('cancellationsByTypeChart');
            if (typeCanvas) {
                destroyChart('cancellationsByType');
                const ctx = typeCanvas.getContext('2d');
                allCharts.cancellationsByType = new Chart(ctx, {
                    type: 'bar',
                    data: {
                        labels: sortedTypes.map(t => t[0]),
                        datasets: [{
                            label: 'Cancellations',
                            data: sortedTypes.map(t => t[1]),
                            backgroundColor: 'rgba(255, 152, 0, 0.7)',
                            borderColor: 'rgba(255, 152, 0, 1)',
                            borderWidth: 2
                        }]
                    },
                    options: {
                        responsive: true,
                        maintainAspectRatio: false,
                        onClick: (event, elements) => {
                            if (elements.length > 0) {
                                const index = elements[0].index;
                                const type = sortedTypes[index][0];
                                const count = sortedTypes[index][1];
                                showCancellationTypeDetails(type, count);
                            }
                        },
                        plugins: {
                            legend: { display: false }
                        },
                        scales: {
                            y: {
                                beginAtZero: true,
                                ticks: { precision: 0 }
                            }
                        }
                    }
                });
            }
            
            // Render Cancellations by Type Pie Chart
            const typePieCanvas = document.getElementById('cancellationsByTypePieChart');
            if (typePieCanvas) {
                destroyChart('cancellationsByTypePie');
                const ctx = typePieCanvas.getContext('2d');
                
                const colors = [
                    'rgba(255, 152, 0, 0.8)',
                    'rgba(255, 193, 7, 0.8)',
                    'rgba(255, 235, 59, 0.8)',
                    'rgba(205, 220, 57, 0.8)',
                    'rgba(139, 195, 74, 0.8)',
                    'rgba(76, 175, 80, 0.8)',
                    'rgba(0, 150, 136, 0.8)',
                    'rgba(0, 188, 212, 0.8)',
                    'rgba(3, 169, 244, 0.8)',
                    'rgba(33, 150, 243, 0.8)'
                ];
                
                allCharts.cancellationsByTypePie = new Chart(ctx, {
                    type: 'pie',
                    data: {
                        labels: sortedTypes.map(t => t[0]),
                        datasets: [{
                            data: sortedTypes.map(t => t[1]),
                            backgroundColor: colors.slice(0, sortedTypes.length),
                            borderWidth: 2,
                            borderColor: '#fff'
                        }]
                    },
                    options: {
                        responsive: true,
                        maintainAspectRatio: false,
                        plugins: {
                            legend: {
                                position: 'right',
                                labels: { boxWidth: 15, padding: 10 }
                            }
                        }
                    }
                });
            }
            
            // Render Cancellations by Location Bar Chart
            const locationCanvas = document.getElementById('cancellationsByLocationChart');
            if (locationCanvas) {
                destroyChart('cancellationsByLocation');
                const ctx = locationCanvas.getContext('2d');
                allCharts.cancellationsByLocation = new Chart(ctx, {
                    type: 'bar',
                    data: {
                        labels: sortedLocations.map(l => l[0]),
                        datasets: [{
                            label: 'Cancellations',
                            data: sortedLocations.map(l => l[1]),
                            backgroundColor: 'rgba(33, 150, 243, 0.7)',
                            borderColor: 'rgba(33, 150, 243, 1)',
                            borderWidth: 2
                        }]
                    },
                    options: {
                        responsive: true,
                        maintainAspectRatio: false,
                        onClick: (event, elements) => {
                            if (elements.length > 0) {
                                const index = elements[0].index;
                                const location = sortedLocations[index][0];
                                const count = sortedLocations[index][1];
                                showCancellationLocationDetails(location, count);
                            }
                        },
                        plugins: {
                            legend: { display: false }
                        },
                        scales: {
                            y: {
                                beginAtZero: true,
                                ticks: { precision: 0 }
                            }
                        }
                    }
                });
            }
            
            // Render Cancellations by Location Pie Chart
            const locationPieCanvas = document.getElementById('cancellationsByLocationPieChart');
            if (locationPieCanvas) {
                destroyChart('cancellationsByLocationPie');
                const ctx = locationPieCanvas.getContext('2d');
                
                const colors = [
                    'rgba(33, 150, 243, 0.8)',
                    'rgba(63, 81, 181, 0.8)',
                    'rgba(103, 58, 183, 0.8)',
                    'rgba(156, 39, 176, 0.8)',
                    'rgba(233, 30, 99, 0.8)',
                    'rgba(244, 67, 54, 0.8)',
                    'rgba(255, 87, 34, 0.8)',
                    'rgba(255, 152, 0, 0.8)',
                    'rgba(255, 193, 7, 0.8)',
                    'rgba(205, 220, 57, 0.8)'
                ];
                
                allCharts.cancellationsByLocationPie = new Chart(ctx, {
                    type: 'doughnut',
                    data: {
                        labels: sortedLocations.map(l => l[0]),
                        datasets: [{
                            data: sortedLocations.map(l => l[1]),
                            backgroundColor: colors.slice(0, sortedLocations.length),
                            borderWidth: 2,
                            borderColor: '#fff'
                        }]
                    },
                    options: {
                        responsive: true,
                        maintainAspectRatio: false,
                        plugins: {
                            legend: {
                                position: 'right',
                                labels: { boxWidth: 15, padding: 10 }
                            }
                        }
                    }
                });
            }
            
            // Render Cancellation Rate by Month Chart
            const rateCanvas = document.getElementById('cancellationRateChart');
            if (rateCanvas && Object.keys(cancellationRateByMonth).length > 0) {
                destroyChart('cancellationRate');
                const ctx = rateCanvas.getContext('2d');
                const sortedRateMonths = Object.keys(cancellationRateByMonth).sort();
                allCharts.cancellationRate = new Chart(ctx, {
                    type: 'line',
                    data: {
                        labels: sortedRateMonths.map(m => {
                            const [year, month] = m.split('-');
                            const date = new Date(year, parseInt(month) - 1);
                            return date.toLocaleDateString('en-US', { month: 'short', year: 'numeric' });
                        }),
                        datasets: [{
                            label: 'Churn Rate %',
                            data: sortedRateMonths.map(m => parseFloat(cancellationRateByMonth[m])),
                            borderColor: 'rgba(255, 152, 0, 1)',
                            backgroundColor: 'rgba(255, 152, 0, 0.1)',
                            fill: true,
                            tension: 0.4,
                            borderWidth: 3
                        }]
                    },
                    options: {
                        responsive: true,
                        maintainAspectRatio: false,
                        plugins: {
                            legend: { display: false }
                        },
                        scales: {
                            y: {
                                beginAtZero: true,
                                ticks: { callback: value => value + '%' }
                            }
                        }
                    }
                });
            }
            
            // Render Cancellations by Day of Week Chart
            const dayCanvas = document.getElementById('cancellationsByDayChart');
            if (dayCanvas) {
                destroyChart('cancellationsByDay');
                const ctx = dayCanvas.getContext('2d');
                const dayOrder = ['Monday', 'Tuesday', 'Wednesday', 'Thursday', 'Friday', 'Saturday', 'Sunday'];
                allCharts.cancellationsByDay = new Chart(ctx, {
                    type: 'bar',
                    data: {
                        labels: dayOrder,
                        datasets: [{
                            label: 'Cancellations',
                            data: dayOrder.map(day => cancellationsByDayOfWeek[day]),
                            backgroundColor: 'rgba(156, 39, 176, 0.7)',
                            borderColor: 'rgba(156, 39, 176, 1)',
                            borderWidth: 2
                        }]
                    },
                    options: {
                        responsive: true,
                        maintainAspectRatio: false,
                        plugins: {
                            legend: { display: false }
                        },
                        scales: {
                            y: {
                                beginAtZero: true,
                                ticks: { precision: 0 }
                            }
                        }
                    }
                });
            }
            
            // Render Daily Activity Line Chart
            const dailyLineCanvas = document.getElementById('cancellationsDailyLineChart');
            if (dailyLineCanvas) {
                destroyChart('cancellationsDailyLine');
                const ctx = dailyLineCanvas.getContext('2d');
                allCharts.cancellationsDailyLine = new Chart(ctx, {
                    type: 'line',
                    data: {
                        labels: sortedDates.map(d => new Date(d).toLocaleDateString('en-US', { month: 'short', day: 'numeric' })),
                        datasets: [{
                            label: 'Daily Cancellations',
                            data: sortedDates.map(d => dailyCancellations[d]),
                            borderColor: 'rgba(33, 150, 243, 1)',
                            backgroundColor: 'rgba(33, 150, 243, 0.1)',
                            fill: true,
                            tension: 0.3,
                            borderWidth: 2
                        }]
                    },
                    options: {
                        responsive: true,
                        maintainAspectRatio: false,
                        plugins: {
                            legend: { display: false }
                        },
                        scales: {
                            y: {
                                beginAtZero: true,
                                ticks: { precision: 0 }
                            }
                        }
                    }
                });
            }
            
            // Render Feedback Rate Chart
            const feedbackCanvas = document.getElementById('feedbackRateChart');
            if (feedbackCanvas) {
                destroyChart('feedbackRate');
                const ctx = feedbackCanvas.getContext('2d');
                allCharts.feedbackRate = new Chart(ctx, {
                    type: 'doughnut',
                    data: {
                        labels: ['With Reason', 'No Reason', 'With Improvements', 'No Improvements'],
                        datasets: [{
                            data: [withReasons, totalCancellations - withReasons, withImprovements, totalCancellations - withImprovements],
                            backgroundColor: [
                                'rgba(76, 175, 80, 0.8)',
                                'rgba(244, 67, 54, 0.8)',
                                'rgba(33, 150, 243, 0.8)',
                                'rgba(255, 152, 0, 0.8)'
                            ],
                            borderWidth: 2,
                            borderColor: '#fff'
                        }]
                    },
                    options: {
                        responsive: true,
                        maintainAspectRatio: false,
                        plugins: {
                            legend: {
                                position: 'bottom',
                                labels: { boxWidth: 15, padding: 10 }
                            }
                        }
                    }
                });
            }
            
            // Render Churn Rate by Type Chart
            const churnTypeCanvas = document.getElementById('churnRateByTypeChart');
            if (churnTypeCanvas && Object.keys(typeChurnRates).length > 0) {
                destroyChart('churnRateByType');
                const ctx = churnTypeCanvas.getContext('2d');
                const sortedChurnTypes = Object.entries(typeChurnRates)
                    .sort((a, b) => parseFloat(b[1]) - parseFloat(a[1]))
                    .slice(0, 10);
                allCharts.churnRateByType = new Chart(ctx, {
                    type: 'bar',
                    data: {
                        labels: sortedChurnTypes.map(t => t[0]),
                        datasets: [{
                            label: 'Churn Rate %',
                            data: sortedChurnTypes.map(t => parseFloat(t[1])),
                            backgroundColor: sortedChurnTypes.map(t => {
                                const rate = parseFloat(t[1]);
                                if (rate > 20) return 'rgba(244, 67, 54, 0.7)';
                                if (rate >= 10) return 'rgba(255, 152, 0, 0.7)';
                                return 'rgba(76, 175, 80, 0.7)';
                            }),
                            borderColor: sortedChurnTypes.map(t => {
                                const rate = parseFloat(t[1]);
                                if (rate > 20) return 'rgba(244, 67, 54, 1)';
                                if (rate >= 10) return 'rgba(255, 152, 0, 1)';
                                return 'rgba(76, 175, 80, 1)';
                            }),
                            borderWidth: 2
                        }]
                    },
                    options: {
                        responsive: true,
                        maintainAspectRatio: false,
                        indexAxis: 'y',
                        plugins: {
                            legend: { display: false }
                        },
                        scales: {
                            x: {
                                beginAtZero: true,
                                ticks: { callback: value => value + '%' }
                            }
                        }
                    }
                });
            }
            
            // Render Churn Rate by Location Chart
            const churnLocCanvas = document.getElementById('churnRateByLocationChart');
            if (churnLocCanvas && Object.keys(locationChurnRates).length > 0) {
                destroyChart('churnRateByLocation');
                const ctx = churnLocCanvas.getContext('2d');
                const sortedChurnLocs = Object.entries(locationChurnRates)
                    .sort((a, b) => parseFloat(b[1]) - parseFloat(a[1]))
                    .slice(0, 10);
                allCharts.churnRateByLocation = new Chart(ctx, {
                    type: 'bar',
                    data: {
                        labels: sortedChurnLocs.map(l => l[0]),
                        datasets: [{
                            label: 'Churn Rate %',
                            data: sortedChurnLocs.map(l => parseFloat(l[1])),
                            backgroundColor: 'rgba(63, 81, 181, 0.7)',
                            borderColor: 'rgba(63, 81, 181, 1)',
                            borderWidth: 2
                        }]
                    },
                    options: {
                        responsive: true,
                        maintainAspectRatio: false,
                        plugins: {
                            legend: { display: false }
                        },
                        scales: {
                            y: {
                                beginAtZero: true,
                                ticks: { callback: value => value + '%' }
                            }
                        }
                    }
                });
            }
            
            // Render Sales vs Cancellations Chart (if sales data available)
            const salesVsCanvas = document.getElementById('salesVsCancellationsChart');
            if (salesVsCanvas && membershipsData && membershipsData.length > 0) {
                destroyChart('salesVsCancellations');
                const ctx = salesVsCanvas.getContext('2d');
                
                // Calculate sales by month
                const salesByMonth = {};
                membershipsData.forEach(m => {
                    const dateStr = m['Bought Date/Time (GMT)'];
                    if (dateStr) {
                        const date = new Date(dateStr);
                        if (!isNaN(date.getTime())) {
                            const monthKey = `${date.getFullYear()}-${String(date.getMonth() + 1).padStart(2, '0')}`;
                            if (!salesByMonth[monthKey]) salesByMonth[monthKey] = 0;
                            salesByMonth[monthKey]++;
                        }
                    }
                });
                
                const allMonths = [...new Set([...Object.keys(salesByMonth), ...sortedMonths])].sort();
                
                allCharts.salesVsCancellations = new Chart(ctx, {
                    type: 'line',
                    data: {
                        labels: allMonths.map(m => {
                            const [year, month] = m.split('-');
                            const date = new Date(year, parseInt(month) - 1);
                            return date.toLocaleDateString('en-US', { month: 'short', year: 'numeric' });
                        }),
                        datasets: [
                            {
                                label: 'New Sales',
                                data: allMonths.map(m => salesByMonth[m] || 0),
                                borderColor: 'rgba(76, 175, 80, 1)',
                                backgroundColor: 'rgba(76, 175, 80, 0.1)',
                                fill: false,
                                tension: 0.4,
                                borderWidth: 3
                            },
                            {
                                label: 'Cancellations',
                                data: allMonths.map(m => cancellationsByMonth[m] || 0),
                                borderColor: 'rgba(244, 67, 54, 1)',
                                backgroundColor: 'rgba(244, 67, 54, 0.1)',
                                fill: false,
                                tension: 0.4,
                                borderWidth: 3
                            }
                        ]
                    },
                    options: {
                        responsive: true,
                        maintainAspectRatio: false,
                        plugins: {
                            legend: { display: true, position: 'top' }
                        },
                        scales: {
                            y: {
                                beginAtZero: true,
                                ticks: { precision: 0 }
                            }
                        }
                    }
                });
            }
            
            // Render Net Growth Chart
            const netGrowthCanvas = document.getElementById('netGrowthChart');
            if (netGrowthCanvas && membershipsData && membershipsData.length > 0) {
                destroyChart('netGrowth');
                const ctx = netGrowthCanvas.getContext('2d');
                
                // Calculate sales by month
                const salesByMonth = {};
                membershipsData.forEach(m => {
                    const dateStr = m['Bought Date/Time (GMT)'];
                    if (dateStr) {
                        const date = new Date(dateStr);
                        if (!isNaN(date.getTime())) {
                            const monthKey = `${date.getFullYear()}-${String(date.getMonth() + 1).padStart(2, '0')}`;
                            if (!salesByMonth[monthKey]) salesByMonth[monthKey] = 0;
                            salesByMonth[monthKey]++;
                        }
                    }
                });
                
                const allMonths = [...new Set([...Object.keys(salesByMonth), ...sortedMonths])].sort();
                const netGrowth = allMonths.map(m => (salesByMonth[m] || 0) - (cancellationsByMonth[m] || 0));
                
                allCharts.netGrowth = new Chart(ctx, {
                    type: 'bar',
                    data: {
                        labels: allMonths.map(m => {
                            const [year, month] = m.split('-');
                            const date = new Date(year, parseInt(month) - 1);
                            return date.toLocaleDateString('en-US', { month: 'short', year: 'numeric' });
                        }),
                        datasets: [{
                            label: 'Net Membership Growth',
                            data: netGrowth,
                            backgroundColor: netGrowth.map(n => n >= 0 ? 'rgba(76, 175, 80, 0.7)' : 'rgba(244, 67, 54, 0.7)'),
                            borderColor: netGrowth.map(n => n >= 0 ? 'rgba(76, 175, 80, 1)' : 'rgba(244, 67, 54, 1)'),
                            borderWidth: 2
                        }]
                    },
                    options: {
                        responsive: true,
                        maintainAspectRatio: false,
                        plugins: {
                            legend: { display: false }
                        },
                        scales: {
                            y: {
                                ticks: { precision: 0 }
                            }
                        }
                    }
                });
            }
            
            // Render Risk Matrix Chart
            const riskCanvas = document.getElementById('riskMatrixChart');
            if (riskCanvas && Object.keys(typeChurnRates).length > 0) {
                destroyChart('riskMatrix');
                const ctx = riskCanvas.getContext('2d');
                
                const bubbleData = Object.entries(typeChurnRates).map(([type, rate]) => ({
                    x: cancellationsByType[type] || 0,
                    y: parseFloat(rate),
                    r: Math.sqrt((cancellationsByType[type] || 0) * 2),
                    label: type
                }));
                
                allCharts.riskMatrix = new Chart(ctx, {
                    type: 'bubble',
                    data: {
                        datasets: [{
                            label: 'Membership Types',
                            data: bubbleData,
                            backgroundColor: bubbleData.map(d => {
                                if (d.y > 20) return 'rgba(244, 67, 54, 0.6)';
                                if (d.y >= 10) return 'rgba(255, 152, 0, 0.6)';
                                return 'rgba(76, 175, 80, 0.6)';
                            }),
                            borderColor: bubbleData.map(d => {
                                if (d.y > 20) return 'rgba(244, 67, 54, 1)';
                                if (d.y >= 10) return 'rgba(255, 152, 0, 1)';
                                return 'rgba(76, 175, 80, 1)';
                            }),
                            borderWidth: 2
                        }]
                    },
                    options: {
                        responsive: true,
                        maintainAspectRatio: false,
                        plugins: {
                            legend: { display: false },
                            tooltip: {
                                callbacks: {
                                    label: (context) => {
                                        const point = bubbleData[context.dataIndex];
                                        return `${point.label}: ${point.x} cancellations (${point.y}% churn)`;
                                    }
                                }
                            }
                        },
                        scales: {
                            x: {
                                title: { display: true, text: 'Number of Cancellations' },
                                beginAtZero: true
                            },
                            y: {
                                title: { display: true, text: 'Churn Rate %' },
                                beginAtZero: true,
                                ticks: { callback: value => value + '%' }
                            }
                        }
                    }
                });
            }
            
            // Render Cancellation Velocity Chart
            const velocityCanvas = document.getElementById('cancellationVelocityChart');
            if (velocityCanvas && sortedMonths.length > 0) {
                destroyChart('cancellationVelocity');
                const ctx = velocityCanvas.getContext('2d');
                
                // Calculate 3-month moving average (or use actual data if less than 3 months)
                const movingAvg = sortedMonths.map((month, idx) => {
                    if (sortedMonths.length < 3 || idx < 2) {
                        // If we don't have enough data for moving average, just use the actual value
                        return cancellationsByMonth[month];
                    }
                    const sum = cancellationsByMonth[sortedMonths[idx]] + 
                               cancellationsByMonth[sortedMonths[idx-1]] + 
                               cancellationsByMonth[sortedMonths[idx-2]];
                    return sum / 3;
                });
                
                allCharts.cancellationVelocity = new Chart(ctx, {
                    type: 'line',
                    data: {
                        labels: sortedMonths.map(m => {
                            const [year, month] = m.split('-');
                            const date = new Date(year, parseInt(month) - 1);
                            return date.toLocaleDateString('en-US', { month: 'short', year: 'numeric' });
                        }),
                        datasets: [
                            {
                                label: 'Actual Cancellations',
                                data: sortedMonths.map(m => cancellationsByMonth[m]),
                                borderColor: 'rgba(244, 67, 54, 0.8)',
                                backgroundColor: 'rgba(244, 67, 54, 0.1)',
                                fill: false,
                                tension: 0.1,
                                borderWidth: 2,
                                pointRadius: 4,
                                pointHoverRadius: 6
                            },
                            ...(sortedMonths.length >= 3 ? [{
                                label: '3-Month Moving Avg',
                                data: movingAvg,
                                borderColor: 'rgba(33, 150, 243, 1)',
                                backgroundColor: 'rgba(33, 150, 243, 0.1)',
                                fill: false,
                                tension: 0.4,
                                borderWidth: 3,
                                pointRadius: 0
                            }] : [])
                        ]
                    },
                    options: {
                        responsive: true,
                        maintainAspectRatio: false,
                        plugins: {
                            legend: { 
                                display: true, 
                                position: 'top'
                            },
                            tooltip: {
                                callbacks: {
                                    label: function(context) {
                                        return context.dataset.label + ': ' + context.parsed.y.toFixed(1);
                                    }
                                }
                            }
                        },
                        scales: {
                            y: {
                                beginAtZero: true,
                                ticks: { precision: 0 }
                            }
                        }
                    }
                });
            }
            
            console.log('Cancellations tab rendering complete!');
        }
        
        // Show Cancellation Reason Details Modal
        function showCancellationReasonDetails(reason, count) {
            const cancellationsWithReason = filteredCancellations.filter(c => {
                const cancelReason = (c['Reason'] || '').trim();
                const reasonKey = cancelReason.split('>')[0].trim() || cancelReason;
                return reasonKey === reason;
            });
            
            // Get detailed info with membership data
            const detailedCancellations = cancellationsWithReason.map(c => {
                const membershipId = c['Membership ID'];
                let membershipValue = 0;
                let membershipType = c['Membership'] || 'Unknown';
                
                if (membershipId && membershipsData) {
                    const matchingMembership = membershipsData.find(m => m['Membership ID'] === membershipId);
                    if (matchingMembership) {
                        membershipValue = parseFloat(matchingMembership['Paid Amount']) || 0;
                    }
                }
                
                // Try different possible field names for customer name
                const firstName = c['First name'] || c['First Name'] || c['Customer First Name'] || '';
                const lastName = c['Last name'] || c['Last Name'] || c['Customer Last Name'] || '';
                const fullName = c['Customer Name'] || c['Name'] || '';
                const customerName = fullName || `${firstName} ${lastName}`.trim();
                
                return {
                    customerName: customerName || 'Unknown',
                    email: c['Email'] || c['E-mail'] || c['Customer Email'] || 'N/A',
                    membership: membershipType,
                    value: membershipValue,
                    cancelledAt: c['Cancelled at'] || 'N/A',
                    location: c['Home location'] || 'Unknown',
                    fullReason: c['Reason'] || reason,
                    improvements: c['Possible improvements'] || 'None provided'
                };
            });
            
            // Sort by value descending
            detailedCancellations.sort((a, b) => b.value - a.value);
            
            const totalValue = detailedCancellations.reduce((sum, c) => sum + c.value, 0);
            const avgValue = totalValue / count;
            
            const sentiment = analyzeSentiment(reason);
            
            let content = `
                <div class="modal-highlight" style="border-left: 4px solid ${sentiment.color};">
                    <div style="display: flex; justify-content: space-between; align-items: start; margin-bottom: 10px;">
                        <div style="flex: 1;">
                            <strong>Reason:</strong> ${reason}<br>
                            <strong>Sentiment:</strong> ${sentiment.emoji} ${sentiment.sentiment}
                        </div>
                        <div style="text-align: right;">
                            <div style="font-size: 24px; font-weight: bold; color: ${sentiment.color};">${count}</div>
                            <div style="font-size: 12px; color: #666;">cancellations</div>
                        </div>
                    </div>
                    <strong>Total Lost Revenue:</strong> ${formatCurrency(totalValue)}<br>
                    <strong>Average Per Cancellation:</strong> ${formatCurrency(avgValue)}
                </div>
                
                <div class="modal-section">
                    <h4>Cancelled Customers (${count})</h4>
                    <table class="modal-table">
                        <thead>
                            <tr>
                                <th>Customer</th>
                                <th>Membership</th>
                                <th>Value</th>
                                <th>Location</th>
                                <th>Cancelled</th>
                                <th>Feedback</th>
                            </tr>
                        </thead>
                        <tbody>
                            ${detailedCancellations.map(c => `
                                <tr>
                                    <td>
                                        <strong>${c.customerName || 'Unknown'}</strong><br>
                                        <span style="font-size: 11px; color: #666;">${c.email}</span>
                                    </td>
                                    <td>${c.membership}</td>
                                    <td><strong>${formatCurrency(c.value)}</strong></td>
                                    <td>${c.location}</td>
                                    <td style="font-size: 12px;">${c.cancelledAt}</td>
                                    <td style="font-size: 12px; max-width: 200px;">${c.improvements.substring(0, 100)}${c.improvements.length > 100 ? '...' : ''}</td>
                                </tr>
                            `).join('')}
                        </tbody>
                    </table>
                </div>
            `;
            
            showModal(`Cancellation Reason: ${reason}`, content);
        }
        
        // Show Cancellation Type Details Modal
        function showCancellationTypeDetails(type, count) {
            const cancellationsOfType = filteredCancellations.filter(c => {
                const membershipType = c['Membership'] || 'Unknown';
                return membershipType === type;
            });
            
            const detailedCancellations = cancellationsOfType.map(c => {
                let membershipValue = 0;
                
                // Match by Customer Email instead of Membership ID
                const customerEmail = (c['Email'] || c['E-mail'] || c['Customer Email'] || '').toLowerCase().trim();
                if (customerEmail && membershipsData) {
                    const matchingMemberships = membershipsData.filter(m => 
                        (m['Customer Email'] || '').toLowerCase().trim() === customerEmail
                    );
                    if (matchingMemberships.length > 0) {
                        // Sort by date and get most recent
                        const sortedMemberships = matchingMemberships.sort((a, b) => {
                            const dateA = a['Bought Date/Time (GMT)'] ? new Date(a['Bought Date/Time (GMT)']) : new Date(0);
                            const dateB = b['Bought Date/Time (GMT)'] ? new Date(b['Bought Date/Time (GMT)']) : new Date(0);
                            return dateB - dateA;
                        });
                        // Use Paid Amount as monthly value
                        membershipValue = parseFloat(sortedMemberships[0]['Paid Amount']) || 0;
                    }
                }
                
                // Try different possible field names for customer name
                const firstName = c['First name'] || c['First Name'] || c['Customer First Name'] || '';
                const lastName = c['Last name'] || c['Last Name'] || c['Customer Last Name'] || '';
                const fullName = c['Customer Name'] || c['Name'] || '';
                const customerName = fullName || `${firstName} ${lastName}`.trim();
                
                return {
                    customerName: customerName || 'Unknown',
                    email: c['Email'] || c['E-mail'] || c['Customer Email'] || 'N/A',
                    value: membershipValue,
                    cancelledAt: c['Cancelled at'] || 'N/A',
                    location: c['Home location'] || 'Unknown',
                    reason: (c['Reason'] || '').split('>')[0].trim() || 'Not provided'
                };
            });
            
            detailedCancellations.sort((a, b) => b.value - a.value);
            
            const totalValue = detailedCancellations.reduce((sum, c) => sum + c.value, 0);
            
            let content = `
                <div class="modal-highlight">
                    <strong>Membership Type:</strong> ${type}<br>
                    <strong>Total Cancellations:</strong> ${count}<br>
                    <strong>Total Lost Revenue:</strong> ${formatCurrency(totalValue)}
                </div>
                
                <div class="modal-section">
                    <h4>Cancelled Members (${count})</h4>
                    <table class="modal-table">
                        <thead>
                            <tr>
                                <th>Customer</th>
                                <th>Value</th>
                                <th>Location</th>
                                <th>Cancelled</th>
                                <th>Reason</th>
                            </tr>
                        </thead>
                        <tbody>
                            ${detailedCancellations.map(c => `
                                <tr>
                                    <td>
                                        <strong>${c.customerName || 'Unknown'}</strong><br>
                                        <span style="font-size: 11px; color: #666;">${c.email}</span>
                                    </td>
                                    <td><strong>${formatCurrency(c.value)}</strong></td>
                                    <td>${c.location}</td>
                                    <td style="font-size: 12px;">${c.cancelledAt}</td>
                                    <td style="font-size: 12px;">${c.reason}</td>
                                </tr>
                            `).join('')}
                        </tbody>
                    </table>
                </div>
            `;
            
            showModal(`Cancellations: ${type}`, content);
        }
        
        // Show Cancellation Location Details Modal
        function showCancellationLocationDetails(location, count) {
            const cancellationsAtLocation = filteredCancellations.filter(c => {
                const loc = c['Home location'] || 'Unknown';
                return loc === location;
            });
            
            const detailedCancellations = cancellationsAtLocation.map(c => {
                let membershipValue = 0;
                
                // Match by Customer Email instead of Membership ID
                const customerEmail = (c['Email'] || c['E-mail'] || c['Customer Email'] || '').toLowerCase().trim();
                if (customerEmail && membershipsData) {
                    const matchingMemberships = membershipsData.filter(m => 
                        (m['Customer Email'] || '').toLowerCase().trim() === customerEmail
                    );
                    if (matchingMemberships.length > 0) {
                        // Sort by date and get most recent
                        const sortedMemberships = matchingMemberships.sort((a, b) => {
                            const dateA = a['Bought Date/Time (GMT)'] ? new Date(a['Bought Date/Time (GMT)']) : new Date(0);
                            const dateB = b['Bought Date/Time (GMT)'] ? new Date(b['Bought Date/Time (GMT)']) : new Date(0);
                            return dateB - dateA;
                        });
                        // Use Paid Amount as monthly value
                        membershipValue = parseFloat(sortedMemberships[0]['Paid Amount']) || 0;
                    }
                }
                
                // Try different possible field names for customer name
                const firstName = c['First name'] || c['First Name'] || c['Customer First Name'] || '';
                const lastName = c['Last name'] || c['Last Name'] || c['Customer Last Name'] || '';
                const fullName = c['Customer Name'] || c['Name'] || '';
                const customerName = fullName || `${firstName} ${lastName}`.trim();
                
                return {
                    customerName: customerName || 'Unknown',
                    email: c['Email'] || c['E-mail'] || c['Customer Email'] || 'N/A',
                    membership: c['Membership'] || 'Unknown',
                    value: membershipValue,
                    cancelledAt: c['Cancelled at'] || 'N/A',
                    reason: (c['Reason'] || '').split('>')[0].trim() || 'Not provided'
                };
            });
            
            detailedCancellations.sort((a, b) => b.value - a.value);
            
            const totalValue = detailedCancellations.reduce((sum, c) => sum + c.value, 0);
            
            let content = `
                <div class="modal-highlight">
                    <strong>Location:</strong> ${location}<br>
                    <strong>Total Cancellations:</strong> ${count}<br>
                    <strong>Total Lost Revenue:</strong> ${formatCurrency(totalValue)}
                </div>
                
                <div class="modal-section">
                    <h4>Cancelled Members at ${location} (${count})</h4>
                    <table class="modal-table">
                        <thead>
                            <tr>
                                <th>Customer</th>
                                <th>Membership</th>
                                <th>Value</th>
                                <th>Cancelled</th>
                                <th>Reason</th>
                            </tr>
                        </thead>
                        <tbody>
                            ${detailedCancellations.map(c => `
                                <tr>
                                    <td>
                                        <strong>${c.customerName || 'Unknown'}</strong><br>
                                        <span style="font-size: 11px; color: #666;">${c.email}</span>
                                    </td>
                                    <td>${c.membership}</td>
                                    <td><strong>${formatCurrency(c.value)}</strong></td>
                                    <td style="font-size: 12px;">${c.cancelledAt}</td>
                                    <td style="font-size: 12px;">${c.reason.substring(0, 40)}${c.reason.length > 40 ? '...' : ''}</td>
                                </tr>
                            `).join('')}
                        </tbody>
                    </table>
                </div>
            `;
            
            showModal(`Cancellations: ${location}`, content);
        }
        
        // Show Cancellation Month Details Modal
        function showCancellationMonthDetails(monthKey, count) {
            const [year, month] = monthKey.split('-');
            const monthName = new Date(year, parseInt(month) - 1).toLocaleDateString('en-US', { month: 'long', year: 'numeric' });
            
            const cancellationsInMonth = filteredCancellations.filter(c => {
                const cancelledAt = c['Cancelled at'];
                if (cancelledAt) {
                    const dateParts = cancelledAt.split(',')[0];
                    const cancelDate = new Date(dateParts);
                    if (!isNaN(cancelDate.getTime())) {
                        const cancelMonthKey = `${cancelDate.getFullYear()}-${String(cancelDate.getMonth() + 1).padStart(2, '0')}`;
                        return cancelMonthKey === monthKey;
                    }
                }
                return false;
            });
            
            const detailedCancellations = cancellationsInMonth.map(c => {
                let membershipValue = 0;
                
                // Match by Customer Email instead of Membership ID
                const customerEmail = (c['Email'] || c['E-mail'] || c['Customer Email'] || '').toLowerCase().trim();
                if (customerEmail && membershipsData) {
                    const matchingMemberships = membershipsData.filter(m => 
                        (m['Customer Email'] || '').toLowerCase().trim() === customerEmail
                    );
                    if (matchingMemberships.length > 0) {
                        // Sort by date and get most recent
                        const sortedMemberships = matchingMemberships.sort((a, b) => {
                            const dateA = a['Bought Date/Time (GMT)'] ? new Date(a['Bought Date/Time (GMT)']) : new Date(0);
                            const dateB = b['Bought Date/Time (GMT)'] ? new Date(b['Bought Date/Time (GMT)']) : new Date(0);
                            return dateB - dateA;
                        });
                        // Use Paid Amount as monthly value
                        membershipValue = parseFloat(sortedMemberships[0]['Paid Amount']) || 0;
                    }
                }
                
                // Try different possible field names for customer name
                const firstName = c['First name'] || c['First Name'] || c['Customer First Name'] || '';
                const lastName = c['Last name'] || c['Last Name'] || c['Customer Last Name'] || '';
                const fullName = c['Customer Name'] || c['Name'] || '';
                const customerName = fullName || `${firstName} ${lastName}`.trim();
                
                return {
                    customerName: customerName || 'Unknown',
                    email: c['Email'] || c['E-mail'] || c['Customer Email'] || 'N/A',
                    membership: c['Membership'] || 'Unknown',
                    value: membershipValue,
                    cancelledAt: c['Cancelled at'] || 'N/A',
                    location: c['Home location'] || 'Unknown',
                    reason: (c['Reason'] || '').split('>')[0].trim() || 'Not provided'
                };
            });
            
            detailedCancellations.sort((a, b) => b.value - a.value);
            
            const totalValue = detailedCancellations.reduce((sum, c) => sum + c.value, 0);
            
            let content = `
                <div class="modal-highlight">
                    <strong>Month:</strong> ${monthName}<br>
                    <strong>Total Cancellations:</strong> ${count}<br>
                    <strong>Total Lost Revenue:</strong> ${formatCurrency(totalValue)}
                </div>
                
                <div class="modal-section">
                    <h4>Cancellations in ${monthName} (${count})</h4>
                    <table class="modal-table">
                        <thead>
                            <tr>
                                <th>Customer</th>
                                <th>Membership</th>
                                <th>Value</th>
                                <th>Location</th>
                                <th>Cancelled</th>
                                <th>Reason</th>
                            </tr>
                        </thead>
                        <tbody>
                            ${detailedCancellations.map(c => `
                                <tr>
                                    <td>
                                        <strong>${c.customerName || 'Unknown'}</strong><br>
                                        <span style="font-size: 11px; color: #666;">${c.email}</span>
                                    </td>
                                    <td>${c.membership}</td>
                                    <td><strong>${formatCurrency(c.value)}</strong></td>
                                    <td>${c.location}</td>
                                    <td style="font-size: 12px;">${c.cancelledAt}</td>
                                    <td style="font-size: 12px;">${c.reason.substring(0, 30)}${c.reason.length > 30 ? '...' : ''}</td>
                                </tr>
                            `).join('')}
                        </tbody>
                    </table>
                </div>
            `;
            
            showModal(`Cancellations: ${monthName}`, content);
        }
        
        // CLIENT JOURNEY VISUALIZATION TAB
        function renderJourneyTab() {
            // Check if leads data is available
            if (!leadsData || leadsData.length === 0) {
                document.getElementById('journey').innerHTML = `
                    <div class="alert info">
                        <h4>üöÄ Client Journey Visualization</h4>
                        <p>Upload the <strong>Leads & Customers CSV</strong> file to unlock the journey visualization showing how clients progress from leads to loyal customers.</p>
                    </div>
                `;
                return;
            }
            
            const data = filteredAppointments;
            // Use global filteredLeads
            
            // Calculate journey stages (using same logic as Funnel tab)
            const totalPeople = filteredLeads.length;
            const customers = filteredLeads.filter(row => row.Type === 'Customer').length;
            const leads = totalPeople - customers;
            
            // Intro offers (same logic as Funnel tab)
            const hadIntroOffer = filteredLeads.filter(row => {
                const firstPurchase = row['First purchase'] || '';
                return firstPurchase && firstPurchase !== 'N/A' && isIntroOffer(firstPurchase);
            }).length;
            
            // Made first paid purchase
            const madePurchase = filteredLeads.filter(row => {
                const firstPurchase = row['First purchase'] || '';
                return firstPurchase && firstPurchase !== 'N/A' && !isIntroOffer(firstPurchase);
            }).length;
            
            // Repeat customers (2+ visits)
            const clientVisits = {};
            data.forEach(row => {
                const email = (row['Customer Email'] || '').toLowerCase().trim();
                if (email) {
                    clientVisits[email] = (clientVisits[email] || 0) + 1;
                }
            });
            const repeatCustomers = Object.values(clientVisits).filter(count => count >= 2).length;
            
            // Loyal customers (5+ visits)
            const loyalCustomers = Object.values(clientVisits).filter(count => count >= 5).length;
            
            // Calculate conversion rates (with safety checks for division by zero)
            const leadToCustomer = totalPeople > 0 ? (customers / totalPeople * 100) : 0;
            const customerToIntro = customers > 0 ? (hadIntroOffer / customers * 100) : 0;
            const introToPurchase = hadIntroOffer > 0 ? (madePurchase / hadIntroOffer * 100) : 0;
            const purchaseToRepeat = madePurchase > 0 ? (repeatCustomers / madePurchase * 100) : 0;
            const repeatToLoyal = repeatCustomers > 0 ? (loyalCustomers / repeatCustomers * 100) : 0;
            
            // Calculate drop-offs (with safety checks)
            const dropLeadToCustomer = totalPeople > 0 ? ((totalPeople - customers) / totalPeople * 100).toFixed(0) : '0';
            const dropCustomerToIntro = customers > 0 ? ((customers - hadIntroOffer) / customers * 100).toFixed(0) : '0';
            const dropIntroToPurchase = hadIntroOffer > 0 ? ((hadIntroOffer - madePurchase) / hadIntroOffer * 100).toFixed(0) : '0';
            const dropPurchaseToRepeat = madePurchase > 0 ? ((madePurchase - repeatCustomers) / madePurchase * 100).toFixed(0) : '0';
            const dropRepeatToLoyal = repeatCustomers > 0 ? ((repeatCustomers - loyalCustomers) / repeatCustomers * 100).toFixed(0) : '0';
            
            let html = `
                <div class="alert info">
                    <h3>üöÄ Client Journey Visualization</h3>
                    <p>Track how clients progress through your sales funnel, from first contact to loyal customer. Click any stage for details.</p>
                </div>
                
                <div class="journey-flow">
                    <div class="journey-stage" onclick="showJourneyDetails('leads', ${totalPeople})">
                        <div class="journey-stage-icon">üë•</div>
                        <div class="journey-stage-title">TOTAL CONTACTS</div>
                        <div class="journey-stage-count">${formatNumber(totalPeople)}<br><span class="journey-stage-percent">100%</span></div>
                    </div>
                    
                    <div class="journey-arrow">‚Üí</div>
                    
                    <div class="journey-stage" onclick="showJourneyDetails('customers', ${customers})" style="position: relative;">
                        ${dropLeadToCustomer > 0 ? `<div class="journey-dropoff">-${dropLeadToCustomer}% drop</div>` : ''}
                        <div class="journey-stage-icon">‚úÖ</div>
                        <div class="journey-stage-title">CUSTOMERS</div>
                        <div class="journey-stage-count">${formatNumber(customers)}<br><span class="journey-stage-percent">${isFinite(leadToCustomer) ? leadToCustomer.toFixed(0) : '0'}%</span></div>
                    </div>
                    
                    <div class="journey-arrow">‚Üí</div>
                    
                    <div class="journey-stage" onclick="showJourneyDetails('intro', ${hadIntroOffer})" style="position: relative;">
                        ${dropCustomerToIntro > 0 ? `<div class="journey-dropoff">-${dropCustomerToIntro}% drop</div>` : ''}
                        <div class="journey-stage-icon">üé´</div>
                        <div class="journey-stage-title">TRIED INTRO</div>
                        <div class="journey-stage-count">${formatNumber(hadIntroOffer)}<br><span class="journey-stage-percent">${isFinite(customerToIntro) ? customerToIntro.toFixed(0) : '0'}%</span></div>
                    </div>
                    
                    <div class="journey-arrow">‚Üí</div>
                    
                    <div class="journey-stage" onclick="showJourneyDetails('purchase', ${madePurchase})" style="position: relative;">
                        ${dropIntroToPurchase > 0 ? `<div class="journey-dropoff">-${dropIntroToPurchase}% drop</div>` : ''}
                        <div class="journey-stage-icon">üí≥</div>
                        <div class="journey-stage-title">FIRST PURCHASE</div>
                        <div class="journey-stage-count">${formatNumber(madePurchase)}<br><span class="journey-stage-percent">${isFinite(introToPurchase) ? introToPurchase.toFixed(0) : '0'}%</span></div>
                    </div>
                    
                    <div class="journey-arrow">‚Üí</div>
                    
                    <div class="journey-stage" onclick="showJourneyDetails('repeat', ${repeatCustomers})" style="position: relative;">
                        ${dropPurchaseToRepeat > 0 ? `<div class="journey-dropoff">-${dropPurchaseToRepeat}% drop</div>` : ''}
                        <div class="journey-stage-icon">üîÑ</div>
                        <div class="journey-stage-title">REPEAT (2+)</div>
                        <div class="journey-stage-count">${formatNumber(repeatCustomers)}<br><span class="journey-stage-percent">${isFinite(purchaseToRepeat) ? purchaseToRepeat.toFixed(0) : '0'}%</span></div>
                    </div>
                    
                    <div class="journey-arrow">‚Üí</div>
                    
                    <div class="journey-stage" onclick="showJourneyDetails('loyal', ${loyalCustomers})" style="position: relative;">
                        ${dropRepeatToLoyal > 0 ? `<div class="journey-dropoff">-${dropRepeatToLoyal}% drop</div>` : ''}
                        <div class="journey-stage-icon">üëë</div>
                        <div class="journey-stage-title">LOYAL (5+)</div>
                        <div class="journey-stage-count">${formatNumber(loyalCustomers)}<br><span class="journey-stage-percent">${isFinite(repeatToLoyal) ? repeatToLoyal.toFixed(0) : '0'}%</span></div>
                    </div>
                </div>
                
                <div class="table-container">
                    <h2>Journey Conversion Analysis</h2>
                    <table>
                        <thead>
                            <tr>
                                <th>Stage Transition</th>
                                <th>Count</th>
                                <th>Conversion Rate</th>
                                <th>Drop-off</th>
                                <th>Status</th>
                            </tr>
                        </thead>
                        <tbody>
                            <tr>
                                <td>Contacts ‚Üí Customers</td>
                                <td>${formatNumber(customers)} / ${formatNumber(totalPeople)}</td>
                                <td><strong>${totalPeople > 0 ? leadToCustomer.toFixed(1) : '0.0'}%</strong></td>
                                <td>${dropLeadToCustomer}%</td>
                                <td>${leadToCustomer >= 40 ? '‚úÖ Good' : leadToCustomer > 0 ? '‚ö†Ô∏è Needs Work' : '‚ûñ N/A'}</td>
                            </tr>
                            <tr>
                                <td>Customers ‚Üí Intro Offer</td>
                                <td>${formatNumber(hadIntroOffer)} / ${formatNumber(customers)}</td>
                                <td><strong>${customers > 0 ? customerToIntro.toFixed(1) : '0.0'}%</strong></td>
                                <td>${dropCustomerToIntro}%</td>
                                <td>${customerToIntro >= 50 ? '‚úÖ Good' : customerToIntro > 0 ? '‚ö†Ô∏è Needs Work' : '‚ûñ N/A'}</td>
                            </tr>
                            <tr>
                                <td>Intro ‚Üí First Purchase</td>
                                <td>${formatNumber(madePurchase)} / ${formatNumber(hadIntroOffer)}</td>
                                <td><strong>${hadIntroOffer > 0 ? introToPurchase.toFixed(1) : '0.0'}%</strong></td>
                                <td>${dropIntroToPurchase}%</td>
                                <td>${introToPurchase >= 30 ? '‚úÖ Good' : introToPurchase > 0 ? '‚ö†Ô∏è Needs Work' : '‚ûñ N/A'}</td>
                            </tr>
                            <tr>
                                <td>Purchase ‚Üí Repeat</td>
                                <td>${formatNumber(repeatCustomers)} / ${formatNumber(madePurchase)}</td>
                                <td><strong>${madePurchase > 0 ? purchaseToRepeat.toFixed(1) : '0.0'}%</strong></td>
                                <td>${dropPurchaseToRepeat}%</td>
                                <td>${purchaseToRepeat >= 40 ? '‚úÖ Good' : purchaseToRepeat > 0 ? '‚ö†Ô∏è Needs Work' : '‚ûñ N/A'}</td>
                            </tr>
                            <tr>
                                <td>Repeat ‚Üí Loyal</td>
                                <td>${formatNumber(loyalCustomers)} / ${formatNumber(repeatCustomers)}</td>
                                <td><strong>${repeatCustomers > 0 ? repeatToLoyal.toFixed(1) : '0.0'}%</strong></td>
                                <td>${dropRepeatToLoyal}%</td>
                                <td>${repeatToLoyal >= 30 ? '‚úÖ Good' : repeatToLoyal > 0 ? '‚ö†Ô∏è Needs Work' : '‚ûñ N/A'}</td>
                            </tr>
                        </tbody>
                    </table>
                </div>
                
                <div class="alert ${introToPurchase >= 30 ? 'success' : 'warning'}">
                    <h4>üí° Journey Optimization Recommendations</h4>
                    <ul style="margin: 10px 0 0 20px; line-height: 1.8;">
                        ${leadToCustomer < 40 ? '<li><strong>Lead Conversion:</strong> Focus on improving your lead nurturing process. Consider adding more touchpoints and personalized follow-ups.</li>' : ''}
                        ${customerToIntro < 50 ? '<li><strong>Intro Offer Adoption:</strong> Make your intro offer more visible and compelling. Consider a time-limited promotion to create urgency.</li>' : ''}
                        ${introToPurchase < 30 ? '<li><strong>Intro-to-Purchase:</strong> Your intro offer conversion needs improvement. Follow up within 24 hours of intro sessions and highlight package benefits.</li>' : ''}
                        ${purchaseToRepeat < 40 ? '<li><strong>First-to-Second Visit:</strong> This is critical! Implement immediate rebooking at checkout and send reminders within 48 hours.</li>' : ''}
                        ${repeatToLoyal < 30 ? '<li><strong>Building Loyalty:</strong> Create a loyalty program or membership for clients with 3-4 visits to incentivize reaching 5+.</li>' : ''}
                        <li><strong>Biggest Opportunity:</strong> ${Math.max(dropLeadToCustomer, dropCustomerToIntro, dropIntroToPurchase, dropPurchaseToRepeat, dropRepeatToLoyal) == dropLeadToCustomer ? 'Convert more leads to customers' : Math.max(dropCustomerToIntro, dropIntroToPurchase, dropPurchaseToRepeat, dropRepeatToLoyal) == dropCustomerToIntro ? 'Get more customers to try intro offers' : Math.max(dropIntroToPurchase, dropPurchaseToRepeat, dropRepeatToLoyal) == dropIntroToPurchase ? 'Convert intro offers to purchases' : Math.max(dropPurchaseToRepeat, dropRepeatToLoyal) == dropPurchaseToRepeat ? 'Get first-time buyers to return' : 'Build loyalty with repeat customers'}</li>
                    </ul>
                </div>
                
                <div class="metrics-grid" style="grid-template-columns: repeat(4, 1fr);">
                    <div class="metric-card">
                        <div class="metric-label">Conversion Rate</div>
                        <div class="metric-value">${(customers / totalPeople * 100).toFixed(1)}%</div>
                        <div class="metric-subtext">Lead ‚Üí Customer</div>
                    </div>
                    <div class="metric-card">
                        <div class="metric-label">Intro Offer Rate</div>
                        <div class="metric-value">${(hadIntroOffer / totalPeople * 100).toFixed(1)}%</div>
                        <div class="metric-subtext">Tried introductory offer</div>
                    </div>
                    <div class="metric-card">
                        <div class="metric-label">Purchase Rate</div>
                        <div class="metric-value">${(madePurchase / totalPeople * 100).toFixed(1)}%</div>
                        <div class="metric-subtext">Made actual purchase</div>
                    </div>
                    <div class="metric-card">
                        <div class="metric-label">Revenue Rate</div>
                        <div class="metric-value">${(() => {
                            const ltvs = leadsData.map(row => parseFloat(row.LTV || 0));
                            const hasRevenue = ltvs.filter(ltv => ltv > 0).length;
                            return (hasRevenue / totalPeople * 100).toFixed(1);
                        })()}%</div>
                        <div class="metric-subtext">Generating LTV</div>
                    </div>
                </div>
            `;
            
            document.getElementById('journey').innerHTML = html;
        }
        
        
        // AI RECOMMENDATIONS ENGINE
        function generateSmartRecommendations() {
            const data = filteredAppointments;
            // Use global leadsData directly
            const recommendations = [];
            
            // Calculate key metrics
            const totalRevenue = data.reduce((sum, row) => sum + parseFloat(row.Revenue || 0), 0);
            const totalPayout = data.reduce((sum, row) => sum + parseFloat(row['Total Payout'] || 0), 0);
            const profit = totalRevenue - totalPayout;
            const profitMargin = totalRevenue > 0 ? (profit / totalRevenue * 100) : 0;
            
            const clientVisits = {};
            data.forEach(row => {
                const email = (row['Customer Email'] || '').toLowerCase().trim();
                if (email) {
                    clientVisits[email] = (clientVisits[email] || 0) + 1;
                }
            });
            
            const uniqueClients = Object.keys(clientVisits).length;
            const returningClients = Object.values(clientVisits).filter(count => count > 1).length;
            const retentionRate = uniqueClients > 0 ? (returningClients / uniqueClients * 100) : 0;
            const avgRevPerClient = uniqueClients > 0 ? totalRevenue / uniqueClients : 0;
            
            // RECOMMENDATION 1: Low Retention Rate
            if (retentionRate < 40) {
                recommendations.push({
                    priority: 'high',
                    title: 'Critical: Improve Client Retention',
                    description: `Your retention rate is ${retentionRate.toFixed(0)}%, which is below the industry target of 50%+. You're losing ${100 - retentionRate.toFixed(0)}% of clients after their first visit.`,
                    action: 'Implement an automated follow-up sequence: 24 hours (thank you), 7 days (check-in), 14 days (special offer). Set up rebooking incentives at checkout.',
                    impact: `Increasing retention to 50% could add ${formatCurrency(avgRevPerClient * uniqueClients * 0.5)} in revenue`,
                    impactValue: avgRevPerClient * uniqueClients * 0.5
                });
            }
            
            // RECOMMENDATION 2: Low Profit Margin
            if (profitMargin < 25) {
                recommendations.push({
                    priority: 'high',
                    title: 'Optimize Profit Margins',
                    description: `Your profit margin of ${profitMargin.toFixed(1)}% is below optimal (30%+). This limits growth and reinvestment capacity.`,
                    action: 'Review practitioner payout structure, optimize scheduling to reduce idle time, and consider 5-10% price increase for premium services.',
                    impact: `Improving margin to 30% would add ${formatCurrency(totalRevenue * 0.3 - profit)} to profit`,
                    impactValue: totalRevenue * 0.3 - profit
                });
            }
            
            // RECOMMENDATION 3: At-Risk Clients
            const today = new Date();
            const avgDaysBetween = 30; // Simplified
            const atRiskCount = Object.entries(clientVisits).filter(([email, visits]) => {
                if (visits <= 1) return false;
                const lastVisit = data.filter(r => r['Customer Email']?.toLowerCase().trim() === email)
                    .map(r => parseDate(r['Appointment Date']))
                    .sort((a, b) => b - a)[0];
                if (!lastVisit) return false;
                const daysSince = (today - lastVisit) / (1000 * 60 * 60 * 24);
                return daysSince > avgDaysBetween * 1.5;
            }).length;
            
            if (atRiskCount > 0) {
                const atRiskRevenue = atRiskCount * avgRevPerClient;
                recommendations.push({
                    priority: 'high',
                    title: `Re-engage ${atRiskCount} At-Risk Clients`,
                    description: `${atRiskCount} returning clients haven't visited recently. They represent ${formatCurrency(atRiskRevenue)} in historical revenue.`,
                    action: `Launch a "We miss you" campaign with a special 20% comeback offer. Personalize messages referencing their last service.`,
                    impact: `Recovering 30% could bring back ${formatCurrency(atRiskRevenue * 0.3)}`,
                    impactValue: atRiskRevenue * 0.3
                });
            }
            
            // RECOMMENDATION 4: Package Opportunities
            const avgVisitsPerClient = uniqueClients > 0 ? data.length / uniqueClients : 0;
            if (avgVisitsPerClient < 3) {
                recommendations.push({
                    priority: 'medium',
                    title: 'Create Package Deals to Increase Visit Frequency',
                    description: `Average client visits only ${avgVisitsPerClient.toFixed(1)} times. Package deals encourage commitment and increase CLV.`,
                    action: 'Create 3-pack (10% off), 5-pack (15% off), and 10-pack (20% off) bundles. Promote as "best value" at checkout.',
                    impact: `Increasing avg visits to 4 could add ${formatCurrency((4 - avgVisitsPerClient) * uniqueClients * (totalRevenue / data.length))}`,
                    impactValue: (4 - avgVisitsPerClient) * uniqueClients * (totalRevenue / data.length)
                });
            }
            
            // RECOMMENDATION 5: Intro Offer Conversion
            if (leadsData && leadsData.length > 0) {
                const hadIntro = leadsData.filter(row => isIntroOffer(row['First purchase'] || '')).length;
                const madePurchase = leadsData.filter(row => {
                    const fp = row['First purchase'] || '';
                    return fp && fp !== 'N/A' && !isIntroOffer(fp);
                }).length;
                const introConversion = hadIntro > 0 ? (madePurchase / hadIntro * 100) : 0;
                
                if (introConversion < 30 && hadIntro > 0) {
                    recommendations.push({
                        priority: 'high',
                        title: 'Boost Intro Offer to Purchase Conversion',
                        description: `Only ${introConversion.toFixed(0)}% of intro offers convert to paid purchases. Industry best practice is 35-40%.`,
                        action: 'Follow up within 24 hours of intro sessions. Offer limited-time package deal. Train staff on conversion techniques.',
                        impact: `Improving to 35% would add ${formatNumber(hadIntro * 0.35 - madePurchase)} new paying clients`,
                        impactValue: (hadIntro * 0.35 - madePurchase) * avgRevPerClient
                    });
                }
            }
            
            // RECOMMENDATION 6: Revenue per Client
            if (avgRevPerClient < 200) {
                recommendations.push({
                    priority: 'medium',
                    title: 'Increase Average Client Value',
                    description: `Your average revenue per client is ${formatCurrency(avgRevPerClient)}. Strategic upselling could significantly boost this.`,
                    action: 'Train team on consultative selling. Recommend add-ons (extended sessions, complementary services). Create premium service tier.',
                    impact: `Increasing to ${formatCurrency(avgRevPerClient * 1.25)} would add ${formatCurrency((avgRevPerClient * 1.25 - avgRevPerClient) * uniqueClients)}`,
                    impactValue: (avgRevPerClient * 1.25 - avgRevPerClient) * uniqueClients
                });
            }
            
            // RECOMMENDATION 7: Referral Program
            const newClientsNeeded = Math.max(0, uniqueClients * 0.2); // 20% growth target
            if (newClientsNeeded > 0) {
                recommendations.push({
                    priority: 'medium',
                    title: 'Launch Referral Program for Growth',
                    description: `To achieve 20% client growth, you need ${Math.ceil(newClientsNeeded)} new clients. Referrals are the most cost-effective acquisition channel.`,
                    action: 'Offer referring client $20 credit + new client 20% off first visit. Promote via email, in-office signage, and social media.',
                    impact: `${Math.ceil(newClientsNeeded)} new clients could add ${formatCurrency(newClientsNeeded * avgRevPerClient)}`,
                    impactValue: newClientsNeeded * avgRevPerClient
                });
            }
            
            // RECOMMENDATION 8: Frozen Memberships
            if (membershipsData && membershipsData.length > 0) {
                const frozenCount = membershipsData.filter(m => m.Frozen === 'Yes').length;
                const frozenRate = (frozenCount / membershipsData.length) * 100;
                
                if (frozenRate > 10) {
                    recommendations.push({
                        priority: 'high',
                        title: 'Address High Frozen Membership Rate',
                        description: `${frozenRate.toFixed(1)}% of memberships are frozen. This indicates potential dissatisfaction or life changes that might lead to cancellations.`,
                        action: 'Reach out personally to frozen members. Offer flexible restart options, pause benefits, or alternative services. Create a "comeback" special offer.',
                        impact: `Reactivating 50% of frozen members could recover ${formatCurrency((frozenCount * 0.5) * avgRevPerClient)}`,
                        impactValue: (frozenCount * 0.5) * avgRevPerClient
                    });
                } else if (frozenCount > 0) {
                    recommendations.push({
                        priority: 'medium',
                        title: 'Monitor Frozen Memberships',
                        description: `You have ${frozenCount} frozen membership${frozenCount > 1 ? 's' : ''}. Proactive outreach can prevent cancellations.`,
                        action: 'Schedule check-ins with frozen members. Understand their concerns and offer solutions to help them resume their wellness journey.',
                        impact: `Preventing cancellations protects ${formatCurrency(frozenCount * avgRevPerClient)} in potential revenue`,
                        impactValue: frozenCount * avgRevPerClient
                    });
                }
            }
            
            // RECOMMENDATION 9: Refunded Memberships
            if (membershipsData && membershipsData.length > 0) {
                const refundedCount = membershipsData.filter(m => parseFloat(m.Refunded) > 0).length;
                const totalRefunded = membershipsData.reduce((sum, m) => sum + (parseFloat(m.Refunded) || 0), 0);
                const refundRate = (refundedCount / membershipsData.length) * 100;
                
                if (refundRate > 5) {
                    recommendations.push({
                        priority: 'high',
                        title: 'Reduce Membership Refund Rate',
                        description: `${refundRate.toFixed(1)}% of memberships have been refunded (${formatCurrency(totalRefunded)} total). This suggests issues with value delivery or expectations.`,
                        action: 'Analyze refund reasons. Improve onboarding process. Set clear expectations. Consider satisfaction check-ins after first 2-3 sessions.',
                        impact: `Reducing refunds by 50% would save ${formatCurrency(totalRefunded * 0.5)}`,
                        impactValue: totalRefunded * 0.5
                    });
                } else if (refundedCount > 0) {
                    recommendations.push({
                        priority: 'low',
                        title: 'Low Refund Rate - Maintain Quality',
                        description: `Your refund rate is ${refundRate.toFixed(1)}%, which is excellent. This indicates strong value delivery and customer satisfaction.`,
                        action: 'Continue current quality standards. Document what\'s working and train all team members on best practices.',
                        impact: 'Maintaining low refund rates protects revenue and reputation',
                        impactValue: 0
                    });
                }
            }
            
            // Sort by impact value
            recommendations.sort((a, b) => b.impactValue - a.impactValue);
            
            return recommendations;
        }
        
        // Show journey stage details
        function showJourneyDetails(stage, count) {
            let title, content;
            
            switch(stage) {
                case 'leads':
                    title = 'Total Contacts';
                    content = `<p>You have <strong>${formatNumber(count)}</strong> total people in your database.</p>
                               <p>These include both leads (prospects) and customers (people who have made at least one purchase).</p>`;
                    break;
                case 'customers':
                    title = 'Converted Customers';
                    content = `<p><strong>${formatNumber(count)}</strong> people have become customers.</p>
                               <p>These are contacts who have made at least one appointment or purchase.</p>`;
                    break;
                case 'intro':
                    title = 'Tried Intro Offer';
                    content = `<p><strong>${formatNumber(count)}</strong> customers tried an introductory offer.</p>
                               <p>Intro offers are a great way to let new clients experience your services at a lower barrier to entry.</p>`;
                    break;
                case 'purchase':
                    title = 'Made First Purchase';
                    content = `<p><strong>${formatNumber(count)}</strong> customers made a paid purchase (non-intro).</p>
                               <p>This is a critical conversion point - they've decided to pay full price for your services.</p>`;
                    break;
                case 'repeat':
                    title = 'Repeat Customers (2+ visits)';
                    content = `<p><strong>${formatNumber(count)}</strong> customers have visited multiple times.</p>
                               <p>Repeat customers are your foundation - they've experienced your value and come back for more.</p>`;
                    break;
                case 'loyal':
                    title = 'Loyal Customers (5+ visits)';
                    content = `<p><strong>${formatNumber(count)}</strong> customers are loyal regulars with 5+ visits.</p>
                               <p>These are your MVPs! They trust you, love your services, and likely refer others.</p>`;
                    break;
            }
            
            showModal(title, content);
        }
        
        // CHART RENDERING FUNCTIONS
        // Helper function to calculate trendline using linear regression
        function calculateTrendline(data) {
            const n = data.length;
            if (n === 0) return [];
            
            let sumX = 0, sumY = 0, sumXY = 0, sumX2 = 0;
            
            data.forEach((y, x) => {
                sumX += x;
                sumY += y;
                sumXY += x * y;
                sumX2 += x * x;
            });
            
            const slope = (n * sumXY - sumX * sumY) / (n * sumX2 - sumX * sumX);
            const intercept = (sumY - slope * sumX) / n;
            
            return data.map((_, x) => slope * x + intercept);
        }
        
        function destroyChart(chartId) {
            if (allCharts[chartId]) {
                allCharts[chartId].destroy();
                delete allCharts[chartId];
            }
        }
        
        // Chart helper function to reduce duplicate code
        function createChart(canvasId, chartId, config) {
            const canvas = document.getElementById(canvasId);
            if (!canvas) return null;
            destroyChart(chartId);
            const ctx = canvas.getContext('2d');
            allCharts[chartId] = new Chart(ctx, config);
            return allCharts[chartId];
        }
        
        // Common chart options
        const chartDefaults = {
            responsive: true,
            maintainAspectRatio: false,
            plugins: { legend: { display: false } }
        };
        
        function renderRevenueByLocationChart() {
            const canvas = document.getElementById('revenueByLocationChart');
            if (!canvas) return;
            
            destroyChart('revenueByLocation');
            
            const revenueByLocation = {};
            filteredAppointments.forEach(row => {
                const location = row.Location || 'Unknown';
                revenueByLocation[location] = (revenueByLocation[location] || 0) + parseFloat(row.Revenue || 0);
            });
            
            const ctx = canvas.getContext('2d');
            allCharts.revenueByLocation = new Chart(ctx, {
                type: 'bar',
                data: {
                    labels: Object.keys(revenueByLocation),
                    datasets: [{
                        label: 'Revenue',
                        data: Object.values(revenueByLocation),
                        backgroundColor: '#71BED2',
                        borderColor: '#013160',
                        borderWidth: 2
                    }]
                },
                options: {
                    responsive: true,
                    maintainAspectRatio: false,
                    plugins: { legend: { display: false } },
                    scales: {
                        y: {
                            beginAtZero: true,
                            ticks: {
                                callback: function(value) {
                                    return formatCurrency(value);
                                }
                            }
                        }
                    }
                }
            });
        }
        
        function renderRevenueByServiceChart() {
            const canvas = document.getElementById('revenueByServiceChart');
            if (!canvas) return;
            
            destroyChart('revenueByService');
            
            const revenueByService = {};
            filteredAppointments.forEach(row => {
                const service = row['Appointment'] || 'Unknown';
                revenueByService[service] = (revenueByService[service] || 0) + parseFloat(row.Revenue || 0);
            });
            
            // Filter out services with $0 revenue
            const filteredServices = Object.entries(revenueByService)
                .filter(([service, revenue]) => revenue > 0)
                .sort((a, b) => b[1] - a[1])
                .slice(0, 8);
            
            const ctx = canvas.getContext('2d');
            allCharts.revenueByService = new Chart(ctx, {
                type: 'bar',
                data: {
                    labels: filteredServices.map(s => s[0].substring(0, 25)),
                    datasets: [{
                        label: 'Revenue',
                        data: filteredServices.map(s => s[1]),
                        backgroundColor: '#013160',
                        borderColor: '#71BED2',
                        borderWidth: 2
                    }]
                },
                options: {
                    responsive: true,
                    maintainAspectRatio: false,
                    onClick: (event, elements) => {
                        if (elements.length > 0) {
                            const index = elements[0].index;
                            const serviceName = filteredServices[index][0];
                            showServiceDetails(serviceName);
                        }
                    },
                    plugins: { legend: { display: false } },
                    scales: {
                        y: {
                            beginAtZero: true,
                            ticks: {
                                callback: function(value) {
                                    return formatCurrency(value);
                                }
                            }
                        }
                    }
                }
            });
        }
        
        function renderIntroSessionsChart() {
            const canvas = document.getElementById('introSessionsChart');
            if (!canvas) return;
            
            destroyChart('introSessions');
            
            const introCount = filteredAppointments.filter(row => 
                isIntroOffer(row['Appointment'])
            ).length;
            const regularCount = filteredAppointments.length - introCount;
            
            const ctx = canvas.getContext('2d');
            allCharts.introSessions = new Chart(ctx, {
                type: 'doughnut',
                data: {
                    labels: ['Intro Offers', 'Regular Sessions'],
                    datasets: [{
                        data: [introCount, regularCount],
                        backgroundColor: ['#FBB514', '#013160'],
                        borderWidth: 2,
                        borderColor: '#fff'
                    }]
                },
                options: {
                    responsive: true,
                    maintainAspectRatio: false,
                    plugins: {
                        legend: { position: 'bottom' }
                    }
                }
            });
        }
        
        function renderPaymentMethodsChart() {
            const canvas = document.getElementById('paymentMethodsChart');
            if (!canvas) return;
            
            destroyChart('paymentMethods');
            
            const paymentMethods = {};
            filteredAppointments.forEach(row => {
                const method = row['Payment Methods'] || 'Unknown';
                paymentMethods[method] = (paymentMethods[method] || 0) + 1;
            });
            
            const ctx = canvas.getContext('2d');
            allCharts.paymentMethods = new Chart(ctx, {
                type: 'pie',
                data: {
                    labels: Object.keys(paymentMethods),
                    datasets: [{
                        data: Object.values(paymentMethods),
                        backgroundColor: ['#013160', '#71BED2', '#FBB514', '#28a745', '#dc3545'],
                        borderWidth: 2,
                        borderColor: '#fff'
                    }]
                },
                options: {
                    responsive: true,
                    maintainAspectRatio: false,
                    plugins: {
                        legend: { position: 'bottom' }
                    }
                }
            });
        }
        
        function renderHeatmap() {
            const container = document.getElementById('heatmapContainer');
            if (!container) return;
            
            const heatmapData = {};
            const days = ['Monday', 'Tuesday', 'Wednesday', 'Thursday', 'Friday', 'Saturday'];
            
            // Initialize - Monday to Saturday only (no Sunday)
            days.forEach(day => {
                heatmapData[day] = {};
                for (let hour = 6; hour <= 21; hour++) {
                    heatmapData[day][hour] = 0;
                }
            });
            
            // Populate
            filteredAppointments.forEach(row => {
                const date = parseDate(row['Appointment Date']);
                const dayIndex = date.getDay();
                
                // Skip Sunday (0)
                if (dayIndex === 0) return;
                
                // Map day index to day name (1=Monday, 6=Saturday)
                const dayName = days[dayIndex - 1];
                const hour = date.getHours();
                
                if (heatmapData[dayName] && heatmapData[dayName][hour] !== undefined) {
                    heatmapData[dayName][hour]++;
                }
            });
            
            // Find max
            let maxValue = 0;
            Object.values(heatmapData).forEach(dayData => {
                Object.values(dayData).forEach(count => {
                    if (count > maxValue) maxValue = count;
                });
            });
            
            // Render
            let html = '<table class="heatmap-table"><thead><tr><th>Day</th>';
            for (let hour = 6; hour <= 21; hour++) {
                const displayHour = hour > 12 ? `${hour - 12}p` : (hour === 12 ? '12p' : `${hour}a`);
                html += `<th>${displayHour}</th>`;
            }
            html += '</tr></thead><tbody>';
            
            days.forEach(day => {
                html += `<tr><td onclick="showDayOfWeekDetails('${day}')" style="cursor: pointer;">${day}</td>`;
                for (let hour = 6; hour <= 21; hour++) {
                    const count = heatmapData[day][hour];
                    const intensity = maxValue > 0 ? Math.ceil((count / maxValue) * 7) : 0;
                    html += `<td class="heatmap-cell heatmap-${intensity}" 
                        title="${day} ${hour}:00 - ${count} appointments" 
                        onclick="showHourDetails('${day}', ${hour})" 
                        style="cursor: pointer;">${count}</td>`;
                }
                html += '</tr>';
            });
            
            html += '</tbody></table>';
            html += '<p style="margin-top: 15px; color: #666; font-size: 14px;"><strong>Tip:</strong> Click on a <strong>day name</strong> to see hourly breakdown. Click on an <strong>hour cell</strong> to see specific appointments.</p>';
            
            container.innerHTML = html;
        }
        
        function renderLTVDistributionChart(tier1, tier2, tier3, tier4, tier5, tier6, tier7) {
            const canvas = document.getElementById('ltvDistributionChart');
            if (!canvas) return;
            
            destroyChart('ltvDistribution');
            
            const ctx = canvas.getContext('2d');
            allCharts.ltvDistribution = new Chart(ctx, {
                type: 'bar',
                data: {
                    labels: ['$1-$100', '$100-$250', '$250-$500', '$500-$1K', '$1K-$2K', '$2K-$3K', '$3K+'],
                    datasets: [{
                        label: 'Customers',
                        data: [tier1, tier2, tier3, tier4, tier5, tier6, tier7],
                        backgroundColor: ['#dc3545', '#ffc107', '#71BED2', '#013160', '#28a745', '#9c27b0', '#FBB514']
                    }]
                },
                options: {
                    responsive: true,
                    maintainAspectRatio: false,
                    onClick: (event, elements) => {
                        if (elements.length > 0) {
                            const index = elements[0].index;
                            const labels = ['$1-$100', '$100-$250', '$250-$500', '$500-$1000', '$1000-$2000', '$2000-$3000', '$3000+'];
                            const values = [tier1, tier2, tier3, tier4, tier5, tier6, tier7];
                            showLTVDetails(labels[index], values[index]);
                        }
                    },
                    plugins: { 
                        legend: { display: false },
                        tooltip: {
                            callbacks: {
                                label: function(context) {
                                    const total = tier1 + tier2 + tier3 + tier4 + tier5 + tier6 + tier7;
                                    const percentage = total > 0 ? ((context.parsed.y / total) * 100).toFixed(1) : 0;
                                    return `${formatNumber(context.parsed.y)} customers (${percentage}%)`;
                                }
                            }
                        }
                    },
                    scales: { 
                        y: { 
                            beginAtZero: true,
                            ticks: {
                                stepSize: 1
                            }
                        } 
                    }
                }
            });
        }
        
        function renderCustomerTypesChart(customers, leads) {
            const canvas = document.getElementById('customerTypesChart');
            if (!canvas) return;
            
            destroyChart('customerTypes');
            
            const ctx = canvas.getContext('2d');
            allCharts.customerTypes = new Chart(ctx, {
                type: 'doughnut',
                data: {
                    labels: ['Customers', 'Leads'],
                    datasets: [{
                        data: [customers, leads],
                        backgroundColor: ['#013160', '#71BED2'],
                        borderWidth: 2,
                        borderColor: '#fff'
                    }]
                },
                options: {
                    responsive: true,
                    maintainAspectRatio: false,
                    plugins: { legend: { position: 'bottom' } }
                }
            });
        }

        function renderVisitFrequencyChart(visitDist) {
            const canvas = document.getElementById('visitFrequencyChart');
            if (!canvas) return;
            
            destroyChart('visitFrequency');
            
            const ctx = canvas.getContext('2d');
            allCharts.visitFrequency = new Chart(ctx, {
                type: 'bar',
                data: {
                    labels: Object.keys(visitDist),
                    datasets: [{
                        label: 'Clients',
                        data: Object.values(visitDist),
                        backgroundColor: ['#dc3545', '#ffc107', '#71BED2', '#013160', '#28a745']
                    }]
                },
                options: {
                    responsive: true,
                    maintainAspectRatio: false,
                    onClick: (event, elements) => {
                        if (elements.length > 0) {
                            const index = elements[0].index;
                            const labels = Object.keys(visitDist);
                            const values = Object.values(visitDist);
                            showVisitFrequencyDetails(labels[index], values[index]);
                        }
                    },
                    plugins: { legend: { display: false } },
                    scales: { y: { beginAtZero: true } }
                }
            });
        }

        function renderRetentionBreakdownChart(oneTime, returning) {
            const canvas = document.getElementById('retentionBreakdownChart');
            if (!canvas) return;
            
            destroyChart('retentionBreakdown');
            
            const ctx = canvas.getContext('2d');
            allCharts.retentionBreakdown = new Chart(ctx, {
                type: 'doughnut',
                data: {
                    labels: ['One-Time Visitors', 'Returning Clients'],
                    datasets: [{
                        data: [oneTime, returning],
                        backgroundColor: ['#dc3545', '#28a745'],
                        borderWidth: 2,
                        borderColor: '#fff'
                    }]
                },
                options: {
                    responsive: true,
                    maintainAspectRatio: false,
                    onClick: (event, elements) => {
                        if (elements.length > 0) {
                            const index = elements[0].index;
                            const labels = ['One-Time Visitors', 'Returning Clients'];
                            const values = [oneTime, returning];
                            showRetentionDetails(labels[index], values[index]);
                        }
                    },
                    plugins: { 
                        legend: { position: 'bottom' },
                        tooltip: {
                            callbacks: {
                                label: function(context) {
                                    const total = oneTime + returning;
                                    const percentage = ((context.parsed / total) * 100).toFixed(1);
                                    return `${context.label}: ${formatNumber(context.parsed)} (${percentage}%)`;
                                }
                            }
                        }
                    }
                }
            });
        }
        
        function renderPractitionerCharts(practitionerData) {
            // Revenue chart
            const revenueCanvas = document.getElementById('practitionerRevenueChart');
            if (revenueCanvas) {
                destroyChart('practitionerRevenue');
                
                const sorted = Object.entries(practitionerData)
                    .sort((a, b) => b[1].revenue - a[1].revenue);
                
                const ctx = revenueCanvas.getContext('2d');
                allCharts.practitionerRevenue = new Chart(ctx, {
                    type: 'bar',
                    data: {
                        labels: sorted.map(p => p[0]),
                        datasets: [{
                            label: 'Revenue',
                            data: sorted.map(p => p[1].revenue),
                            backgroundColor: '#FBB514',
                            borderColor: '#013160',
                            borderWidth: 2
                        }]
                    },
                    options: {
                        responsive: true,
                        maintainAspectRatio: false,
                        indexAxis: 'y',
                        onClick: (event, elements) => {
                            if (elements.length > 0) {
                                const index = elements[0].index;
                                const practitionerName = sorted[index][0];
                                showPractitionerDetails(practitionerName);
                            }
                        },
                        plugins: { legend: { display: false } },
                        scales: {
                            x: {
                                beginAtZero: true,
                                ticks: {
                                    callback: function(value) {
                                        return formatCurrency(value);
                                    }
                                }
                            }
                        }
                    }
                });
            }
            
            // Appointments chart
            const apptsCanvas = document.getElementById('practitionerApptsChart');
            if (apptsCanvas) {
                destroyChart('practitionerAppts');
                
                const sorted = Object.entries(practitionerData)
                    .sort((a, b) => b[1].appointments - a[1].appointments);
                
                const ctx = apptsCanvas.getContext('2d');
                allCharts.practitionerAppts = new Chart(ctx, {
                    type: 'bar',
                    data: {
                        labels: sorted.map(p => p[0]),
                        datasets: [{
                            label: 'Appointments',
                            data: sorted.map(p => p[1].appointments),
                            backgroundColor: '#71BED2',
                            borderColor: '#013160',
                            borderWidth: 2
                        }]
                    },
                    options: {
                        responsive: true,
                        maintainAspectRatio: false,
                        indexAxis: 'y',
                        onClick: (event, elements) => {
                            if (elements.length > 0) {
                                const index = elements[0].index;
                                const practitionerName = sorted[index][0];
                                showPractitionerDetails(practitionerName);
                            }
                        },
                        plugins: { legend: { display: false } },
                        scales: { x: { beginAtZero: true } }
                    }
                });
            }
        }
        
        function renderTimelineCharts(dailyData, dates) {
            // Fees timeline chart (stacked)
            const feesCanvas = document.getElementById('feesTimelineChart');
            if (feesCanvas) {
                destroyChart('feesTimeline');
                
                const ctx = feesCanvas.getContext('2d');
                const franchiseFees = dates.map(date => dailyData[date].revenue * CONFIG.franchiseFeePercent / 100);
                const brandFunds = dates.map(date => dailyData[date].revenue * CONFIG.brandFundPercent / 100);
                const ccFees = dates.map(date => dailyData[date].revenue * CONFIG.ccFeesPercent / 100);
                
                allCharts.feesTimeline = new Chart(ctx, {
                    type: 'bar',
                    data: {
                        labels: dates,
                        datasets: [
                            {
                                label: 'Franchise Fee',
                                data: franchiseFees,
                                backgroundColor: 'rgba(1, 49, 96, 0.8)',
                                borderColor: 'rgba(1, 49, 96, 1)',
                                borderWidth: 1
                            },
                            {
                                label: 'Brand Fund',
                                data: brandFunds,
                                backgroundColor: 'rgba(113, 190, 210, 0.8)',
                                borderColor: 'rgba(113, 190, 210, 1)',
                                borderWidth: 1
                            },
                            {
                                label: 'CC Processing',
                                data: ccFees,
                                backgroundColor: 'rgba(251, 181, 20, 0.8)',
                                borderColor: 'rgba(251, 181, 20, 1)',
                                borderWidth: 1
                            }
                        ]
                    },
                    options: {
                        responsive: true,
                        maintainAspectRatio: false,
                        scales: {
                            x: { stacked: true },
                            y: {
                                stacked: true,
                                beginAtZero: true,
                                ticks: {
                                    callback: function(value) {
                                        return formatCurrency(value);
                                    }
                                }
                            }
                        },
                        plugins: {
                            legend: { position: 'bottom' },
                            tooltip: {
                                callbacks: {
                                    label: function(context) {
                                        return context.dataset.label + ': ' + formatCurrency(context.parsed.y);
                                    }
                                }
                            }
                        }
                    }
                });
            }
            
            // Daily revenue chart
            const revenueCanvas = document.getElementById('dailyRevenueChart');
            if (revenueCanvas) {
                destroyChart('dailyRevenue');
                
                const ctx = revenueCanvas.getContext('2d');
                const revenueData = dates.map(date => dailyData[date].revenue);
                const trendlineData = calculateTrendline(revenueData);
                
                allCharts.dailyRevenue = new Chart(ctx, {
                    type: 'line',
                    data: {
                        labels: dates,
                        datasets: [
                            {
                                label: 'Daily Revenue',
                                data: revenueData,
                                borderColor: '#71BED2',
                                backgroundColor: 'rgba(113, 190, 210, 0.1)',
                                borderWidth: 3,
                                fill: true,
                                tension: 0.4,
                                order: 1
                            },
                            {
                                label: 'Trend',
                                data: trendlineData,
                                borderColor: 'rgba(113, 190, 210, 0.7)',
                                backgroundColor: 'transparent',
                                borderWidth: 3,
                                borderDash: [5, 5],
                                fill: false,
                                tension: 0,
                                pointRadius: 0,
                                order: 2
                            }
                        ]
                    },
                    options: {
                        responsive: true,
                        maintainAspectRatio: false,
                        plugins: { legend: { display: false } },
                        scales: {
                            y: {
                                beginAtZero: true,
                                ticks: {
                                    callback: function(value) {
                                        return formatCurrency(value);
                                    }
                                }
                            }
                        }
                    }
                });
            }
            
            // Cumulative revenue chart
            const cumulativeCanvas = document.getElementById('cumulativeRevenueChart');
            if (cumulativeCanvas) {
                destroyChart('cumulativeRevenue');
                
                let cumulative = 0;
                const cumulativeData = dates.map(date => {
                    cumulative += dailyData[date].revenue;
                    return cumulative;
                });
                
                const cumulativeTrendline = calculateTrendline(cumulativeData);
                
                const ctx = cumulativeCanvas.getContext('2d');
                allCharts.cumulativeRevenue = new Chart(ctx, {
                    type: 'line',
                    data: {
                        labels: dates,
                        datasets: [
                            {
                                label: 'Cumulative Revenue',
                                data: cumulativeData,
                                borderColor: '#28a745',
                                backgroundColor: 'rgba(40, 167, 69, 0.1)',
                                borderWidth: 3,
                                fill: true,
                                tension: 0.4,
                                order: 1
                            },
                            {
                                label: 'Trend',
                                data: cumulativeTrendline,
                                borderColor: 'rgba(40, 167, 69, 0.7)',
                                backgroundColor: 'transparent',
                                borderWidth: 3,
                                borderDash: [5, 5],
                                fill: false,
                                tension: 0,
                                pointRadius: 0,
                                order: 2
                            }
                        ]
                    },
                    options: {
                        responsive: true,
                        maintainAspectRatio: false,
                        plugins: { legend: { display: false } },
                        scales: {
                            y: {
                                beginAtZero: true,
                                ticks: {
                                    callback: function(value) {
                                        return formatCurrency(value);
                                    }
                                }
                            }
                        }
                    }
                });
            }
            
            // Daily appointments chart
            const apptsCanvas = document.getElementById('dailyAppointmentsChart');
            if (apptsCanvas) {
                destroyChart('dailyAppointments');
                
                const ctx = apptsCanvas.getContext('2d');
                const apptsData = dates.map(date => dailyData[date].appointments);
                const apptsTrendline = calculateTrendline(apptsData);
                
                allCharts.dailyAppointments = new Chart(ctx, {
                    type: 'line',
                    data: {
                        labels: dates,
                        datasets: [
                            {
                                label: 'Daily Appointments',
                                data: apptsData,
                                borderColor: '#013160',
                                backgroundColor: 'rgba(1, 49, 96, 0.1)',
                                borderWidth: 3,
                                fill: true,
                                tension: 0.4,
                                order: 1
                            },
                            {
                                label: 'Trend',
                                data: apptsTrendline,
                                borderColor: 'rgba(1, 49, 96, 0.7)',
                                backgroundColor: 'transparent',
                                borderWidth: 3,
                                borderDash: [5, 5],
                                fill: false,
                                tension: 0,
                                pointRadius: 0,
                                order: 2
                            }
                        ]
                    },
                    options: {
                        responsive: true,
                        maintainAspectRatio: false,
                        plugins: { legend: { display: false } },
                        scales: {
                            y: {
                                beginAtZero: true,
                                ticks: { stepSize: 1 }
                            }
                        }
                    }
                });
            }
            
            // Daily profit chart
            const profitCanvas = document.getElementById('dailyProfitChart');
            if (profitCanvas) {
                destroyChart('dailyProfit');
                
                const ctx = profitCanvas.getContext('2d');
                const profitData = dates.map(date => dailyData[date].profit);
                const profitTrendline = calculateTrendline(profitData);
                
                allCharts.dailyProfit = new Chart(ctx, {
                    type: 'line',
                    data: {
                        labels: dates,
                        datasets: [
                            {
                                label: 'Daily Profit',
                                data: profitData,
                                borderColor: '#FBB514',
                                backgroundColor: 'rgba(251, 181, 20, 0.1)',
                                borderWidth: 3,
                                fill: true,
                                tension: 0.4,
                                order: 1
                            },
                            {
                                label: 'Trend',
                                data: profitTrendline,
                                borderColor: 'rgba(251, 181, 20, 0.7)',
                                backgroundColor: 'transparent',
                                borderWidth: 3,
                                borderDash: [5, 5],
                                fill: false,
                                tension: 0,
                                pointRadius: 0,
                                order: 2
                            }
                        ]
                    },
                    options: {
                        responsive: true,
                        maintainAspectRatio: false,
                        plugins: { legend: { display: false } },
                        scales: {
                            y: {
                                beginAtZero: true,
                                ticks: {
                                    callback: function(value) {
                                        return formatCurrency(value);
                                    }
                                }
                            }
                        }
                    }
                });
            }
            
            // Daily revenue per appointment chart
            const revenuePerApptCanvas = document.getElementById('dailyRevenuePerApptChart');
            if (revenuePerApptCanvas) {
                destroyChart('dailyRevenuePerAppt');
                
                const ctx = revenuePerApptCanvas.getContext('2d');
                const revenuePerApptData = dates.map(date => {
                    return dailyData[date].appointments > 0 
                        ? dailyData[date].revenue / dailyData[date].appointments 
                        : 0;
                });
                const revenuePerApptTrendline = calculateTrendline(revenuePerApptData);
                
                allCharts.dailyRevenuePerAppt = new Chart(ctx, {
                    type: 'line',
                    data: {
                        labels: dates,
                        datasets: [
                            {
                                label: 'Revenue per Appointment',
                                data: revenuePerApptData,
                                borderColor: '#9c27b0',
                                backgroundColor: 'rgba(156, 39, 176, 0.1)',
                                borderWidth: 3,
                                fill: true,
                                tension: 0.4,
                                order: 1
                            },
                            {
                                label: 'Trend',
                                data: revenuePerApptTrendline,
                                borderColor: 'rgba(156, 39, 176, 0.7)',
                                backgroundColor: 'transparent',
                                borderWidth: 3,
                                borderDash: [5, 5],
                                fill: false,
                                tension: 0,
                                pointRadius: 0,
                                order: 2
                            }
                        ]
                    },
                    options: {
                        responsive: true,
                        maintainAspectRatio: false,
                        plugins: { legend: { display: false } },
                        scales: {
                            y: {
                                beginAtZero: true,
                                ticks: {
                                    callback: function(value) {
                                        return formatCurrency(value);
                                    }
                                }
                            }
                        }
                    }
                });
            }
            
            // Daily hours chart
            const hoursCanvas = document.getElementById('dailyHoursChart');
            if (hoursCanvas) {
                destroyChart('dailyHours');
                
                const ctx = hoursCanvas.getContext('2d');
                const hoursData = dates.map(date => dailyData[date].hours);
                const hoursTrendline = calculateTrendline(hoursData);
                
                allCharts.dailyHours = new Chart(ctx, {
                    type: 'line',
                    data: {
                        labels: dates,
                        datasets: [
                            {
                                label: 'Daily Hours',
                                data: hoursData,
                                borderColor: '#ff6384',
                                backgroundColor: 'rgba(255, 99, 132, 0.1)',
                                borderWidth: 3,
                                fill: true,
                                tension: 0.4,
                                order: 1
                            },
                            {
                                label: 'Trend',
                                data: hoursTrendline,
                                borderColor: 'rgba(255, 99, 132, 0.7)',
                                backgroundColor: 'transparent',
                                borderWidth: 3,
                                borderDash: [5, 5],
                                fill: false,
                                tension: 0,
                                pointRadius: 0,
                                order: 2
                            }
                        ]
                    },
                    options: {
                        responsive: true,
                        maintainAspectRatio: false,
                        plugins: { legend: { display: false } },
                        scales: {
                            y: {
                                beginAtZero: true,
                                ticks: {
                                    callback: function(value) {
                                        return value.toFixed(1) + ' hrs';
                                    }
                                }
                            }
                        }
                    }
                });
            }
            
            // Daily utilization chart
            const utilizationCanvas = document.getElementById('dailyUtilizationChart');
            if (utilizationCanvas) {
                destroyChart('dailyUtilization');
                
                const ctx = utilizationCanvas.getContext('2d');
                const utilizationData = dates.map(date => dailyData[date].utilization);
                const utilizationTrendline = calculateTrendline(utilizationData.map(v => v || 0));
                
                allCharts.dailyUtilization = new Chart(ctx, {
                    type: 'line',
                    data: {
                        labels: dates,
                        datasets: [
                            {
                                label: 'Daily Utilization %',
                                data: utilizationData,
                                borderColor: '#28a745',
                                backgroundColor: 'rgba(40, 167, 69, 0.1)',
                                borderWidth: 3,
                                fill: true,
                                tension: 0.4,
                                spanGaps: true,
                                order: 1
                            },
                            {
                                label: 'Trend',
                                data: utilizationTrendline,
                                borderColor: 'rgba(40, 167, 69, 0.7)',
                                backgroundColor: 'transparent',
                                borderWidth: 3,
                                borderDash: [5, 5],
                                fill: false,
                                tension: 0,
                                pointRadius: 0,
                                order: 2
                            }
                        ]
                    },
                    options: {
                        responsive: true,
                        maintainAspectRatio: false,
                        plugins: { legend: { display: false } },
                        scales: {
                            y: {
                                beginAtZero: true,
                                max: 100,
                                ticks: {
                                    callback: function(value) {
                                        return value.toFixed(0) + '%';
                                    }
                                }
                            }
                        }
                    }
                });
            }
            
            // New vs Returning clients chart
            const clientTypeCanvas = document.getElementById('dailyClientTypeChart');
            if (clientTypeCanvas) {
                destroyChart('dailyClientType');
                
                const ctx = clientTypeCanvas.getContext('2d');
                allCharts.dailyClientType = new Chart(ctx, {
                    type: 'bar',
                    data: {
                        labels: dates,
                        datasets: [
                            {
                                label: 'New Clients',
                                data: dates.map(date => dailyData[date].newClients.size),
                                backgroundColor: '#28a745',
                                borderColor: '#218838',
                                borderWidth: 1
                            },
                            {
                                label: 'Returning Clients',
                                data: dates.map(date => dailyData[date].returningClients.size),
                                backgroundColor: '#71BED2',
                                borderColor: '#5aa8bf',
                                borderWidth: 1
                            }
                        ]
                    },
                    options: {
                        responsive: true,
                        maintainAspectRatio: false,
                        plugins: { 
                            legend: { 
                                display: true,
                                position: 'top'
                            } 
                        },
                        scales: {
                            x: { stacked: true },
                            y: { 
                                stacked: true,
                                beginAtZero: true,
                                ticks: { stepSize: 1 }
                            }
                        }
                    }
                });
            }
        }
        
        // Render membership charts in timeline tab
        function renderMembershipTimelineCharts() {
            // Only render if memberships data is available
            if (!filteredMemberships || filteredMemberships.length === 0) {
                return;
            }
            
            // Weekly Sales Trend Chart
            const weeklyCanvas = document.getElementById('membershipWeeklyChart');
            if (weeklyCanvas) {
                destroyChart('membershipWeekly');
                const ctx = weeklyCanvas.getContext('2d');
                
                // Group by week
                const weeklyData = {};
                filteredMemberships.forEach(m => {
                    const boughtDate = m['Bought Date/Time (GMT)'] ? new Date(m['Bought Date/Time (GMT)']) : null;
                    if (boughtDate) {
                        const year = boughtDate.getFullYear();
                        const week = Math.ceil((boughtDate - new Date(year, 0, 1)) / (7 * 24 * 60 * 60 * 1000));
                        const weekKey = `${year}-W${String(week).padStart(2, '0')}`;
                        if (!weeklyData[weekKey]) {
                            weeklyData[weekKey] = { count: 0, revenue: 0 };
                        }
                        weeklyData[weekKey].count++;
                        weeklyData[weekKey].revenue += parseFloat(m['Paid Amount']) || 0;
                    }
                });
                
                const sortedWeeks = Object.keys(weeklyData).sort();
                
                allCharts.membershipWeekly = new Chart(ctx, {
                    type: 'line',
                    data: {
                        labels: sortedWeeks,
                        datasets: [
                            {
                                label: 'Weekly Sales Count',
                                data: sortedWeeks.map(w => weeklyData[w].count),
                                borderColor: '#007bff',
                                backgroundColor: 'rgba(0, 123, 255, 0.1)',
                                borderWidth: 2,
                                fill: true,
                                tension: 0.4,
                                yAxisID: 'y'
                            },
                            {
                                label: 'Weekly Revenue',
                                data: sortedWeeks.map(w => weeklyData[w].revenue),
                                borderColor: '#28a745',
                                backgroundColor: 'rgba(40, 167, 69, 0.1)',
                                borderWidth: 2,
                                fill: true,
                                tension: 0.4,
                                yAxisID: 'y1'
                            }
                        ]
                    },
                    options: {
                        responsive: true,
                        maintainAspectRatio: false,
                        plugins: {
                            legend: {
                                display: true,
                                position: 'top'
                            }
                        },
                        scales: {
                            y: {
                                type: 'linear',
                                display: true,
                                position: 'left',
                                beginAtZero: true,
                                ticks: { stepSize: 1 }
                            },
                            y1: {
                                type: 'linear',
                                display: true,
                                position: 'right',
                                beginAtZero: true,
                                grid: {
                                    drawOnChartArea: false
                                },
                                ticks: {
                                    callback: function(value) {
                                        return formatCurrency(value);
                                    }
                                }
                            }
                        }
                    }
                });
            }
            
            // Average Sale Value Over Time Chart
            const avgValueCanvas = document.getElementById('membershipAvgValueChart');
            if (avgValueCanvas) {
                destroyChart('membershipAvgValue');
                const ctx = avgValueCanvas.getContext('2d');
                
                // Group by week to calculate averages
                const weeklyRevenue = {};
                filteredMemberships.forEach(m => {
                    const boughtDate = m['Bought Date/Time (GMT)'] ? new Date(m['Bought Date/Time (GMT)']) : null;
                    if (boughtDate) {
                        const year = boughtDate.getFullYear();
                        const week = Math.ceil((boughtDate - new Date(year, 0, 1)) / (7 * 24 * 60 * 60 * 1000));
                        const weekKey = `${year}-W${String(week).padStart(2, '0')}`;
                        if (!weeklyRevenue[weekKey]) {
                            weeklyRevenue[weekKey] = [];
                        }
                        weeklyRevenue[weekKey].push(parseFloat(m['Paid Amount']) || 0);
                    }
                });
                
                const sortedWeeks = Object.keys(weeklyRevenue).sort();
                
                // Calculate average value per week
                const weeklyAvg = {};
                sortedWeeks.forEach(week => {
                    const values = weeklyRevenue[week];
                    if (values.length > 0) {
                        weeklyAvg[week] = values.reduce((sum, v) => sum + v, 0) / values.length;
                    } else {
                        weeklyAvg[week] = 0;
                    }
                });
                
                allCharts.membershipAvgValue = new Chart(ctx, {
                    type: 'line',
                    data: {
                        labels: sortedWeeks,
                        datasets: [{
                            label: 'Average Membership Sale Value (Weekly Average)',
                            data: sortedWeeks.map(w => weeklyAvg[w]),
                            borderColor: '#ff6384',
                            backgroundColor: 'rgba(255, 99, 132, 0.1)',
                            borderWidth: 2,
                            fill: true,
                            tension: 0.4
                        }]
                    },
                    options: {
                        responsive: true,
                        maintainAspectRatio: false,
                        plugins: { 
                            legend: { 
                                display: true,
                                position: 'top',
                                labels: {
                                    font: {
                                        size: 12,
                                        weight: 'bold'
                                    }
                                }
                            },
                            title: {
                                display: true,
                                text: 'Note: Values represent weekly averages',
                                font: {
                                    size: 10,
                                    style: 'italic'
                                },
                                color: '#666',
                                padding: {
                                    top: 5,
                                    bottom: 10
                                }
                            }
                        },
                        scales: {
                            y: {
                                beginAtZero: true,
                                ticks: {
                                    callback: function(value) {
                                        return formatCurrency(value);
                                    }
                                }
                            }
                        }
                    }
                });
            }
        }
    
        // Modal control functions
        function openSettingsModal() {
            document.getElementById('settingsModal').classList.add('show');
            document.body.style.overflow = 'hidden';
        }

        function closeSettingsModal() {
            document.getElementById('settingsModal').classList.remove('show');
            document.body.style.overflow = 'auto';
            document.getElementById('franchiseSettingsStatus').innerHTML = '';
        }

        function openUploadModal() {
            document.getElementById('uploadModal').classList.add('show');
            document.body.style.overflow = 'hidden';
        }

        function closeUploadModal() {
            document.getElementById('uploadModal').classList.remove('show');
            document.body.style.overflow = 'auto';
        }

        function hideEmptyState() {
            document.getElementById('emptyState').style.display = 'none';
            document.getElementById('mainContent').style.display = 'block';
            document.getElementById('uploadBadge').style.display = 'none';
            document.getElementById('uploadBtn').classList.remove('highlight');
        }

        function showEmptyState() {
            document.getElementById('emptyState').style.display = 'block';
            document.getElementById('mainContent').style.display = 'none';
            document.getElementById('uploadBadge').style.display = 'block';
            document.getElementById('uploadBtn').classList.add('highlight');
        }

</script>
    
    <!-- Footer -->
    <div class="dashboard-footer">
        <div class="footer-content">
            <span class="footer-version">v2.20251104.08</span>
            <span class="footer-separator">|</span>
            <span class="footer-credits">Made by bonJoeV with ‚ù§Ô∏è</span>
        </div>
    </div>
</body>
</html>
