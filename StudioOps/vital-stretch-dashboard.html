<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta http-equiv="Cache-Control" content="no-cache, no-store, must-revalidate">
    <meta http-equiv="Pragma" content="no-cache">
    <meta http-equiv="Expires" content="0">
    <title>The Vital Stretch - Analytics Dashboard</title>
    
    <!-- Google Fonts -->
    <link href="https://fonts.googleapis.com/css2?family=Yeseva+One&display=swap" rel="stylesheet">
    
    <!-- External Libraries -->
    <script src="https://cdn.jsdelivr.net/npm/chart.js@4.4.0/dist/chart.umd.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/PapaParse/5.4.1/papaparse.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/jszip/3.10.1/jszip.min.js"></script>
    
    <style>
        /* The Vital Stretch - Dashboard Styles */
        :root {
            --primary: #013160;
            --accent: #71BED2;
            --highlight: #FBB514;
            --white: #FFFFFF;
            --gray-light: #F5F5F5;
            --gray: #E0E0E0;
            --text: #333333;
            --success: #28a745;
            --warning: #ffc107;
            --danger: #dc3545;
        }

        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Futura', 'Arial', sans-serif;
            background: linear-gradient(135deg, var(--gray-light) 0%, var(--white) 100%);
            color: var(--text);
            line-height: 1.6;
        }

        h1, h2, h3, h4, h5, h6 {
            font-family: 'Yeseva One', serif;
            color: var(--primary);
        }

        /* Header */
        .dashboard-header {
            background: var(--primary);
            color: white;
            padding: 15px 30px;
            box-shadow: 0 2px 10px rgba(1, 49, 96, 0.3);
            position: relative;
        }

        .header-content {
            position: relative;
            z-index: 1;
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 15px;
        }

        .logo {
            width: 50px;
            height: 50px;
            background: white;
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            font-weight: bold;
            color: var(--primary);
            font-size: 18px;
            box-shadow: 0 2px 8px rgba(0,0,0,0.2);
        }

        .dashboard-header h1 {
            font-size: 1.8em;
            margin-bottom: 0;
            color: white;
        }

        .tagline {
            font-size: 0.9em;
            font-style: italic;
            color: var(--highlight);
            margin-top: 5px;
            font-weight: 600;
        }

        /* Header Icons */
        .header-icons {
            position: fixed;
            top: 15px;
            right: 20px;
            display: flex;
            gap: 10px;
            z-index: 1000;
        }

        .icon-btn {
            background: white;
            color: var(--primary);
            border: 2px solid var(--accent);
            width: 50px;
            height: 50px;
            border-radius: 50%;
            cursor: pointer;
            font-size: 24px;
            display: flex;
            align-items: center;
            justify-content: center;
            box-shadow: 0 3px 10px rgba(0,0,0,0.15);
            transition: all 0.3s ease;
            position: relative;
        }

        .icon-btn:hover {
            background: var(--accent);
            color: white;
            transform: translateY(-2px);
            box-shadow: 0 5px 15px rgba(0,0,0,0.25);
        }

        .icon-btn.highlight {
            background: var(--highlight);
            border-color: var(--highlight);
            animation: pulse 2s infinite;
        }

        @keyframes pulse {
            0%, 100% { transform: scale(1); }
            50% { transform: scale(1.05); }
        }

        .icon-btn .badge {
            position: absolute;
            top: -5px;
            right: -5px;
            background: var(--danger);
            color: white;
            width: 20px;
            height: 20px;
            border-radius: 50%;
            font-size: 12px;
            font-weight: bold;
            display: flex;
            align-items: center;
            justify-content: center;
        }


        /* Modal Styles */
        .settings-modal-overlay {
            display: none;
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: rgba(0, 0, 0, 0.7);
            z-index: 10000;
            overflow-y: auto;
        }

        .settings-modal-overlay.show {
            display: flex;
            align-items: flex-start;
            justify-content: center;
            padding: 20px;
        }

        .settings-modal-content {
            background: white;
            border-radius: 15px;
            box-shadow: 0 10px 40px rgba(0,0,0,0.3);
            max-width: 1200px;
            width: 100%;
            margin: 20px auto;
        }

        .upload-modal-overlay {
            display: none;
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: rgba(0, 0, 0, 0.7);
            z-index: 10000;
            overflow-y: auto;
        }

        .upload-modal-overlay.show {
            display: flex;
            align-items: center;
            justify-content: center;
            padding: 20px;
        }

        .upload-modal-content {
            background: white;
            border-radius: 15px;
            box-shadow: 0 10px 40px rgba(0,0,0,0.3);
            max-width: 900px;
            width: 100%;
        }

        .modal-header-custom {
            background: linear-gradient(135deg, var(--primary) 0%, var(--accent) 100%);
            color: white;
            padding: 20px 25px;
            border-radius: 15px 15px 0 0;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }

        .modal-header-custom h3 {
            margin: 0;
            color: white;
            font-size: 1.5em;
        }

        .modal-close-custom {
            background: rgba(255, 255, 255, 0.2);
            border: none;
            color: white;
            font-size: 24px;
            cursor: pointer;
            width: 35px;
            height: 35px;
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            transition: all 0.3s ease;
        }

        .modal-close-custom:hover {
            background: rgba(255, 255, 255, 0.3);
            transform: rotate(90deg);
        }

        .modal-body-custom {
            padding: 25px;
        }

        .empty-state {
            text-align: center;
            padding: 60px 20px;
            color: #666;
        }

        .empty-state-icon {
            font-size: 80px;
            margin-bottom: 20px;
            opacity: 0.5;
        }

        .empty-state h2 {
            color: var(--primary);
            margin-bottom: 15px;
        }

        .empty-state p {
            font-size: 16px;
            margin-bottom: 30px;
        }

        /* Container */
        .container {
            max-width: 1400px;
            margin: 20px auto;
            padding: 0 20px;
        }

        /* Upload Section */
        .upload-section {
            background: white;
            padding: 10px;
            border-radius: 10px;
            box-shadow: 0 5px 20px rgba(0,0,0,0.1);
            margin-bottom: 14px;
            border: 2px solid var(--accent);
        }

        .upload-section h2 {
            margin-bottom: 7px;
            text-align: center;
            font-size: 0.91em;
        }

        .upload-grid {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 10px;
            margin-top: 7px;
        }

        .upload-box {
            text-align: center;
            padding: 10px;
            background: var(--gray-light);
            border-radius: 7px;
            border: 2px dashed var(--accent);
            transition: all 0.3s ease;
        }

        .upload-box:hover {
            border-color: var(--primary);
            background: white;
        }

        .upload-box h3 {
            font-size: 11px;
            margin-bottom: 7px;
        }

        .upload-btn {
            background: var(--highlight);
            color: var(--primary);
            padding: 8px 17px;
            border: none;
            border-radius: 35px;
            cursor: pointer;
            font-size: 10px;
            font-weight: bold;
            transition: all 0.3s ease;
            box-shadow: 0 4px 15px rgba(251, 181, 20, 0.3);
            display: inline-block;
        }

        .upload-btn:hover {
            background: var(--primary);
            color: var(--highlight);
            transform: translateY(-2px);
        }

        .upload-status {
            margin-top: 7px;
            font-size: 10px;
            min-height: 14px;
        }

        /* Collapsible Section */
        .collapsible-header {
            cursor: pointer;
            user-select: none;
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 5px 0;
            transition: all 0.3s ease;
        }

        .collapsible-header:hover {
            opacity: 0.8;
        }

        .collapsible-header h2 {
            margin-bottom: 0;
        }

        .collapse-icon {
            font-size: 1.5em;
            transition: transform 0.3s ease;
            display: inline-block;
        }

        .collapse-icon.collapsed {
            transform: rotate(-90deg);
        }

        .collapsible-content {
            max-height: 1000px;
            overflow: hidden;
            transition: max-height 0.3s ease, opacity 0.3s ease, margin 0.3s ease;
            opacity: 1;
        }

        .collapsible-content.collapsed {
            max-height: 0;
            opacity: 0;
            margin-top: 0 !important;
        }

        /* Modal Styles */
        .modal-overlay {
            display: none;
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: rgba(0, 0, 0, 0.7);
            z-index: 9999;
            animation: fadeIn 0.2s ease;
        }

        .modal-overlay.show {
            display: flex;
            align-items: center;
            justify-content: center;
            padding: 20px;
        }

        @keyframes fadeIn {
            from { opacity: 0; }
            to { opacity: 1; }
        }

        .modal-content {
            background: white;
            border-radius: 15px;
            box-shadow: 0 10px 40px rgba(0, 0, 0, 0.3);
            max-width: 900px;
            max-height: 90vh;
            width: 100%;
            overflow-y: auto;
            animation: slideUp 0.3s ease;
            position: relative;
        }

        @keyframes slideUp {
            from {
                transform: translateY(50px);
                opacity: 0;
            }
            to {
                transform: translateY(0);
                opacity: 1;
            }
        }

        .modal-header {
            background: linear-gradient(135deg, var(--primary) 0%, var(--accent) 100%);
            color: white;
            padding: 20px 25px;
            border-radius: 15px 15px 0 0;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }

        .modal-header h3 {
            margin: 0;
            color: white;
            font-size: 1.5em;
        }

        .modal-close {
            background: rgba(255, 255, 255, 0.2);
            border: none;
            color: white;
            font-size: 24px;
            cursor: pointer;
            width: 35px;
            height: 35px;
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            transition: all 0.3s ease;
        }

        .modal-close:hover {
            background: rgba(255, 255, 255, 0.3);
            transform: rotate(90deg);
        }

        .modal-body {
            padding: 25px;
        }

        .modal-stat {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 12px;
            background: var(--gray-light);
            border-radius: 8px;
            margin-bottom: 10px;
            border-left: 4px solid var(--accent);
        }

        .modal-stat-label {
            font-weight: 600;
            color: var(--primary);
        }

        .modal-stat-value {
            font-size: 1.2em;
            font-weight: bold;
            color: var(--text);
        }

        .modal-section {
            margin-bottom: 25px;
        }

        .modal-section h4 {
            color: var(--primary);
            margin-bottom: 15px;
            padding-bottom: 10px;
            border-bottom: 2px solid var(--accent);
        }

        .modal-table {
            width: 100%;
            border-collapse: collapse;
            margin-top: 10px;
        }

        .modal-table th {
            background: var(--primary);
            color: white;
            padding: 10px;
            text-align: left;
            font-weight: 600;
            font-size: 0.9em;
        }

        .modal-table td {
            padding: 10px;
            border-bottom: 1px solid var(--gray);
            font-size: 0.9em;
        }

        .modal-table tr:hover {
            background: var(--gray-light);
        }

        .modal-table tr:last-child td {
            border-bottom: none;
        }

        .modal-highlight {
            background: linear-gradient(135deg, rgba(251, 181, 20, 0.1) 0%, rgba(251, 181, 20, 0.05) 100%);
            padding: 15px;
            border-radius: 10px;
            border-left: 4px solid var(--highlight);
            margin-bottom: 15px;
        }

        .modal-highlight strong {
            color: var(--primary);
        }

        /* Interactive Indicator Badge */
        .chart-card {
            position: relative;
        }

        .interactive-badge {
            position: absolute;
            top: 10px;
            right: 10px;
            background: transparent;
            color: transparent;
            padding: 0;
            border-radius: 0;
            font-size: 24px;
            font-weight: normal;
            z-index: 10;
            box-shadow: none;
            display: flex;
            align-items: center;
            gap: 0;
            cursor: pointer;
            animation: wiggle 2s ease-in-out infinite;
            filter: drop-shadow(0 2px 4px rgba(0,0,0,0.2));
        }

        @keyframes wiggle {
            0%, 100% {
                transform: rotate(0deg);
            }
            10%, 30%, 50%, 70%, 90% {
                transform: rotate(-10deg);
            }
            20%, 40%, 60%, 80% {
                transform: rotate(10deg);
            }
        }

        .interactive-badge::before {
            content: 'üëÜ';
            font-size: 28px;
        }

        /* CSV Export Button */
        .csv-export-btn {
            background: var(--success);
            color: white;
            border: none;
            padding: 10px 20px;
            border-radius: 8px;
            cursor: pointer;
            font-weight: bold;
            font-size: 14px;
            transition: all 0.3s ease;
            display: inline-flex;
            align-items: center;
            gap: 8px;
            margin-top: 15px;
        }

        .csv-export-btn:hover {
            background: #218838;
            transform: translateY(-2px);
            box-shadow: 0 4px 12px rgba(40, 167, 69, 0.3);
        }

        .csv-export-btn::before {
            content: 'üì•';
            font-size: 16px;
        }

        /* Tooltip for hover data */
        .name-cell {
            cursor: help;
            position: relative;
        }

        .name-cell:hover::after {
            content: attr(data-tooltip);
            position: absolute;
            bottom: 100%;
            left: 50%;
            transform: translateX(-50%);
            background: var(--primary);
            color: white;
            padding: 8px 12px;
            border-radius: 6px;
            white-space: nowrap;
            font-size: 12px;
            z-index: 1000;
            margin-bottom: 5px;
            box-shadow: 0 4px 12px rgba(0,0,0,0.2);
        }

        .name-cell:hover::before {
            content: '';
            position: absolute;
            bottom: 100%;
            left: 50%;
            transform: translateX(-50%);
            border: 6px solid transparent;
            border-top-color: var(--primary);
            margin-bottom: -1px;
        }

        /* Active Filters Badge */
        .active-filters {
            background: var(--accent);
            color: white;
            padding: 15px 20px;
            border-radius: 10px;
            margin-bottom: 20px;
            display: none;
        }

        .active-filters.show {
            display: block;
        }

        .filter-badge {
            display: inline-block;
            background: white;
            color: var(--primary);
            padding: 5px 12px;
            border-radius: 20px;
            margin: 5px 5px 5px 0;
            font-size: 13px;
            font-weight: 600;
        }

        /* Filters */
        .filters {
            background: white;
            padding: 15px;
            border-radius: 15px;
            box-shadow: 0 5px 20px rgba(0,0,0,0.1);
            margin-bottom: 20px;
            border-top: 4px solid var(--primary);
        }

        .filters h2 {
            margin-bottom: 10px;
            font-size: 1.3em;
        }

        .filter-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
            gap: 12px;
            margin-bottom: 15px;
        }

        .filter-group label {
            display: block;
            margin-bottom: 5px;
            font-weight: 600;
            color: var(--primary);
        }
        
        /* Make Compare To label smaller */
        .filter-group label[for="comparisonPeriod"] {
            font-size: 13px;
        }

        .filter-group select,
        .filter-group input {
            width: 100%;
            padding: 10px;
            border: 2px solid var(--accent);
            border-radius: 8px;
            font-size: 14px;
        }

        .filter-group select:focus,
        .filter-group input:focus {
            outline: none;
            border-color: var(--primary);
        }

        .quick-filters {
            display: flex;
            gap: 10px;
            flex-wrap: wrap;
            margin-top: 15px;
        }

        .quick-filter-btn {
            padding: 6px 12px;
            background: var(--accent);
            color: white;
            border: none;
            border-radius: 20px;
            cursor: pointer;
            font-size: 10px;
            transition: all 0.3s ease;
        }

        .quick-filter-btn:hover {
            background: var(--primary);
            transform: translateY(-2px);
        }

        .refresh-filter-btn {
            padding: 8px 16px;
            background: var(--highlight);
            color: var(--primary);
            border: none;
            border-radius: 25px;
            cursor: pointer;
            font-size: 12px;
            font-weight: bold;
            transition: all 0.3s ease;
            box-shadow: 0 2px 8px rgba(251, 181, 20, 0.3);
            margin-top: 10px;
        }

        .refresh-filter-btn:hover {
            background: var(--primary);
            color: var(--highlight);
            transform: translateY(-2px);
        }

        .refresh-filter-btn:active {
            transform: translateY(0);
        }

        /* Footer */
        .dashboard-footer {
            background: var(--primary);
            color: white;
            text-align: center;
            padding: 15px 30px;
            margin-top: 40px;
            border-top: 3px solid var(--highlight);
        }

        .footer-content {
            display: flex;
            justify-content: center;
            align-items: center;
            gap: 20px;
            flex-wrap: wrap;
            font-size: 14px;
        }

        .footer-version {
            color: var(--accent);
            font-weight: 600;
        }

        .footer-credits {
            color: var(--highlight);
        }

        .footer-separator {
            color: var(--accent);
        }

        /* Tabs */
        .tabs {
            display: flex;
            gap: 5px;
            margin-bottom: 30px;
            flex-wrap: nowrap;
            overflow-x: auto;
        }

        .tab {
            padding: 12px 20px;
            min-width: auto;
            flex: 1;
            background: white;
            border: 2px solid var(--accent);
            border-radius: 10px;
            cursor: pointer;
            transition: all 0.3s ease;
            font-weight: 600;
            color: var(--primary);
            white-space: nowrap;
            text-align: center;
        }

        .tab:hover {
            background: var(--accent);
            color: white;
            transform: translateY(-2px);
        }

        .tab.active {
            background: var(--primary);
            color: white;
            border-color: var(--primary);
        }

        .tab-content {
            display: none;
        }

        .tab-content.active {
            display: block;
        }

        /* Metrics Grid */
        .metrics-grid {
            display: grid;
            grid-template-columns: repeat(8, 1fr);
            gap: 12px;
            margin-bottom: 30px;
        }

        .metric-card {
            background: white;
            padding: 25px;
            border-radius: 15px;
            box-shadow: 0 5px 15px rgba(0,0,0,0.1);
            border-left: 5px solid var(--accent);
            transition: all 0.3s ease;
            position: relative;
        }

        .metric-card.compact {
            padding: 11px;
            transform: scale(0.9);
            transform-origin: center;
            border-left-width: 3px;
            border-radius: 10px;
            text-align: center;
        }

        .metric-card.compact:hover {
            transform: scale(0.9) translateY(-5px);
        }

        .metric-card.compact .metric-label {
            font-size: 11px;
            margin-bottom: 5px;
        }

        .metric-card.compact .metric-value {
            font-size: 1.6em;
            margin-bottom: 0;
        }

        .metric-card.compact .metric-subtext {
            font-size: 10px;
            opacity: 0;
            max-height: 0;
            overflow: hidden;
            transition: all 0.3s ease;
            margin-top: 5px;
        }

        .metric-card.compact .comparison-details {
            opacity: 0;
            max-height: 0;
            overflow: hidden;
            transition: all 0.3s ease;
        }

        .metric-card.compact:hover .metric-subtext {
            opacity: 1;
            max-height: 50px;
        }

        .metric-card.compact:hover .comparison-details {
            opacity: 1;
            max-height: 30px;
        }

        .metric-card:hover {
            transform: translateY(-5px);
            box-shadow: 0 8px 25px rgba(0,0,0,0.15);
        }

        .metric-card.warning {
            border-left-color: var(--warning);
        }

        .metric-card.danger {
            border-left-color: var(--danger);
        }

        .metric-card.success {
            border-left-color: var(--success);
        }

        .metric-label {
            color: var(--primary);
            font-size: 14px;
            font-weight: 600;
            text-transform: uppercase;
            margin-bottom: 10px;
        }

        .metric-value {
            font-size: 2.2em;
            font-weight: bold;
            color: var(--primary);
            margin-bottom: 5px;
            font-family: 'Yeseva One', serif;
            word-break: break-word;
            line-height: 1.2;
        }

        .metric-subtext {
            color: var(--accent);
            font-size: 13px;
        }

        /* Charts */
        .charts-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(400px, 1fr));
            gap: 25px;
            margin-bottom: 30px;
        }
        
        .chart-grid {
            display: grid;
            grid-template-columns: repeat(2, 1fr);
            gap: 25px;
            margin-bottom: 30px;
        }

        .chart-container {
            background: white;
            padding: 25px;
            border-radius: 15px;
            box-shadow: 0 5px 15px rgba(0,0,0,0.1);
            position: relative;
        }

        .chart-container.full-width {
            grid-column: 1 / -1;
        }

        .chart-container h2, .chart-container h3 {
            margin-bottom: 20px;
            font-size: 1.3em;
        }

        .chart-wrapper {
            position: relative;
            height: 300px;
        }

        /* Tables */
        .table-container {
            background: white;
            padding: 25px;
            border-radius: 15px;
            box-shadow: 0 5px 15px rgba(0,0,0,0.1);
            margin-bottom: 30px;
            overflow-x: auto;
        }

        table {
            width: 100%;
            border-collapse: collapse;
            margin-top: 15px;
        }

        thead {
            background: var(--primary);
            color: white;
        }

        th {
            padding: 15px;
            text-align: left;
            font-weight: 600;
            border-bottom: 3px solid var(--highlight);
        }

        td {
            padding: 12px 15px;
            border-bottom: 1px solid var(--gray);
        }

        tbody tr:hover {
            background: var(--gray-light);
        }

        /* Borderless VSP Tables */
        .vsp-table {
            border-collapse: separate;
            border-spacing: 0;
        }
        
        .vsp-table th,
        .vsp-table td {
            border: none !important;
            border-bottom: none !important;
        }
        
        .vsp-table thead tr th {
            border-bottom: none !important;
        }

        /* Alerts */
        .alert {
            padding: 20px;
            margin-bottom: 20px;
            border-radius: 10px;
            border-left: 5px solid;
        }

        .alert.success {
            background: rgba(40, 167, 69, 0.1);
            border-color: var(--success);
            color: #155724;
        }

        .alert.warning {
            background: rgba(255, 193, 7, 0.1);
            border-color: var(--warning);
            color: #856404;
        }

        .alert.danger {
            background: rgba(220, 53, 69, 0.1);
            border-color: var(--danger);
            color: #721c24;
        }

        .alert.info {
            background: rgba(113, 190, 210, 0.1);
            border-color: var(--accent);
            color: var(--primary);
        }

        .alert h4 {
            margin-bottom: 10px;
            color: inherit;
        }

        /* Progress Bars */
        .progress-bar {
            height: 30px;
            background: var(--gray-light);
            border-radius: 15px;
            overflow: hidden;
            border: 2px solid var(--gray);
            margin: 10px 0;
        }

        .progress-fill {
            height: 100%;
            background: linear-gradient(90deg, var(--accent), var(--primary));
            display: flex;
            align-items: center;
            justify-content: center;
            color: white;
            font-weight: bold;
            transition: width 0.5s ease;
        }

        .progress-fill.warning {
            background: linear-gradient(90deg, #ffc107, #ff9800);
        }

        .progress-fill.danger {
            background: linear-gradient(90deg, #dc3545, #c82333);
        }

        .progress-fill.success {
            background: linear-gradient(90deg, #28a745, #20c997);
        }

        /* Heatmap */
        .heatmap-table {
            border-collapse: collapse;
            font-size: 0.9em;
            margin: 20px 0;
            width: 100%;
        }

        .heatmap-table th {
            background: var(--primary);
            color: white;
            padding: 10px;
            text-align: center;
            font-size: 0.85em;
        }

        .heatmap-table td {
            padding: 12px;
            text-align: center;
            border: 1px solid var(--gray);
            cursor: pointer;
            transition: transform 0.2s;
            min-width: 50px;
            font-size: 0.9em;
        }

        .heatmap-table td:first-child {
            font-weight: bold;
            background: var(--gray-light);
            position: sticky;
            left: 0;
            z-index: 1;
        }

        .heatmap-table td:hover:not(:first-child) {
            transform: scale(1.05);
            box-shadow: 0 2px 8px rgba(0,0,0,0.2);
        }

        .heatmap-cell {
            border-radius: 5px;
            font-weight: 600;
        }

        .heatmap-0 { background-color: #f5f5f5; color: #999; }
        .heatmap-1 { background-color: rgba(113, 190, 210, 0.2); color: var(--primary); }
        .heatmap-2 { background-color: rgba(113, 190, 210, 0.4); color: var(--primary); }
        .heatmap-3 { background-color: rgba(113, 190, 210, 0.6); color: white; }
        .heatmap-4 { background-color: rgba(113, 190, 210, 0.8); color: white; }
        .heatmap-5 { background-color: var(--accent); color: white; }
        .heatmap-6 { background-color: var(--primary); color: white; }
        .heatmap-7 { background-color: #001a3a; color: white; }

        /* Loading Spinner */
        .spinner {
            display: inline-block;
            width: 20px;
            height: 20px;
            border: 3px solid rgba(0,0,0,.1);
            border-radius: 50%;
            border-top-color: var(--accent);
            animation: spin 1s ease-in-out infinite;
        }

        @keyframes spin {
            to { transform: rotate(360deg); }
        }

        /* Responsive */
        @media (max-width: 768px) {
            .dashboard-header {
                padding: 12px 15px;
            }

            .dashboard-header h1 {
                font-size: 1.4em;
            }

            .tagline {
                font-size: 0.8em;
            }

            .logo {
                width: 40px;
                height: 40px;
                font-size: 16px;
            }

            .header-content {
                flex-direction: row;
                gap: 10px;
            }
            
            .charts-grid {
                grid-template-columns: 1fr;
            }
            
            .filter-grid {
                grid-template-columns: 1fr;
            }

            .upload-grid {
                grid-template-columns: 1fr;
            }

            .tabs {
                overflow-x: auto;
            }

            .metrics-grid {
                grid-template-columns: repeat(2, 1fr);
            }

            .heatmap-table {
                font-size: 0.75em;
            }

            .heatmap-table td {
                padding: 8px;
                min-width: 40px;
            }

            .settings-btn {
                top: 10px;
                right: 10px;
                padding: 8px 14px;
                font-size: 12px;
            }
        }

        /* Period Comparison Styles */
        .comparison-indicator {
            display: inline-flex;
            align-items: center;
            margin-left: 10px;
            font-size: 0.9em;
            font-weight: 600;
            padding: 4px 10px;
            border-radius: 12px;
            background: rgba(0,0,0,0.05);
        }

        .comparison-indicator.positive {
            color: #28a745;
            background: rgba(40, 167, 69, 0.1);
        }

        .comparison-indicator.negative {
            color: #dc3545;
            background: rgba(220, 53, 69, 0.1);
        }

        .comparison-indicator.neutral {
            color: #666;
        }

        .comparison-arrow {
            font-size: 1.2em;
            margin-right: 4px;
        }

        .comparison-details {
            font-size: 8px;
            color: #666;
            font-style: italic;
            margin-top: 3px;
        }

        /* Journey Visualization Styles */
        .journey-flow {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin: 40px 0;
            padding: 20px;
            background: var(--gray-light);
            border-radius: 15px;
            overflow-x: auto;
        }

        .journey-stage {
            flex: 1;
            min-width: 140px;
            text-align: center;
            padding: 20px;
            background: white;
            border-radius: 12px;
            box-shadow: 0 3px 10px rgba(0,0,0,0.1);
            margin: 0 10px;
            cursor: pointer;
            transition: all 0.3s ease;
            border: 3px solid transparent;
        }

        .journey-stage:hover {
            transform: translateY(-5px);
            box-shadow: 0 5px 20px rgba(0,0,0,0.15);
            border-color: var(--accent);
        }

        .journey-stage-icon {
            font-size: 36px;
            margin-bottom: 10px;
        }

        .journey-stage-title {
            font-weight: bold;
            color: var(--primary);
            margin-bottom: 8px;
            font-size: 14px;
        }

        .journey-stage-count {
            font-size: 28px;
            font-weight: bold;
            color: var(--primary);
            margin-bottom: 0px;
            line-height: 1.2;
        }

        .journey-stage-percent {
            font-size: 16px;
            color: var(--accent);
            font-weight: 600;
            display: inline-block;
            margin-top: 4px;
        }

        .journey-arrow {
            font-size: 28px;
            color: var(--accent);
            opacity: 0.6;
            flex: 0 0 30px;
        }

        .journey-dropoff {
            position: absolute;
            top: 10px;
            right: 10px;
            background: #dc3545;
            color: white;
            padding: 4px 10px;
            border-radius: 12px;
            font-size: 11px;
            font-weight: bold;
        }

        /* Leaderboard Styles */
        .leaderboard-card {
            background: white;
            padding: 25px;
            border-radius: 15px;
            box-shadow: 0 5px 15px rgba(0,0,0,0.1);
            margin-bottom: 20px;
            transition: all 0.3s ease;
        }

        .leaderboard-card:hover {
            transform: translateY(-3px);
            box-shadow: 0 8px 25px rgba(0,0,0,0.15);
        }

        .leaderboard-rank {
            display: inline-flex;
            align-items: center;
            justify-content: center;
            width: 50px;
            height: 50px;
            border-radius: 50%;
            font-size: 24px;
            font-weight: bold;
            margin-right: 20px;
        }

        .leaderboard-rank.gold {
            background: linear-gradient(135deg, #FFD700, #FFA500);
            color: white;
            box-shadow: 0 4px 15px rgba(255, 215, 0, 0.4);
        }

        .leaderboard-rank.silver {
            background: linear-gradient(135deg, #C0C0C0, #A8A8A8);
            color: white;
            box-shadow: 0 4px 15px rgba(192, 192, 192, 0.4);
        }

        .leaderboard-rank.bronze {
            background: linear-gradient(135deg, #CD7F32, #8B4513);
            color: white;
            box-shadow: 0 4px 15px rgba(205, 127, 50, 0.4);
        }

        .leaderboard-rank.other {
            background: var(--gray-light);
            color: var(--primary);
            border: 2px solid var(--accent);
        }

        .leaderboard-content {
            display: flex;
            align-items: center;
            justify-content: space-between;
        }

        .leaderboard-info {
            flex: 1;
        }

        .leaderboard-name {
            font-size: 20px;
            font-weight: bold;
            color: var(--primary);
            margin-bottom: 8px;
        }

        .leaderboard-stats {
            display: flex;
            gap: 20px;
            flex-wrap: wrap;
        }

        .leaderboard-stat {
            font-size: 13px;
            color: #666;
        }

        .leaderboard-stat strong {
            color: var(--primary);
            font-size: 16px;
        }

        .leaderboard-score {
            text-align: center;
            padding: 15px;
            background: var(--gray-light);
            border-radius: 12px;
            min-width: 100px;
        }

        .leaderboard-score-label {
            font-size: 12px;
            color: #666;
            margin-bottom: 5px;
        }

        .leaderboard-score-value {
            font-size: 28px;
            font-weight: bold;
            color: var(--primary);
        }

        /* AI Recommendations */
        .recommendation-card {
            background: linear-gradient(135deg, rgba(113, 190, 210, 0.1), rgba(251, 181, 20, 0.1));
            border-left: 5px solid var(--accent);
            padding: 20px;
            border-radius: 12px;
            margin-bottom: 15px;
            transition: all 0.3s ease;
        }

        .recommendation-card:hover {
            transform: translateX(5px);
            box-shadow: 0 5px 15px rgba(0,0,0,0.1);
        }

        .recommendation-priority {
            display: inline-block;
            padding: 4px 12px;
            border-radius: 12px;
            font-size: 11px;
            font-weight: bold;
            margin-bottom: 10px;
        }

        .recommendation-priority.high {
            background: #dc3545;
            color: white;
        }

        .recommendation-priority.medium {
            background: #ffc107;
            color: #333;
        }

        .recommendation-priority.low {
            background: #28a745;
            color: white;
        }

        .recommendation-title {
            font-size: 18px;
            font-weight: bold;
            color: var(--primary);
            margin-bottom: 10px;
        }

        .recommendation-impact {
            display: inline-flex;
            align-items: center;
            gap: 5px;
            background: white;
            padding: 6px 12px;
            border-radius: 8px;
            font-size: 13px;
            font-weight: 600;
            color: #28a745;
            margin-top: 10px;
        }

        /* Client Segmentation Styles */
        .segmentation-container {
            background: linear-gradient(135deg, rgba(1, 49, 96, 0.03), rgba(113, 190, 210, 0.03));
            padding: 25px;
            border-radius: 15px;
            margin: 30px 0;
            border: 2px solid var(--accent);
        }

        .segmentation-header {
            text-align: center;
            margin-bottom: 30px;
        }

        .segmentation-header h2 {
            font-size: 28px;
            margin-bottom: 10px;
            color: var(--primary);
        }

        .segmentation-grid {
            display: grid;
            grid-template-columns: repeat(5, 1fr);
            gap: 20px;
            margin-bottom: 20px;
        }
        
        @media (max-width: 1400px) {
            .segmentation-grid {
                grid-template-columns: repeat(3, 1fr);
            }
        }
        
        @media (max-width: 900px) {
            .segmentation-grid {
                grid-template-columns: repeat(2, 1fr);
            }
        }
        
        @media (max-width: 600px) {
            .segmentation-grid {
                grid-template-columns: 1fr;
            }
        }

        .segment-card {
            background: white;
            border-radius: 12px;
            padding: 20px;
            box-shadow: 0 4px 12px rgba(0,0,0,0.08);
            transition: all 0.3s ease;
            border-left: 5px solid;
            position: relative;
            overflow: hidden;
        }

        .segment-card::before {
            content: '';
            position: absolute;
            top: 0;
            right: 0;
            width: 100px;
            height: 100px;
            border-radius: 50%;
            opacity: 0.05;
            transform: translate(30%, -30%);
        }

        .segment-card:hover {
            transform: translateY(-5px);
            box-shadow: 0 8px 20px rgba(0,0,0,0.12);
        }

        .segment-card.vip {
            border-left-color: #FFD700;
        }

        .segment-card.vip::before {
            background: #FFD700;
        }

        .segment-card.at-risk {
            border-left-color: #dc3545;
        }

        .segment-card.at-risk::before {
            background: #dc3545;
        }

        .segment-card.new-client {
            border-left-color: #28a745;
        }

        .segment-card.new-client::before {
            background: #28a745;
        }

        .segment-card.high-frequency {
            border-left-color: #007bff;
        }

        .segment-card.high-frequency::before {
            background: #007bff;
        }

        .segment-card.inactive-paid {
            border-left-color: #ff9800;
        }

        .segment-card.inactive-paid::before {
            background: #ff9800;
        }

        .segment-icon {
            font-size: 36px;
            margin-bottom: 10px;
        }

        .segment-title {
            font-size: 18px;
            font-weight: bold;
            color: var(--primary);
            margin-bottom: 5px;
        }

        .segment-description {
            font-size: 13px;
            color: #666;
            margin-bottom: 15px;
            min-height: 40px;
        }

        .segment-count {
            font-size: 42px;
            font-weight: bold;
            color: var(--primary);
            margin: 15px 0;
            text-align: center;
        }

        .segment-stats {
            background: var(--gray-light);
            padding: 12px;
            border-radius: 8px;
            margin-bottom: 15px;
            font-size: 13px;
        }

        .segment-stats-row {
            display: flex;
            justify-content: space-between;
            margin-bottom: 5px;
        }

        .segment-stats-row:last-child {
            margin-bottom: 0;
        }

        .segment-actions {
            display: flex;
            gap: 10px;
        }

        .segment-btn {
            flex: 1;
            padding: 10px 15px;
            border: none;
            border-radius: 8px;
            cursor: pointer;
            font-weight: bold;
            font-size: 13px;
            transition: all 0.3s ease;
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 5px;
        }

        .segment-btn.view {
            background: var(--accent);
            color: white;
        }

        .segment-btn.view:hover {
            background: #5AA8BB;
            transform: translateY(-2px);
        }

        .segment-btn.download {
            background: var(--success);
            color: white;
        }

        .segment-btn.download:hover {
            background: #218838;
            transform: translateY(-2px);
        }

        .segment-summary {
            background: white;
            padding: 20px;
            border-radius: 12px;
            margin-top: 20px;
            box-shadow: 0 4px 12px rgba(0,0,0,0.08);
        }

        .segment-summary h3 {
            color: var(--primary);
            margin-bottom: 15px;
        }

        .summary-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
            gap: 15px;
        }

        .summary-item {
            padding: 15px;
            background: var(--gray-light);
            border-radius: 8px;
            text-align: center;
        }

        .summary-label {
            font-size: 12px;
            color: #666;
            margin-bottom: 5px;
        }

        .summary-value {
            font-size: 24px;
            font-weight: bold;
            color: var(--primary);
        }

        @media print {
            .settings-btn,
            .upload-section,
            .filters,
            .tabs,
            .active-filters {
                display: none !important;
            }
            
            .tab-content {
                display: block !important;
            }
        }
    </style>
</head>
<body>
    <!-- Header Icons -->
    <div class="header-icons">
        <button class="icon-btn" id="uploadBtn" onclick="openUploadModal()" title="Upload Data">
            üìÅ
            <span class="badge" id="uploadBadge" style="display: none;">!</span>
        </button>
        <button class="icon-btn" onclick="openSettingsModal()" title="Settings">
            ‚öôÔ∏è
        </button>
    </div>

    <!-- Dashboard Header -->
    <div class="dashboard-header">
        <div class="header-content">
            <div class="logo">TVS</div>
            <div>
                <h1>The Vital Stretch</h1>
                <p class="tagline">Operational Insights Dashboard</p>
            </div>
        </div>
    </div>
    
    <div class="container">
        <!-- Empty State (shown when no data loaded) -->
        <div class="empty-state" id="emptyState">
            <div class="empty-state-icon">üìä</div>
            <h2>Welcome to The Vital Stretch Dashboard</h2>
            <p>Get started by uploading your Momence data files</p>
            <button class="icon-btn highlight" onclick="openUploadModal()" style="position: relative; width: auto; height: auto; padding: 15px 30px; border-radius: 25px; font-size: 16px; font-weight: 600;">
                üìÅ Upload Data to Get Started
            </button>
        </div>

        <!-- Main Content (hidden until data loaded) -->
        <div id="mainContent" style="display: none;">
        
        <!-- Active Filters Display -->
        <div class="active-filters" id="activeFiltersDisplay"></div>
        
        <!-- Filters -->
        <div class="filters" id="filtersSection" style="display: none;">
            <div class="collapsible-header" onclick="toggleCollapse('filtersContent', 'filtersIcon')">
                <h2>üîç Filters</h2>
                <span class="collapse-icon collapsed" id="filtersIcon">‚ñº</span>
            </div>
            <div class="collapsible-content collapsed" id="filtersContent">
                <div class="filter-grid">
                    <div class="filter-group">
                        <label for="monthFilter">Month</label>
                        <select id="monthFilter">
                            <option value="all">All Months</option>
                        </select>
                    </div>
                    <div class="filter-group">
                        <label for="locationFilter">Location</label>
                        <select id="locationFilter">
                            <option value="all">All Locations</option>
                        </select>
                    </div>
                    <div class="filter-group">
                        <label for="practitionerFilter">VSP</label>
                        <select id="practitionerFilter">
                            <option value="all">All VSPs</option>
                        </select>
                    </div>
                    <div class="filter-group">
                        <label for="serviceFilter">Service</label>
                        <select id="serviceFilter">
                            <option value="all">All Services</option>
                        </select>
                    </div>
                    <div class="filter-group">
                        <label for="startDate">Start Date</label>
                        <input type="date" id="startDate">
                    </div>
                    <div class="filter-group">
                        <label for="endDate">End Date</label>
                        <input type="date" id="endDate">
                    </div>
                    <div class="filter-group">
                        <label for="comparisonPeriod">üìä Compare To</label>
                        <select id="comparisonPeriod" onchange="toggleComparison()">
                            <option value="none">No Comparison</option>
                            <option value="previous">Previous Period</option>
                            <option value="lastMonth">Last Month</option>
                            <option value="lastQuarter">Last Quarter</option>
                            <option value="lastYear">Same Period Last Year</option>
                        </select>
                    </div>
                </div>
                <div class="quick-filters">
                    <button class="quick-filter-btn" onclick="setQuickFilter('7days')">Last 7 Days</button>
                    <button class="quick-filter-btn" onclick="setQuickFilter('30days')">Last 30 Days</button>
                    <button class="quick-filter-btn" onclick="setQuickFilter('90days')">Last 90 Days</button>
                    <button class="quick-filter-btn" onclick="setQuickFilter('thisMonth')">This Month</button>
                    <button class="quick-filter-btn" onclick="setQuickFilter('lastMonth')">Last Month</button>
                    <button class="quick-filter-btn" onclick="setQuickFilter('reset')" style="background: #dc3545; color: white; font-weight: bold; border: 2px solid #fff;">üîÑ RESET ALL FILTERS</button>
                </div>
                <div style="text-align: center;">
                    <button class="refresh-filter-btn" onclick="refreshData()">üîÑ Refresh Data</button>
                </div>
            </div>
        </div>
        
        <!-- Main Tabs -->
        <div class="tabs" id="mainTabs" style="display: none;">
            <div class="tab active" onclick="switchTab('overview')">Overview</div>
            <div class="tab" onclick="switchTab('timeline')">Timeline</div>
            <div class="tab" onclick="switchTab('practitioners')">VSP</div>
            <div class="tab" onclick="switchTab('customers')">Customers</div>
            <div class="tab" onclick="switchTab('leads')">Leads</div>
            <div class="tab" onclick="switchTab('studios')">Studios</div>
            <div class="tab" onclick="switchTab('journey')">Journey</div>
            <div class="tab" onclick="switchTab('memberships')">Memberships</div>
            <div class="tab" onclick="switchTab('schedule')">Schedule</div>
            <div class="tab" onclick="switchTab('insights')">Insights</div>
        </div>
        
        <!-- Tab Contents -->
        <div id="overview" class="tab-content active"></div>
        <div id="memberships" class="tab-content"></div>
        <div id="leads" class="tab-content"></div>
        <div id="journey" class="tab-content"></div>
        <div id="studios" class="tab-content"></div>
        <div id="schedule" class="tab-content"></div>
        <div id="customers" class="tab-content"></div>
        <div id="practitioners" class="tab-content"></div>
        <div id="timeline" class="tab-content"></div>
        <div id="insights" class="tab-content"></div>
        </div> <!-- end mainContent -->
    </div>
    
    <!-- Upload Modal -->
    <div class="upload-modal-overlay" id="uploadModal">
        <div class="upload-modal-content">
            <div class="modal-header-custom">
                <h3>üìÅ Upload Data Files</h3>
                <button class="modal-close-custom" onclick="closeUploadModal()">√ó</button>
            </div>
            <div class="modal-body-custom">
                <p style="text-align: center; margin-bottom: 10px; color: #666; font-size: 13px;">
                    Upload your Momence exports to start analyzing your franchise performance
                </p>
                
                <!-- Notices Side-by-Side -->
                <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 10px; margin-bottom: 15px;">
                    <!-- Future Date Filter Notice -->
                    <div style="padding: 6px; background: #f0f9ff; border-radius: 6px; border: 1px solid #bae6fd; text-align: center;">
                        <span style="color: #0369a1; font-size: 11px;">üîÆ Future bookings excluded from appointments & VSP stats</span>
                    </div>
                    
                    <!-- Date Filter Status Indicator -->
                    <div id="dateFilterStatus" style="padding: 6px; background: var(--gray-light); border-radius: 6px; text-align: center; display: none;">
                        <span style="color: var(--warning); font-weight: 600; font-size: 11px;">‚ö†Ô∏è Date Filter: Excluding data before <span id="dateFilterDisplay"></span></span>
                    </div>
                </div>
                
                <div style="display: grid; grid-template-columns: 1fr 1fr 1fr 1fr; gap: 14px; margin-bottom: 14px;">
                    <div class="upload-box">
                        <h3>üì¶ Payroll Zip</h3>
                        <p style="font-size: 8px; color: #666; margin: 7px 0;">All employee payroll files</p>
                        <input type="file" id="payrollZipFile" accept=".zip" style="display: none;">
                        <label for="payrollZipFile" class="upload-btn">Choose Zip File</label>
                        <div class="upload-status" id="payrollZipStatus"></div>
                    </div>
                    
                    <div class="upload-box">
                        <h3>üìã Attendance Report</h3>
                        <p style="font-size: 8px; color: #666; margin: 7px 0;">VSP attendance & name mapping (ZIP or CSV)</p>
                        <input type="file" id="attendanceZipFile" accept=".zip,.csv" style="display: none;">
                        <label for="attendanceZipFile" class="upload-btn">Choose File</label>
                        <div class="upload-status" id="attendanceZipStatus"></div>
                    </div>
                    
                    <div class="upload-box">
                        <h3>üí≥ Memberships</h3>
                        <p style="font-size: 8px; color: #666; margin: 7px 0;">Sales, cancellations & frozen</p>
                        <input type="file" id="membershipsFile" accept=".csv" multiple style="display: none;">
                        <label for="membershipsFile" class="upload-btn">Choose File(s)</label>
                        <div class="upload-status" id="membershipsStatus"></div>
                    </div>
                    
                    <div class="upload-box">
                        <h3>üë• Leads</h3>
                        <p style="font-size: 8px; color: #666; margin: 7px 0;">Leads, customers & conversions</p>
                        <input type="file" id="leadsFile" accept=".csv" multiple style="display: none;">
                        <label for="leadsFile" class="upload-btn">Choose File(s)</label>
                        <div class="upload-status" id="leadsStatus"></div>
                        <input type="file" id="leadsConvertedFile" accept=".csv" style="display: none;">
                        <div class="upload-status" id="leadsConvertedStatus"></div>
                    </div>
                </div>
                
                <!-- Second Row: Magic Upload (can expand down) -->
                <div style="display: grid; grid-template-columns: 1fr 1fr 1fr 1fr; gap: 14px;">
                    <div style="grid-column: span 4;">
                        <!-- Magic Upload Section -->
                        <div style="padding: 12px; background: linear-gradient(135deg, rgba(251, 181, 20, 0.1), rgba(251, 181, 20, 0.05)); border: 2px dashed var(--highlight); border-radius: 7px;">
                            <h3 style="margin: 0 0 5px 0; color: var(--highlight); font-size: 14px;">‚ú® Experimental Magic Upload</h3>
                            <p style="font-size: 10px; color: #666; margin: 0 0 8px 0;">
                                Upload multiple files at once and let the dashboard automatically detect and load them!
                            </p>
                            <input type="file" id="magicUploadFile" accept=".csv,.zip" multiple style="display: none;">
                            <label for="magicUploadFile" class="upload-btn" style="background: var(--highlight); color: var(--primary); font-weight: bold; padding: 8px 16px; font-size: 13px;">
                                ü™Ñ Choose Files (Magic Mode)
                            </label>
                            <div class="upload-status" id="magicUploadStatus" style="margin-top: 7px;"></div>
                        </div>
                    </div>
                </div>
                
                <div style="margin-top: 15px; padding: 8px; background: var(--gray-light); border-radius: 5px;">
                    <p style="font-size: 9px; color: #666; margin: 0 0 4px 0;">
                        <strong>üí° Tip:</strong> For memberships & leads, you can upload multiple files together. The dashboard will automatically detect and process them correctly.
                    </p>
                    <p style="font-size: 9px; color: #666; margin: 0;">
                        <strong>üìù Note:</strong> Memberships are identified by having "Hours/Month" in the name. Renewals are automatically credited to the original seller.
                    </p>
                </div>
            </div>
        </div>
    </div>

    <!-- Settings Modal -->
    <div class="settings-modal-overlay" id="settingsModal">
        <div class="settings-modal-content">
            <div class="modal-header-custom">
                <h3>‚öôÔ∏è Franchise Settings</h3>
                <button class="modal-close-custom" onclick="closeSettingsModal()">√ó</button>
            </div>
            <div class="modal-body-custom">
                <div style="display: grid; grid-template-columns: repeat(auto-fit, minmax(280px, 1fr)); gap: 20px; margin-bottom: 20px;">
                    
                    <!-- Timezone -->
                    <div style="background: var(--gray-light); padding: 20px; border-radius: 10px; border-left: 4px solid var(--highlight);">
                        <label style="display: block; font-weight: 600; color: var(--primary); margin-bottom: 8px;">
                            üåç Timezone
                        </label>
                        <p style="font-size: 13px; color: #666; margin-bottom: 10px;">
                            Your local timezone for date/time conversions
                        </p>
                        <select id="timezoneSelect" style="width: 100%; padding: 12px; border: 2px solid var(--accent); border-radius: 8px; font-size: 16px; font-weight: 600;">
                            <option value="America/New_York">Eastern Time</option>
                            <option value="America/Chicago" selected>Central Time</option>
                            <option value="America/Denver">Mountain Time</option>
                            <option value="Pacific/Honolulu">Hawaii Time</option>
                        </select>
                    </div>
                    
                    <!-- Momence Host ID -->
                    <div style="background: var(--gray-light); padding: 20px; border-radius: 10px; border-left: 4px solid var(--highlight);">
                        <label style="display: block; font-weight: 600; color: var(--primary); margin-bottom: 8px;">
                            üîó Momence Host ID
                        </label>
                        <p style="font-size: 13px; color: #666; margin-bottom: 10px;">
                            Your Momence Host ID for customer deep links (e.g., "49534")
                        </p>
                        <input type="text" id="momenceHostId" 
                            style="width: 100%; padding: 12px; border: 2px solid var(--accent); border-radius: 8px; font-size: 14px; font-weight: 600;">
                    </div>
                    
                    <!-- Not Before Date -->
                    <div style="background: var(--gray-light); padding: 20px; border-radius: 10px; border-left: 4px solid var(--warning);">
                        <label style="display: block; font-weight: 600; color: var(--primary); margin-bottom: 8px;">
                            üìÖ Data Start Date ("Not Before")
                        </label>
                        <p style="font-size: 13px; color: #666; margin-bottom: 10px;">
                            Exclude all data (except Leads) before this date. Useful for filtering out pre-opening data from studios.
                        </p>
                        <input type="date" id="notBeforeDate" 
                            style="width: 100%; padding: 12px; border: 2px solid var(--accent); border-radius: 8px; font-size: 16px; font-weight: 600;">
                        <p style="font-size: 12px; color: #999; margin-top: 8px; font-style: italic;">
                            üí° Leave blank to include all data
                        </p>
                    </div>
                    
                    <!-- Franchise Fee -->
                    <div style="background: var(--gray-light); padding: 20px; border-radius: 10px; border-left: 4px solid var(--accent);">
                        <label style="display: block; font-weight: 600; color: var(--primary); margin-bottom: 8px;">
                            üè¢ Franchise Fee
                        </label>
                        <p style="font-size: 13px; color: #666; margin-bottom: 10px;">
                            Percentage of revenue paid as franchise fee
                        </p>
                        <input type="number" id="franchiseFeePercent" value="7.0" min="0" max="100" step="0.1" 
                            style="width: 100%; padding: 12px; border: 2px solid var(--accent); border-radius: 8px; font-size: 16px; font-weight: 600;">
                    </div>
                    
                    <!-- Brand Fund -->
                    <div style="background: var(--gray-light); padding: 20px; border-radius: 10px; border-left: 4px solid var(--accent);">
                        <label style="display: block; font-weight: 600; color: var(--primary); margin-bottom: 8px;">
                            üéØ Brand Fund
                        </label>
                        <p style="font-size: 13px; color: #666; margin-bottom: 10px;">
                            Percentage of revenue for brand marketing
                        </p>
                        <input type="number" id="brandFundPercent" value="1.5" min="0" max="100" step="0.1" 
                            style="width: 100%; padding: 12px; border: 2px solid var(--accent); border-radius: 8px; font-size: 16px; font-weight: 600;">
                    </div>
                    
                    <!-- CC Processing -->
                    <div style="background: var(--gray-light); padding: 20px; border-radius: 10px; border-left: 4px solid var(--accent);">
                        <label style="display: block; font-weight: 600; color: var(--primary); margin-bottom: 8px;">
                            üí≥ CC Processing Fees
                        </label>
                        <p style="font-size: 13px; color: #666; margin-bottom: 10px;">
                            Credit card processing fee percentage
                        </p>
                        <input type="number" id="ccFeesPercent" value="2.9" min="0" max="100" step="0.1" 
                            style="width: 100%; padding: 12px; border: 2px solid var(--accent); border-radius: 8px; font-size: 16px; font-weight: 600;">
                    </div>
                    
                    <!-- Monthly Paid Appointments Goal -->
                    <div style="background: var(--gray-light); padding: 20px; border-radius: 10px; border-left: 4px solid var(--primary);">
                        <label style="display: block; font-weight: 600; color: var(--primary); margin-bottom: 8px;">
                            üéØ Monthly Paid Appointments Goal
                        </label>
                        <p style="font-size: 13px; color: #666; margin-bottom: 10px;">
                            Target for paid, non-intro appointments per month
                        </p>
                        <input type="number" id="monthlyPaidApptGoal" value="300" min="0" step="1" 
                            style="width: 100%; padding: 12px; border: 2px solid var(--accent); border-radius: 8px; font-size: 16px; font-weight: 600;">
                    </div>
                    
                    <!-- Monthly Intro Appointments Goal -->
                    <div style="background: var(--gray-light); padding: 20px; border-radius: 10px; border-left: 4px solid var(--primary);">
                        <label style="display: block; font-weight: 600; color: var(--primary); margin-bottom: 8px;">
                            üÜï Monthly Intro Appointments Goal
                        </label>
                        <p style="font-size: 13px; color: #666; margin-bottom: 10px;">
                            Target for intro appointments per month
                        </p>
                        <input type="number" id="monthlyIntroApptGoal" value="36" min="0" step="1" 
                            style="width: 100%; padding: 12px; border: 2px solid var(--accent); border-radius: 8px; font-size: 16px; font-weight: 600;">
                    </div>
                    
                    <!-- Monthly Revenue Goal -->
                    <div style="background: var(--gray-light); padding: 20px; border-radius: 10px; border-left: 4px solid var(--primary);">
                        <label style="display: block; font-weight: 600; color: var(--primary); margin-bottom: 8px;">
                            üí∞ Monthly Revenue Goal
                        </label>
                        <p style="font-size: 13px; color: #666; margin-bottom: 10px;">
                            Target monthly revenue
                        </p>
                        <input type="number" id="monthlyRevenueGoal" value="50000" min="0" step="1000" 
                            style="width: 100%; padding: 12px; border: 2px solid var(--accent); border-radius: 8px; font-size: 16px; font-weight: 600;">
                    </div>
                    
                    <!-- Base Hourly Rate -->
                    <div style="background: var(--gray-light); padding: 20px; border-radius: 10px; border-left: 4px solid var(--highlight);">
                        <label style="display: block; font-weight: 600; color: var(--primary); margin-bottom: 8px;">
                            üíµ Base Hourly Rate
                        </label>
                        <p style="font-size: 13px; color: #666; margin-bottom: 10px;">
                            Hourly rate for non-appointment work
                        </p>
                        <input type="number" id="baseRateInput" value="13" min="0" step="0.50" 
                            style="width: 100%; padding: 12px; border: 2px solid var(--accent); border-radius: 8px; font-size: 16px; font-weight: 600;">
                    </div>
                    
                    <!-- LTV Distribution Tiers -->
                    <div style="background: var(--gray-light); padding: 20px; border-radius: 10px; border-left: 4px solid var(--primary);">
                        <label style="display: block; font-weight: 600; color: var(--primary); margin-bottom: 8px;">
                            üíé LTV Distribution Tiers
                        </label>
                        <p style="font-size: 13px; color: #666; margin-bottom: 10px;">
                            Customer value segmentation (VIP = highest tier)
                        </p>
                        <select id="ltvTiersSelect" style="width: 100%; padding: 12px; border: 2px solid var(--accent); border-radius: 8px; font-size: 14px; font-weight: 600;">
                            <option value="default">Tier 1: Up to $1K+ VIP (Default)</option>
                            <option value="tier2">Tier 2: Up to $2K+ VIP</option>
                            <option value="tier3">Tier 3: Up to $3K+ VIP</option>
                            <option value="tier4">Tier 4: Up to $4K+ VIP</option>
                            <option value="tier5">Tier 5: Up to $5K+ VIP</option>
                        </select>
                        <div style="font-size: 11px; color: #666; margin-top: 5px;">
                            <strong>Selected tier ranges:</strong><br>
                            <span id="ltvTierPreview">$1‚Äì$50, $50‚Äì$150, $150‚Äì$300, $300‚Äì$500, $500‚Äì$1K, $1K+</span>
                        </div>
                    </div>
                </div>
                
                <!-- Salaried Employees Section -->
                <div style="margin-top: 30px; padding: 25px; background: linear-gradient(135deg, #f8f9fa 0%, #e9ecef 100%); border-radius: 12px; border: 2px solid var(--accent);">
                    <h4 style="color: var(--primary); margin-bottom: 15px; display: flex; align-items: center; gap: 10px;">
                        <span style="font-size: 24px;">üëî</span> Salaried Employees
                    </h4>
                    <p style="font-size: 13px; color: #666; margin-bottom: 20px;">
                        Track up to 3 salaried employees. Enter their annual salary and start date for accurate labor cost calculations.
                    </p>
                    
                    <div style="display: grid; gap: 20px;">
                        <!-- Employee 1 -->
                        <div style="background: white; padding: 20px; border-radius: 10px; border-left: 4px solid var(--primary);">
                            <h5 style="color: var(--primary); margin-bottom: 15px;">Employee 1</h5>
                            <div style="display: grid; grid-template-columns: 2fr 1fr 1fr; gap: 15px;">
                                <div>
                                    <label style="display: block; font-weight: 600; color: #555; margin-bottom: 5px; font-size: 13px;">Name</label>
                                    <input type="text" id="salaryEmp1Name" placeholder="Employee name" 
                                        style="width: 100%; padding: 10px; border: 2px solid #ddd; border-radius: 6px; font-size: 14px;">
                                </div>
                                <div>
                                    <label style="display: block; font-weight: 600; color: #555; margin-bottom: 5px; font-size: 13px;">Annual Salary</label>
                                    <input type="number" id="salaryEmp1Salary" placeholder="0" min="0" step="1000" 
                                        style="width: 100%; padding: 10px; border: 2px solid #ddd; border-radius: 6px; font-size: 14px;">
                                </div>
                                <div>
                                    <label style="display: block; font-weight: 600; color: #555; margin-bottom: 5px; font-size: 13px;">Start Date</label>
                                    <input type="date" id="salaryEmp1StartDate" 
                                        style="width: 100%; padding: 10px; border: 2px solid #ddd; border-radius: 6px; font-size: 14px;">
                                </div>
                            </div>
                        </div>
                        
                        <!-- Employee 2 -->
                        <div style="background: white; padding: 20px; border-radius: 10px; border-left: 4px solid var(--accent);">
                            <h5 style="color: var(--primary); margin-bottom: 15px;">Employee 2</h5>
                            <div style="display: grid; grid-template-columns: 2fr 1fr 1fr; gap: 15px;">
                                <div>
                                    <label style="display: block; font-weight: 600; color: #555; margin-bottom: 5px; font-size: 13px;">Name</label>
                                    <input type="text" id="salaryEmp2Name" placeholder="Employee name" 
                                        style="width: 100%; padding: 10px; border: 2px solid #ddd; border-radius: 6px; font-size: 14px;">
                                </div>
                                <div>
                                    <label style="display: block; font-weight: 600; color: #555; margin-bottom: 5px; font-size: 13px;">Annual Salary</label>
                                    <input type="number" id="salaryEmp2Salary" placeholder="0" min="0" step="1000" 
                                        style="width: 100%; padding: 10px; border: 2px solid #ddd; border-radius: 6px; font-size: 14px;">
                                </div>
                                <div>
                                    <label style="display: block; font-weight: 600; color: #555; margin-bottom: 5px; font-size: 13px;">Start Date</label>
                                    <input type="date" id="salaryEmp2StartDate" 
                                        style="width: 100%; padding: 10px; border: 2px solid #ddd; border-radius: 6px; font-size: 14px;">
                                </div>
                            </div>
                        </div>
                        
                        <!-- Employee 3 -->
                        <div style="background: white; padding: 20px; border-radius: 10px; border-left: 4px solid var(--highlight);">
                            <h5 style="color: var(--primary); margin-bottom: 15px;">Employee 3</h5>
                            <div style="display: grid; grid-template-columns: 2fr 1fr 1fr; gap: 15px;">
                                <div>
                                    <label style="display: block; font-weight: 600; color: #555; margin-bottom: 5px; font-size: 13px;">Name</label>
                                    <input type="text" id="salaryEmp3Name" placeholder="Employee name" 
                                        style="width: 100%; padding: 10px; border: 2px solid #ddd; border-radius: 6px; font-size: 14px;">
                                </div>
                                <div>
                                    <label style="display: block; font-weight: 600; color: #555; margin-bottom: 5px; font-size: 13px;">Annual Salary</label>
                                    <input type="number" id="salaryEmp3Salary" placeholder="0" min="0" step="1000" 
                                        style="width: 100%; padding: 10px; border: 2px solid #ddd; border-radius: 6px; font-size: 14px;">
                                </div>
                                <div>
                                    <label style="display: block; font-weight: 600; color: #555; margin-bottom: 5px; font-size: 13px;">Start Date</label>
                                    <input type="date" id="salaryEmp3StartDate" 
                                        style="width: 100%; padding: 10px; border: 2px solid #ddd; border-radius: 6px; font-size: 14px;">
                                </div>
                            </div>
                        </div>
                    </div>
                </div>
                
                <div style="text-align: center; margin-top: 20px;">
                    <button onclick="saveFranchiseSettings()" class="upload-btn" style="min-width: 250px; font-size: 16px;">
                        üíæ Save Settings
                    </button>
                    <div id="franchiseSettingsStatus" style="margin-top: 15px; min-height: 20px; font-weight: 600;"></div>
                </div>
            </div>
        </div>
    </div>
    
    <!-- Data Detail Modal -->
    <div class="modal-overlay" id="dataModal" onclick="closeModal()">
        <div class="modal-content" onclick="event.stopPropagation()">
            <div class="modal-header">
                <h3 id="modalTitle">Data Details</h3>
                <button class="modal-close" onclick="closeModal()">√ó</button>
            </div>
            <div class="modal-body" id="modalBody">
                <!-- Dynamic content will be inserted here -->
            </div>
        </div>
    </div>
    
    <script>
        /* =====================================================
         * PERFORMANCE OPTIMIZATIONS IMPLEMENTED:
         * =====================================================
         * 1. Lazy Tab Loading: Tabs render only when clicked
         * 2. Memoized Date Parsing: Caches parsed dates
         * 3. Chart Helper Functions: Reduces duplicate code
         * 4. Tab State Tracking: Prevents re-rendering
         * 5. Efficient Filtering: Optimized data processing
         * ===================================================== */
        
        // Toggle collapsible sections
        function toggleCollapse(contentId, iconId) {
            const content = document.getElementById(contentId);
            const icon = document.getElementById(iconId);
            
            content.classList.toggle('collapsed');
            icon.classList.toggle('collapsed');
        }
        
        // Modal functions
        let currentModalData = null;
        
        function showModal(title, content, exportData = null) {
            document.getElementById('modalTitle').textContent = title;
            document.getElementById('modalBody').innerHTML = content;
            document.getElementById('dataModal').classList.add('show');
            document.body.style.overflow = 'hidden';
            
            // Store export data for the export button
            currentModalData = exportData;
            
            // Add export button if data is provided
            const modalHeader = document.querySelector('.modal-header');
            let exportBtn = document.getElementById('modalExportBtn');
            if (exportData && exportData.length > 0) {
                if (!exportBtn) {
                    exportBtn = document.createElement('button');
                    exportBtn.id = 'modalExportBtn';
                    exportBtn.textContent = 'üì• Export CSV';
                    exportBtn.style.cssText = 'padding: 8px 16px; background: var(--accent); color: white; border: none; border-radius: 5px; cursor: pointer; margin-left: 10px;';
                    exportBtn.onclick = exportModalData;
                    modalHeader.insertBefore(exportBtn, modalHeader.querySelector('.modal-close'));
                }
                exportBtn.style.display = 'inline-block';
            } else if (exportBtn) {
                exportBtn.style.display = 'none';
            }
        }
        
        function exportModalData() {
            if (currentModalData && currentModalData.length > 0) {
                const filename = 'modal-data-' + new Date().toISOString().split('T')[0] + '.csv';
                exportToCSV(currentModalData, filename);
            }
        }
        
        function closeModal() {
            const modal = document.getElementById('dataModal');
            modal.classList.remove('show');
            modal.style.display = ''; // Clear any inline display styles
            document.body.style.overflow = 'auto';
            currentModalData = null;
        }
        
        // Escape key to close modal
        document.addEventListener('keydown', function(e) {
            if (e.key === 'Escape') {
                closeModal();
            }
        });
        
        // CSV Export Function
        function exportToCSV(data, filename) {
            if (!data || data.length === 0) {
                alert('No data to export');
                return;
            }
            
            // Get headers from first object
            const headers = Object.keys(data[0]);
            
            // Create CSV content
            let csv = headers.join(',') + '\n';
            
            data.forEach(row => {
                const values = headers.map(header => {
                    let value = row[header];
                    
                    // Handle values with commas or quotes
                    if (typeof value === 'string' && (value.includes(',') || value.includes('"') || value.includes('\n'))) {
                        value = '"' + value.replace(/"/g, '""') + '"';
                    }
                    
                    return value;
                });
                csv += values.join(',') + '\n';
            });
            
            // Create download link
            const blob = new Blob([csv], { type: 'text/csv;charset=utf-8;' });
            const link = document.createElement('a');
            const url = URL.createObjectURL(blob);
            
            link.setAttribute('href', url);
            link.setAttribute('download', filename);
            link.style.visibility = 'hidden';
            
            document.body.appendChild(link);
            link.click();
            document.body.removeChild(link);
        }
        
        // Show LTV distribution details
        function showLTVDetails(range, customers) {



            // Get current tier configuration
            const currentTierConfig = LTV_TIERS[CONFIG.ltvTiers];
            const ranges = currentTierConfig.ranges;

            // Helper function to parse K values
            const parseValue = (str) => {
                str = str.replace('$', '').trim();
                if (str.includes('K')) {
                    return parseFloat(str.replace('K', '')) * 1000;
                }
                return parseFloat(str);
            };

            // Filter customers based on the range label
            const customersInRange = filteredLeads.filter(customer => {
                const ltv = parseLTV(customer.LTV);
                
                // Skip zero LTV
                if (ltv <= 0) return false;
                
                // Check if this is the VIP tier (has +)
                if (range.includes('+')) {
                    const result = ltv > ranges[4];
                    if (result && customer['E-mail'] && customer['E-mail'].toLowerCase().includes('cdahl')) {

                    }
                    return result;
                }
                
                // Parse the range from the label (e.g., "$1-$100" or "$1K-$2K")
                const parts = range.split('-');
                if (parts.length === 2) {
                    const lower = parseValue(parts[0]);
                    const upper = parseValue(parts[1]);
                    
                    // First tier starts at $1 (i.e., > 0)
                    if (lower === 1) {
                        return ltv > 0 && ltv <= upper;
                    } else {
                        return ltv > lower && ltv <= upper;
                    }
                }
                
                return false;
            });

            // Check if Chris Dahl is in the results
            const chrisInResults = customersInRange.find(c => c['E-mail'] && c['E-mail'].toLowerCase().includes('cdahl'));
            if (chrisInResults) {

            } else {

            }
            
            // Get detailed info for each customer
            const customersWithDetails = customersInRange.map(c => {
                const customerEmail = c['E-mail'];
                const customerAppointments = filteredAppointments.filter(a => a['Customer Email'] === customerEmail);
                
                // Get latest appointment date
                let latestDate = null;
                customerAppointments.forEach(a => {
                    const apptDate = parseDate(a['Appointment Date']);
                    if (apptDate && (!latestDate || apptDate > latestDate)) {
                        latestDate = apptDate;
                    }
                });
                
                // Get practitioner counts
                const practitionerCounts = {};
                customerAppointments.forEach(a => {
                    const firstName = a['Practitioner First Name'];
                    const lastName = a['Practitioner Last Name'];
                    if (firstName && lastName) {
                        const key = `${firstName} ${lastName}`;
                        practitionerCounts[key] = (practitionerCounts[key] || 0) + 1;
                    }
                });
                
                // Format practitioners as "First L. (count)"
                const practitionerList = Object.entries(practitionerCounts)
                    .sort((a, b) => b[1] - a[1]) // Sort by count descending
                    .map(([name, count]) => {
                        const parts = name.split(' ');
                        const firstName = parts[0];
                        const lastInitial = parts[1] ? parts[1].charAt(0) + '.' : '';
                        return `${firstName} ${lastInitial} (${count})`;
                    })
                    .join(', ');
                
                return {
                    ...c,
                    latestDate: latestDate,
                    latestDateStr: latestDate ? latestDate.toLocaleDateString('en-US') : 'N/A',
                    practitionerList: practitionerList || 'N/A',
                    joinDateStr: c['Join date'] ? c['Join date'].split(',')[0] : 'N/A'
                };
            });
            
            // Sort by latest appointment date descending (most recent first)
            customersWithDetails.sort((a, b) => {
                if (!a.latestDate) return 1;
                if (!b.latestDate) return -1;
                return b.latestDate - a.latestDate;
            });
            
            const totalLTV = customersWithDetails.reduce((sum, c) => sum + parseLTV(c.LTV), 0);
            const avgLTV = customersWithDetails.length > 0 ? totalLTV / customersWithDetails.length : 0;
            
            let tableRows = customersWithDetails.slice(0, 50).map(c => {
                const customerName = `${c['First name'] || ''} ${c['Last name'] || ''}`;
                const momenceLink = getMomenceCustomerLink(c['E-mail'], customerName);
                return `
                <tr>
                    <td class="name-cell" data-tooltip="Joined: ${c.joinDateStr}">${customerName}${momenceLink}</td>
                    <td>${formatCurrency(parseLTV(c.LTV))}</td>
                    <td>${c.latestDateStr}</td>
                    <td>${c.practitionerList}</td>
                </tr>
            `;
            }).join('');
            
            if (customersWithDetails.length > 50) {
                tableRows += `<tr><td colspan="4" style="text-align: center; color: #666; font-style: italic;">Showing first 50 of ${customersWithDetails.length} customers</td></tr>`;
            }
            
            // Prepare CSV data
            const csvData = customersWithDetails.map(c => ({
                'Name': `${c['First name'] || ''} ${c['Last name'] || ''}`,
                'LTV': parseLTV(c.LTV),
                'Latest Visit': c.latestDateStr,
                'Join Date': c.joinDateStr,
                'Practitioners': c.practitionerList
            }));
            
            const content = `
                <div class="modal-highlight">
                    <strong>LTV Range:</strong> ${range}<br>
                    <strong>Total Customers:</strong> ${customersWithDetails.length}<br>
                    <strong>Average LTV:</strong> ${formatCurrency(avgLTV)}<br>
                    <strong>Total Revenue:</strong> ${formatCurrency(totalLTV)}
                </div>
                
                <div class="modal-section">
                    <h4>Customer Details</h4>
                    <p style="font-size: 12px; color: #999; margin: -10px 0 10px 0; font-style: italic;">‚Üì Sorted by Latest Visit (Most Recent First) | üí° Hover over names for join date</p>
                    <table class="modal-table">
                        <thead>
                            <tr>
                                <th>Name</th>
                                <th>LTV</th>
                                <th>Latest Visit</th>
                                <th>Practitioner(s)</th>
                            </tr>
                        </thead>
                        <tbody>
                            ${tableRows}
                        </tbody>
                    </table>
                    <button class="csv-export-btn" onclick='exportToCSV(${JSON.stringify(csvData)}, "ltv-distribution-${range.replace(/[^a-zA-Z0-9]/g, '-')}.csv")'>
                        Export to CSV
                    </button>
                </div>
            `;
            
            showModal(`LTV Distribution: ${range}`, content);
        }
        
        // Show visit frequency details
        function showVisitFrequencyDetails(range, count) {
            const clientVisits = {};
            const activeMemberEmails = getActiveMemberEmails();
            
            filteredAppointments.forEach(row => {
                const email = row['Customer Email'];
                if (email) {
                    clientVisits[email] = (clientVisits[email] || 0) + 1;
                }
            });
            
            let clientsInRange = [];
            Object.entries(clientVisits).forEach(([email, visits]) => {
                let inRange = false;
                // Match the keys from visitDist: '1 visit', '2-3 visits', '4-6 visits', '7-10 visits', '11+ visits'
                if (range === '1 visit' && visits === 1) inRange = true;
                else if (range === '2-3 visits' && visits >= 2 && visits <= 3) inRange = true;
                else if (range === '4-6 visits' && visits >= 4 && visits <= 6) inRange = true;
                else if (range === '7-10 visits' && visits >= 7 && visits <= 10) inRange = true;
                else if (range === '11+ visits' && visits > 10) inRange = true;
                
                if (inRange) {
                    const appointments = filteredAppointments.filter(a => a['Customer Email'] === email);
                    // Calculate revenue excluding if they are an active member
                    const customerEmail = email.toLowerCase().trim();
                    const revenue = activeMemberEmails.has(customerEmail) ? 0 : 
                        appointments.reduce((sum, a) => sum + (parseFloat(a.Revenue) || 0), 0);
                    const customerName = appointments[0]?.['Customer Name'] || 'Unknown';
                    const lastVisitDate = appointments[appointments.length - 1]?.['Appointment Date'] || 'N/A';
                    
                    clientsInRange.push({
                        email,
                        name: customerName,
                        visits,
                        revenue,
                        lastVisit: lastVisitDate,
                        lastVisitDate: parseDate(lastVisitDate)
                    });
                }
            });
            
            // Sort by revenue descending by default
            clientsInRange.sort((a, b) => b.revenue - a.revenue);
            
            const totalRevenue = clientsInRange.reduce((sum, c) => sum + c.revenue, 0);
            const avgRevenue = clientsInRange.length > 0 ? totalRevenue / clientsInRange.length : 0;
            
            // Format range display
            const rangeDisplay = range; // Use the range as-is since it's already formatted
            
            let tableRows = '';
            if (clientsInRange.length === 0) {
                tableRows = '<tr><td colspan="4" style="text-align: center; color: #999; padding: 30px;">No clients found in this range</td></tr>';
            } else {
                tableRows = clientsInRange.slice(0, 50).map(c => {
                    const momenceLink = getMomenceCustomerLink(c.email, c.name);
                    return `
                    <tr>
                        <td>${c.name}${momenceLink}</td>
                        <td>${c.visits}</td>
                        <td>${formatCurrency(c.revenue)}</td>
                        <td>${c.lastVisit.split(',')[0] || 'N/A'}</td>
                    </tr>
                `;
                }).join('');
                
                if (clientsInRange.length > 50) {
                    tableRows += `<tr><td colspan="4" style="text-align: center; color: #666; font-style: italic;">Showing first 50 of ${clientsInRange.length} clients</td></tr>`;
                }
            }
            
            // Prepare CSV data
            const csvData = clientsInRange.map(c => ({
                'Name': c.name,
                'Email': c.email,
                'Visits': c.visits,
                'Revenue': c.revenue,
                'Last Visit': c.lastVisit.split(',')[0] || 'N/A'
            }));
            
            const content = `
                <div class="modal-highlight">
                    <strong>Visit Range:</strong> ${rangeDisplay}<br>
                    <strong>Total Clients:</strong> ${clientsInRange.length}<br>
                    <strong>Total Revenue:</strong> ${formatCurrency(totalRevenue)}<br>
                    <strong>Average Revenue per Client:</strong> ${formatCurrency(avgRevenue)}
                </div>
                
                <div class="modal-section">
                    <h4>Client Details</h4>
                    <p style="font-size: 12px; color: #999; margin: -10px 0 10px 0; font-style: italic;">‚Üì Sorted by Revenue (Highest First)</p>
                    <table class="modal-table">
                        <thead>
                            <tr>
                                <th>Name</th>
                                <th>Visits</th>
                                <th>Revenue</th>
                                <th>Last Visit</th>
                            </tr>
                        </thead>
                        <tbody>
                            ${tableRows}
                        </tbody>
                    </table>
                    ${clientsInRange.length > 0 ? `<button class="csv-export-btn" onclick='exportToCSV(${JSON.stringify(csvData)}, "visit-frequency-${range.replace(/[^a-zA-Z0-9]/g, '-')}.csv")'>
                        Export to CSV
                    </button>` : ''}
                </div>
            `;
            
            showModal(`Visit Frequency: ${rangeDisplay}`, content);
        }
        
        // Show practitioner details
        function showPractitionerDetails(practitionerName) {
            const appointments = filteredAppointments.filter(row => {
                return `${row['Practitioner First Name']} ${row['Practitioner Last Name']}` === practitionerName;
            });
            
            const revenue = appointments.reduce((sum, a) => sum + (parseFloat(a.Revenue) || 0), 0);
            const payout = appointments.reduce((sum, a) => sum + (parseFloat(a['Total Payout']) || 0), 0);
            const uniqueClients = new Set(appointments.map(a => a['Customer Email'])).size;
            
            // Service breakdown
            const services = {};
            appointments.forEach(a => {
                const service = a.Appointment;
                if (!services[service]) {
                    services[service] = { count: 0, revenue: 0 };
                }
                services[service].count++;
                services[service].revenue += parseFloat(a.Revenue) || 0;
            });
            
            const sortedServices = Object.entries(services)
                .sort((a, b) => b[1].count - a[1].count)
                .slice(0, 10);
            
            const serviceRows = sortedServices.map(([service, data]) => `
                <tr>
                    <td>${service}</td>
                    <td>${data.count}</td>
                    <td>${formatCurrency(data.revenue)}</td>
                    <td>${formatCurrency(data.revenue / data.count)}</td>
                </tr>
            `).join('');
            
            // Prepare CSV data
            const csvData = sortedServices.map(([service, data]) => ({
                'Service': service,
                'Count': data.count,
                'Revenue': data.revenue,
                'Avg per Appt': data.revenue / data.count
            }));
            
            const content = `
                <div class="modal-highlight">
                    <strong>Practitioner:</strong> ${practitionerName}<br>
                    <strong>Total Appointments:</strong> ${appointments.length}<br>
                    <strong>Unique Clients:</strong> ${uniqueClients}<br>
                    <strong>Total Revenue:</strong> ${formatCurrency(revenue)}<br>
                    <strong>Total Payout:</strong> ${formatCurrency(payout)}<br>
                    <strong>Avg Revenue per Appointment:</strong> ${formatCurrency(revenue / appointments.length)}
                </div>
                
                <div class="modal-section">
                    <h4>Service Breakdown</h4>
                    <p style="font-size: 12px; color: #999; margin: -10px 0 10px 0; font-style: italic;">‚Üì Sorted by Appointment Count (Highest First)</p>
                    <table class="modal-table">
                        <thead>
                            <tr>
                                <th>Service</th>
                                <th>Count</th>
                                <th>Revenue</th>
                                <th>Avg per Appt</th>
                            </tr>
                        </thead>
                        <tbody>
                            ${serviceRows}
                        </tbody>
                    </table>
                    <button class="csv-export-btn" onclick='exportToCSV(${JSON.stringify(csvData)}, "practitioner-${practitionerName.replace(/[^a-zA-Z0-9]/g, '-')}.csv")'>
                        Export to CSV
                    </button>
                </div>
            `;
            
            showModal(`Practitioner: ${practitionerName}`, content);
        }
        
        // Show service details
        function showServiceDetails(serviceName) {
            const appointments = filteredAppointments.filter(row => row.Appointment === serviceName);
            
            const revenue = appointments.reduce((sum, a) => sum + (parseFloat(a.Revenue) || 0), 0);
            const uniqueClients = new Set(appointments.map(a => a['Customer Email'])).size;
            const avgRevenue = appointments.length > 0 ? revenue / appointments.length : 0;
            
            // Practitioner breakdown
            const practitioners = {};
            appointments.forEach(a => {
                const name = `${a['Practitioner First Name']} ${a['Practitioner Last Name']}`;
                if (!practitioners[name]) {
                    practitioners[name] = { count: 0, revenue: 0 };
                }
                practitioners[name].count++;
                practitioners[name].revenue += parseFloat(a.Revenue) || 0;
            });
            
            const sortedPractitioners = Object.entries(practitioners)
                .sort((a, b) => b[1].count - a[1].count);
            
            const practitionerRows = sortedPractitioners.map(([name, data]) => `
                <tr>
                    <td>${name}</td>
                    <td>${data.count}</td>
                    <td>${formatCurrency(data.revenue)}</td>
                    <td>${((data.count / appointments.length) * 100).toFixed(1)}%</td>
                </tr>
            `).join('');
            
            // Prepare CSV data
            const csvData = sortedPractitioners.map(([name, data]) => ({
                'Practitioner': name,
                'Appointments': data.count,
                'Revenue': data.revenue,
                '% of Total': ((data.count / appointments.length) * 100).toFixed(1)
            }));
            
            const content = `
                <div class="modal-highlight">
                    <strong>Service:</strong> ${serviceName}<br>
                    <strong>Total Appointments:</strong> ${appointments.length}<br>
                    <strong>Unique Clients:</strong> ${uniqueClients}<br>
                    <strong>Total Revenue:</strong> ${formatCurrency(revenue)}<br>
                    <strong>Avg Revenue per Appointment:</strong> ${formatCurrency(avgRevenue)}
                </div>
                
                <div class="modal-section">
                    <h4>Practitioner Breakdown</h4>
                    <p style="font-size: 12px; color: #999; margin: -10px 0 10px 0; font-style: italic;">‚Üì Sorted by Appointment Count (Highest First)</p>
                    <table class="modal-table">
                        <thead>
                            <tr>
                                <th>Practitioner</th>
                                <th>Appointments</th>
                                <th>Revenue</th>
                                <th>% of Total</th>
                            </tr>
                        </thead>
                        <tbody>
                            ${practitionerRows}
                        </tbody>
                    </table>
                    <button class="csv-export-btn" onclick='exportToCSV(${JSON.stringify(csvData)}, "service-${serviceName.replace(/[^a-zA-Z0-9]/g, '-')}.csv")'>
                        Export to CSV
                    </button>
                </div>
            `;
            
            showModal(`Service: ${serviceName}`, content);
        }
        
        // Show day of week details
        function showDayOfWeekDetails(dayName, location = null) {
            const dayAppointments = filteredAppointments.filter(row => {
                const date = parseDate(row['Appointment Date']);
                if (!date) return false;
                const days = ['Sunday', 'Monday', 'Tuesday', 'Wednesday', 'Thursday', 'Friday', 'Saturday'];
                const matchesDay = days[date.getDay()] === dayName;
                const matchesLocation = !location || row.Location === location;
                return matchesDay && matchesLocation;
            });
            
            const revenue = dayAppointments.reduce((sum, a) => sum + (parseFloat(a.Revenue) || 0), 0);
            const uniqueClients = new Set(dayAppointments.map(a => a['Customer Email'])).size;
            
            // Hour breakdown
            const hourBreakdown = {};
            dayAppointments.forEach(a => {
                const date = parseDate(a['Appointment Date']);
                if (date) {
                    const hour = date.getHours();
                    if (!hourBreakdown[hour]) {
                        hourBreakdown[hour] = { count: 0, revenue: 0 };
                    }
                    hourBreakdown[hour].count++;
                    hourBreakdown[hour].revenue += parseFloat(a.Revenue) || 0;
                }
            });
            
            const sortedHours = Object.entries(hourBreakdown)
                .sort((a, b) => b[1].count - a[1].count)
                .slice(0, 10);
            
            const hourRows = sortedHours.map(([hour, data]) => {
                const hourNum = parseInt(hour);
                const ampm = hourNum >= 12 ? 'PM' : 'AM';
                const displayHour = hourNum > 12 ? hourNum - 12 : (hourNum === 0 ? 12 : hourNum);
                return `
                    <tr>
                        <td>${displayHour}:00 ${ampm}</td>
                        <td>${data.count}</td>
                        <td>${formatCurrency(data.revenue)}</td>
                        <td>${formatCurrency(data.revenue / data.count)}</td>
                    </tr>
                `;
            }).join('');
            
            // Prepare CSV data
            const csvData = sortedHours.map(([hour, data]) => {
                const hourNum = parseInt(hour);
                const ampm = hourNum >= 12 ? 'PM' : 'AM';
                const displayHour = hourNum > 12 ? hourNum - 12 : (hourNum === 0 ? 12 : hourNum);
                return {
                    'Hour': `${displayHour}:00 ${ampm}`,
                    'Appointments': data.count,
                    'Revenue': data.revenue,
                    'Avg Revenue': data.revenue / data.count
                };
            });
            
            const content = `
                <div class="modal-highlight">
                    ${location ? `<strong>Location:</strong> ${location}<br>` : ''}
                    <strong>Day:</strong> ${dayName}<br>
                    <strong>Total Appointments:</strong> ${dayAppointments.length}<br>
                    <strong>Unique Clients:</strong> ${uniqueClients}<br>
                    <strong>Total Revenue:</strong> ${formatCurrency(revenue)}<br>
                    <strong>Avg Revenue per Appointment:</strong> ${formatCurrency(revenue / dayAppointments.length)}
                </div>
                
                <div class="modal-section">
                    <h4>Peak Hours on ${dayName}${location ? ` at ${location}` : ''}</h4>
                    <p style="font-size: 12px; color: #999; margin: -10px 0 10px 0; font-style: italic;">‚Üì Sorted by Appointment Count (Highest First)</p>
                    <table class="modal-table">
                        <thead>
                            <tr>
                                <th>Hour</th>
                                <th>Appointments</th>
                                <th>Revenue</th>
                                <th>Avg Revenue</th>
                            </tr>
                        </thead>
                        <tbody>
                            ${hourRows}
                        </tbody>
                    </table>
                    <button class="csv-export-btn" onclick='exportToCSV(${JSON.stringify(csvData)}, "${dayName.toLowerCase()}-peak-hours.csv")'>
                        Export to CSV
                    </button>
                </div>
            `;
            
            showModal(`${dayName} Performance${location ? ` - ${location}` : ''}`, content);
        }
        
        // Show specific hour details with individual appointment information
        function showHourDetails(dayName, hour, location = null) {
            const days = ['Sunday', 'Monday', 'Tuesday', 'Wednesday', 'Thursday', 'Friday', 'Saturday'];
            const dayIndex = days.indexOf(dayName);
            
            // Filter appointments for this specific day of week and hour
            const hourAppointments = filteredAppointments.filter(row => {
                const date = parseDate(row['Appointment Date']);
                if (!date) return false;
                const matchesTime = date.getDay() === dayIndex && date.getHours() === hour;
                const matchesLocation = !location || row.Location === location;
                return matchesTime && matchesLocation;
            });
            
            if (hourAppointments.length === 0) {
                showModal(`${dayName} ${hour}:00`, `<p>No appointments found for this time slot.</p>`);
                return;
            }
            
            const revenue = hourAppointments.reduce((sum, a) => sum + (parseFloat(a.Revenue) || 0), 0);
            const uniqueClients = new Set(hourAppointments.map(a => a['Customer Email'])).size;
            
            // Create detailed appointment list
            const appointmentRows = hourAppointments.map(appt => {
                const date = parseDate(appt['Appointment Date']);
                const dateStr = date ? date.toLocaleDateString() : 'N/A';
                const customerName = appt['Customer Name'] || 'Unknown';
                const revenue = parseFloat(appt.Revenue) || 0;
                const service = appt['Appointment'] || 'Unknown';
                const practitioner = `${appt['Practitioner First Name'] || ''} ${appt['Practitioner Last Name'] || ''}`.trim() || 'Unknown';
                
                return `
                    <tr>
                        <td>${dateStr}</td>
                        <td>${customerName}</td>
                        <td>${formatCurrency(revenue)}</td>
                        <td style="font-size: 0.85em;">${service.substring(0, 30)}${service.length > 30 ? '...' : ''}</td>
                        <td>${practitioner}</td>
                    </tr>
                `;
            }).join('');
            
            // Prepare CSV data
            const csvData = hourAppointments.map(appt => {
                const date = parseDate(appt['Appointment Date']);
                return {
                    'Date': date ? date.toLocaleDateString() : 'N/A',
                    'Customer Name': appt['Customer Name'] || 'Unknown',
                    'Customer Email': appt['Customer Email'] || 'N/A',
                    'Revenue': parseFloat(appt.Revenue) || 0,
                    'Service': appt['Appointment'] || 'Unknown',
                    'Practitioner': `${appt['Practitioner First Name'] || ''} ${appt['Practitioner Last Name'] || ''}`.trim() || 'Unknown',
                    'Duration (h)': appt['Time (h)'] || 'N/A'
                };
            });
            
            const ampm = hour >= 12 ? 'PM' : 'AM';
            const displayHour = hour > 12 ? hour - 12 : (hour === 0 ? 12 : hour);
            
            const content = `
                <div class="modal-highlight">
                    ${location ? `<strong>Location:</strong> ${location}<br>` : ''}
                    <strong>Time Slot:</strong> ${dayName}s at ${displayHour}:00 ${ampm}<br>
                    <strong>Total Appointments:</strong> ${hourAppointments.length}<br>
                    <strong>Unique Clients:</strong> ${uniqueClients}<br>
                    <strong>Total Revenue:</strong> ${formatCurrency(revenue)}<br>
                    <strong>Avg Revenue per Appointment:</strong> ${formatCurrency(revenue / hourAppointments.length)}
                </div>
                
                <div class="modal-section">
                    <h4>All Appointments at This Time</h4>
                    <p style="font-size: 12px; color: #999; margin: -10px 0 10px 0; font-style: italic;">‚Üì Showing all ${dayName} appointments at ${displayHour}:00 ${ampm}${location ? ` at ${location}` : ''}</p>
                    <table class="modal-table">
                        <thead>
                            <tr>
                                <th>Date</th>
                                <th>Customer</th>
                                <th>Revenue</th>
                                <th>Service</th>
                                <th>VSP</th>
                            </tr>
                        </thead>
                        <tbody>
                            ${appointmentRows}
                        </tbody>
                    </table>
                    <button class="csv-export-btn" onclick='exportToCSV(${JSON.stringify(csvData)}, "${dayName.toLowerCase()}-${hour}00-appointments.csv")'>
                        Export to CSV
                    </button>
                </div>
            `;
            
            showModal(`${dayName} ${displayHour}:00 ${ampm} - Appointments`, content);
        }
        
        // Show retention segment details
        function showRetentionDetails(segment, count) {
            const clientVisits = {};
            filteredAppointments.forEach(row => {
                const email = row['Customer Email'];
                if (email) {
                    clientVisits[email] = (clientVisits[email] || 0) + 1;
                }
            });
            
            let clientsInSegment = [];
            Object.entries(clientVisits).forEach(([email, visits]) => {
                const isOneTime = visits === 1;
                const isReturning = visits > 1;
                
                if ((segment === 'One-Time Visitors' && isOneTime) || 
                    (segment === 'Returning Clients' && isReturning)) {
                    const appointments = filteredAppointments.filter(a => a['Customer Email'] === email);
                    const revenue = appointments.reduce((sum, a) => sum + (parseFloat(a.Revenue) || 0), 0);
                    const customerName = appointments[0]?.['Customer Name'] || 'Unknown';
                    const firstVisit = appointments[0]?.['Appointment Date'] || 'N/A';
                    const lastVisit = appointments[appointments.length - 1]?.['Appointment Date'] || 'N/A';
                    
                    clientsInSegment.push({
                        email,
                        name: customerName,
                        visits,
                        revenue,
                        firstVisit,
                        lastVisit
                    });
                }
            });
            
            clientsInSegment.sort((a, b) => b.revenue - a.revenue);
            
            const totalRevenue = clientsInSegment.reduce((sum, c) => sum + c.revenue, 0);
            const avgRevenue = clientsInSegment.length > 0 ? totalRevenue / clientsInSegment.length : 0;
            
            let tableRows = clientsInSegment.slice(0, 50).map(c => {
                const momenceLink = getMomenceCustomerLink(c.email, c.name);
                return `
                <tr>
                    <td>${c.name}</td>
                    <td>${c.email}${momenceLink}</td>
                    <td>${c.visits}</td>
                    <td>${formatCurrency(c.revenue)}</td>
                    <td>${c.firstVisit.split(',')[0] || 'N/A'}</td>
                    <td>${c.lastVisit.split(',')[0] || 'N/A'}</td>
                </tr>
            `;
            }).join('');
            
            if (clientsInSegment.length > 50) {
                tableRows += `<tr><td colspan="6" style="text-align: center; color: #666; font-style: italic;">Showing first 50 of ${clientsInSegment.length} clients</td></tr>`;
            }
            
            // Prepare CSV data
            const csvData = clientsInSegment.map(c => ({
                'Name': c.name,
                'Email': c.email,
                'Visits': c.visits,
                'Revenue': c.revenue,
                'First Visit': c.firstVisit.split(',')[0] || 'N/A',
                'Last Visit': c.lastVisit.split(',')[0] || 'N/A'
            }));
            
            const content = `
                <div class="modal-highlight">
                    <strong>Segment:</strong> ${segment}<br>
                    <strong>Total Clients:</strong> ${clientsInSegment.length}<br>
                    <strong>Total Revenue:</strong> ${formatCurrency(totalRevenue)}<br>
                    <strong>Average Revenue per Client:</strong> ${formatCurrency(avgRevenue)}
                </div>
                
                <div class="modal-section">
                    <h4>Client Details (Sorted by Revenue)</h4>
                    <table class="modal-table">
                        <thead>
                            <tr>
                                <th>Name</th>
                                <th>Email</th>
                                <th>Visits</th>
                                <th>Revenue</th>
                                <th>First Visit</th>
                                <th>Last Visit</th>
                            </tr>
                        </thead>
                        <tbody>
                            ${tableRows}
                        </tbody>
                    </table>
                    <button class="csv-export-btn" onclick='exportToCSV(${JSON.stringify(csvData)}, "${segment.replace(/[^a-zA-Z0-9]/g, '-')}.csv")'>
                        Export to CSV
                    </button>
                </div>
            `;
            
            showModal(segment, content);
        }
        
        // Global State
        let appointmentsData = [];
        let leadsData = [];
        let leadsConvertedData = [];
        let membershipsData = [];
        let membershipCancellationsData = [];
        let membershipRenewalsData = [];
        let filteredAppointments = [];
        let filteredMemberships = [];
        let filteredLeads = [];
        let filteredLeadsConverted = [];
        let filteredCancellations = [];
        let filteredTimeTracking = [];
        let allCharts = {};
        let membershipTypes = {};
        let salesByStaff = {};
        let staffEmailToName = {}; // Map staff email to full name
        
        // Configuration
        const CONFIG = {
            currencySymbol: '$',
            dateFormat: 'en-US',
            timezone: 'America/Chicago', // Central Time
            momenceHostId: '', // Momence Host ID for deep linking
            notBeforeDate: '', // Data start date - exclude data before this date (except Leads)
            goals: {
                monthlyRevenue: 20000,
                monthlyAppointments: 300,
                monthlyIntroAppointments: 50,
                avgRevenuePerAppt: 100
            },
            baseHourlyRate: 13.00,
            franchiseFeePercent: 7.0,
            brandFundPercent: 1.5,
            ccFeesPercent: 2.9,
            ltvTiers: 'default', // default, tier2, tier3, tier4
            salariedEmployees: [
                { name: '', annualSalary: 0, startDate: '' },
                { name: '', annualSalary: 0, startDate: '' },
                { name: '', annualSalary: 0, startDate: '' }
            ]
        };
        
        // LTV Tier definitions
        const LTV_TIERS = {
            default: { ranges: [50, 150, 300, 500, 1000, Infinity], vipMin: 1000 },
            tier2: { ranges: [100, 300, 500, 1000, 2000, Infinity], vipMin: 2000 },
            tier3: { ranges: [150, 400, 800, 1500, 3000, Infinity], vipMin: 3000 },
            tier4: { ranges: [200, 600, 1000, 2000, 4000, Infinity], vipMin: 4000 },
            tier5: { ranges: [300, 800, 1500, 3000, 5000, Infinity], vipMin: 5000 }
        };
        
        // Franchise Settings Management
        
        // Helper function to create Momence customer link
        function getMomenceCustomerLink(email, customerName = 'customer') {
            if (!email) return '';
            
            if (!CONFIG.momenceHostId) {
                // Show warning icon if Host ID not configured
                return `<span style="color: #ffc107; margin-left: 5px; cursor: help;" 
                           title="Set your Momence Host ID first">‚ö†Ô∏è</span>`;
            }
            
            const encodedEmail = encodeURIComponent(email);
            const url = `https://momence.com/dashboard/${CONFIG.momenceHostId}/search?query=${encodedEmail}`;
            return `<a href="${url}" target="_blank" rel="noopener noreferrer" 
                       style="color: var(--accent); text-decoration: none; margin-left: 5px;" 
                       title="See ${customerName} in Momence">üîó</a>`;
        }
        
        function saveFranchiseSettings() {
            const settings = {
                timezone: document.getElementById('timezoneSelect').value,
                momenceHostId: document.getElementById('momenceHostId').value.trim(),
                notBeforeDate: document.getElementById('notBeforeDate').value,
                franchiseFeePercent: parseFloat(document.getElementById('franchiseFeePercent').value),
                brandFundPercent: parseFloat(document.getElementById('brandFundPercent').value),
                ccFeesPercent: parseFloat(document.getElementById('ccFeesPercent').value),
                monthlyPaidApptGoal: parseInt(document.getElementById('monthlyPaidApptGoal').value),
                monthlyIntroApptGoal: parseInt(document.getElementById('monthlyIntroApptGoal').value),
                monthlyRevenueGoal: parseFloat(document.getElementById('monthlyRevenueGoal').value),
                baseHourlyRate: parseFloat(document.getElementById('baseRateInput').value),
                ltvTiers: document.getElementById('ltvTiersSelect').value,
                salariedEmployees: [
                    {
                        name: document.getElementById('salaryEmp1Name').value.trim(),
                        annualSalary: parseFloat(document.getElementById('salaryEmp1Salary').value) || 0,
                        startDate: document.getElementById('salaryEmp1StartDate').value
                    },
                    {
                        name: document.getElementById('salaryEmp2Name').value.trim(),
                        annualSalary: parseFloat(document.getElementById('salaryEmp2Salary').value) || 0,
                        startDate: document.getElementById('salaryEmp2StartDate').value
                    },
                    {
                        name: document.getElementById('salaryEmp3Name').value.trim(),
                        annualSalary: parseFloat(document.getElementById('salaryEmp3Salary').value) || 0,
                        startDate: document.getElementById('salaryEmp3StartDate').value
                    }
                ]
            };
            
            // Validate (skip string fields and special objects)
            for (const [key, value] of Object.entries(settings)) {
                if (key === 'timezone' || key === 'ltvTiers' || key === 'salariedEmployees' || 
                    key === 'momenceHostId' || key === 'notBeforeDate') continue;
                if (isNaN(value) || value < 0) {
                    showFranchiseSettingsStatus('‚ùå Please enter valid numbers (0 or greater) for all fields', 'error');
                    return;
                }
            }
            
            // Validate salaried employees
            for (let i = 0; i < settings.salariedEmployees.length; i++) {
                const emp = settings.salariedEmployees[i];
                if (emp.name && emp.annualSalary <= 0) {
                    showFranchiseSettingsStatus(`‚ùå Employee ${i + 1}: Please enter a valid salary`, 'error');
                    return;
                }
                if (emp.annualSalary > 0 && !emp.startDate) {
                    showFranchiseSettingsStatus(`‚ùå Employee ${i + 1}: Please enter a start date`, 'error');
                    return;
                }
            }
            
            // Update CONFIG
            CONFIG.timezone = settings.timezone;
            CONFIG.momenceHostId = settings.momenceHostId;
            CONFIG.notBeforeDate = settings.notBeforeDate;
            CONFIG.franchiseFeePercent = settings.franchiseFeePercent;
            CONFIG.brandFundPercent = settings.brandFundPercent;
            CONFIG.ccFeesPercent = settings.ccFeesPercent;
            CONFIG.goals.monthlyAppointments = settings.monthlyPaidApptGoal;
            CONFIG.goals.monthlyIntroAppointments = settings.monthlyIntroApptGoal;
            CONFIG.goals.monthlyRevenue = settings.monthlyRevenueGoal;
            CONFIG.baseHourlyRate = settings.baseHourlyRate;
            CONFIG.ltvTiers = settings.ltvTiers;
            CONFIG.salariedEmployees = settings.salariedEmployees;
            
            // Save to localStorage
            localStorage.setItem('vitalStretchFranchiseSettings', JSON.stringify(settings));
            
            // Update the date filter status display
            updateDateFilterStatus();
            
            // Show success message with date filter info
            let successMsg = '‚úÖ Settings saved successfully!';
            if (settings.notBeforeDate) {
                const filterDate = new Date(settings.notBeforeDate);
                const today = new Date();
                today.setHours(0, 0, 0, 0);
                
                if (filterDate > today) {
                    successMsg += ' ‚ö†Ô∏è Note: Date filter is set to a future date.';
                }
            }
            showFranchiseSettingsStatus(successMsg, 'success');
            
            // Re-render tabs if data is loaded
            if (appointmentsData.length > 0) {
                renderAllTabs();
            }
        }
        
        function showFranchiseSettingsStatus(message, type) {
            const statusEl = document.getElementById('franchiseSettingsStatus');
            statusEl.textContent = message;
            statusEl.style.color = type === 'success' ? 'var(--success)' : 'var(--danger)';
            
            setTimeout(() => {
                statusEl.textContent = '';
            }, 3000);
        }
        
        function loadFranchiseSettingsFromStorage() {
            const saved = localStorage.getItem('vitalStretchFranchiseSettings');
            if (saved) {
                try {
                    const settings = JSON.parse(saved);
                    
                    // Update CONFIG
                    CONFIG.timezone = settings.timezone || 'America/Chicago';
                    CONFIG.momenceHostId = settings.momenceHostId || '';
                    CONFIG.notBeforeDate = settings.notBeforeDate || '';
                    CONFIG.franchiseFeePercent = settings.franchiseFeePercent || 7.0;
                    CONFIG.brandFundPercent = settings.brandFundPercent || 1.5;
                    CONFIG.ccFeesPercent = settings.ccFeesPercent || 2.9;
                    CONFIG.goals.monthlyAppointments = settings.monthlyPaidApptGoal || 300;
                    CONFIG.goals.monthlyIntroAppointments = settings.monthlyIntroApptGoal || 50;
                    CONFIG.goals.monthlyRevenue = settings.monthlyRevenueGoal || 20000;
                    CONFIG.baseHourlyRate = settings.baseHourlyRate || 13.00;
                    CONFIG.ltvTiers = settings.ltvTiers || 'default';
                    CONFIG.salariedEmployees = settings.salariedEmployees || [
                        { name: '', annualSalary: 0, startDate: '' },
                        { name: '', annualSalary: 0, startDate: '' },
                        { name: '', annualSalary: 0, startDate: '' }
                    ];
                    
                    // Update form fields
                    document.getElementById('timezoneSelect').value = CONFIG.timezone;
                    document.getElementById('momenceHostId').value = CONFIG.momenceHostId;
                    document.getElementById('notBeforeDate').value = CONFIG.notBeforeDate;
                    document.getElementById('franchiseFeePercent').value = CONFIG.franchiseFeePercent;
                    document.getElementById('brandFundPercent').value = CONFIG.brandFundPercent;
                    document.getElementById('ccFeesPercent').value = CONFIG.ccFeesPercent;
                    document.getElementById('monthlyPaidApptGoal').value = CONFIG.goals.monthlyAppointments;
                    document.getElementById('monthlyIntroApptGoal').value = CONFIG.goals.monthlyIntroAppointments;
                    document.getElementById('monthlyRevenueGoal').value = CONFIG.goals.monthlyRevenue;
                    document.getElementById('baseRateInput').value = CONFIG.baseHourlyRate;
                    document.getElementById('ltvTiersSelect').value = CONFIG.ltvTiers;
                    
                    // Update salaried employee fields
                    for (let i = 0; i < 3; i++) {
                        const emp = CONFIG.salariedEmployees[i];
                        document.getElementById(`salaryEmp${i + 1}Name`).value = emp.name || '';
                        document.getElementById(`salaryEmp${i + 1}Salary`).value = emp.annualSalary || '';
                        document.getElementById(`salaryEmp${i + 1}StartDate`).value = emp.startDate || '';
                    }
                } catch (e) {
                    console.error('Error loading settings:', e);
                }
            }
        }
        
        // Update LTV tier preview text
        function updateLTVTierPreview() {
            const tierSelect = document.getElementById('ltvTiersSelect');
            const previewEl = document.getElementById('ltvTierPreview');
            
            if (!tierSelect || !previewEl) return;
            
            const tierPreviews = {
                'default': '$1‚Äì$50, $50‚Äì$150, $150‚Äì$300, $300‚Äì$500, $500‚Äì$1K, $1K+',
                'tier2': '$1‚Äì$100, $100‚Äì$300, $300‚Äì$500, $500‚Äì$1K, $1K‚Äì$2K, $2K+',
                'tier3': '$1‚Äì$150, $150‚Äì$400, $400‚Äì$800, $800‚Äì$1.5K, $1.5K‚Äì$3K, $3K+',
                'tier4': '$1‚Äì$200, $200‚Äì$600, $600‚Äì$1K, $1K‚Äì$2K, $2K‚Äì$4K, $4K+',
                'tier5': '$1‚Äì$300, $300‚Äì$800, $800‚Äì$1.5K, $1.5K‚Äì$3K, $3K‚Äì$5K, $5K+'
            };
            
            previewEl.textContent = tierPreviews[tierSelect.value] || tierPreviews['default'];
        }
        
        // Load saved settings on page load
        window.addEventListener('DOMContentLoaded', function() {
            loadFranchiseSettingsFromStorage();
            
            // Add event listener for LTV tier dropdown
            const tierSelect = document.getElementById('ltvTiersSelect');
            if (tierSelect) {
                tierSelect.addEventListener('change', updateLTVTierPreview);
                updateLTVTierPreview(); // Initial update
            }
        });
        
        // Utility Functions
        function formatNumber(num) {
            return num.toLocaleString('en-US', {
                minimumFractionDigits: 0,
                maximumFractionDigits: 2
            });
        }
        
        function formatCurrency(num) {
            // Only round to nearest dollar if >= 1000, otherwise show cents
            if (Math.abs(num) >= 1000) {
                return CONFIG.currencySymbol + formatNumber(Math.round(num));
            }
            return CONFIG.currencySymbol + num.toLocaleString('en-US', {
                minimumFractionDigits: 2,
                maximumFractionDigits: 2
            });
        }
        
        // Helper function to parse LTV values robustly
        function parseLTV(value) {
            if (value === null || value === undefined || value === '') return 0;
            // Remove currency symbols, commas, and whitespace
            const cleaned = String(value).replace(/[$,\s]/g, '').trim();
            const parsed = parseFloat(cleaned);
            return isNaN(parsed) ? 0 : parsed;
        }
        
        // Format staff name to "First name, Last initial" format
        function formatStaffName(nameOrEmail) {
            if (!nameOrEmail || nameOrEmail === 'Direct/Online') return nameOrEmail;
            
            // Check if we have a mapping from email to full name
            const emailLower = nameOrEmail.toLowerCase().trim();
            if (staffEmailToName[emailLower]) {
                nameOrEmail = staffEmailToName[emailLower];
            }
            
            // If it's an email and we don't have a mapping, extract the name part
            if (nameOrEmail.includes('@') && !staffEmailToName[emailLower]) {
                nameOrEmail = nameOrEmail.split('@')[0].replace(/[._]/g, ' ');
            }
            
            // Split by spaces and get parts
            const parts = nameOrEmail.trim().split(/\s+/);
            if (parts.length === 0) return nameOrEmail;
            if (parts.length === 1) return parts[0]; // Just first name
            
            // Get first name and last initial
            const firstName = parts[0];
            const lastInitial = parts[parts.length - 1].charAt(0).toUpperCase();
            
            return `${firstName} ${lastInitial}.`;
        }
        
        // Calculate prorated salary costs for a given period
        function calculateSalaryCosts(startDate, endDate) {
            let totalSalaryCost = 0;
            const salaryDetails = [];
            
            if (!CONFIG.salariedEmployees) return { total: 0, details: [] };
            
            CONFIG.salariedEmployees.forEach((emp, index) => {
                if (!emp.name || emp.annualSalary <= 0 || !emp.startDate) return;
                
                const empStartDate = new Date(emp.startDate);
                const periodStart = new Date(startDate);
                const periodEnd = new Date(endDate);
                
                // Check if employee worked during this period
                if (empStartDate > periodEnd) return; // Started after period
                
                // Determine actual work start date (later of employee start or period start)
                const workStart = empStartDate > periodStart ? empStartDate : periodStart;
                
                // Calculate days worked in the period
                const daysInPeriod = Math.ceil((periodEnd - periodStart) / (1000 * 60 * 60 * 24));
                const daysWorked = Math.ceil((periodEnd - workStart) / (1000 * 60 * 60 * 24)) + 1; // +1 to include start day
                
                // Calculate prorated cost
                const dailyRate = emp.annualSalary / 365;
                const proratedCost = dailyRate * Math.min(daysWorked, daysInPeriod);
                
                totalSalaryCost += proratedCost;
                salaryDetails.push({
                    name: emp.name,
                    annualSalary: emp.annualSalary,
                    startDate: emp.startDate,
                    daysWorked: Math.min(daysWorked, daysInPeriod),
                    proratedCost: proratedCost
                });
            });
            
            return {
                total: totalSalaryCost,
                details: salaryDetails
            };
        }
        
        // Memoized date parsing for performance
        const dateCache = new Map();
        function parseDate(dateStr) {
            if (!dateStr) return new Date();
            
            // Check cache first
            if (dateCache.has(dateStr)) {
                return dateCache.get(dateStr);
            }
            
            let result;
            
            // Handle "YYYY-MM-DD, HH:MM AM/PM" format
            const parts = dateStr.split(',');
            if (parts.length >= 2) {
                const datePart = parts[0].trim();
                const timePart = parts[1].trim();
                
                // Parse date
                const dateComponents = datePart.split('-');
                if (dateComponents.length === 3) {
                    const year = parseInt(dateComponents[0]);
                    const month = parseInt(dateComponents[1]) - 1;
                    const day = parseInt(dateComponents[2]);
                    
                    // Parse time
                    const timeMatch = timePart.match(/(\d+):(\d+)\s*(AM|PM)/i);
                    if (timeMatch) {
                        let hour = parseInt(timeMatch[1]);
                        const minute = parseInt(timeMatch[2]);
                        const ampm = timeMatch[3].toUpperCase();
                        
                        // Convert to 24-hour format
                        if (ampm === 'PM' && hour !== 12) {
                            hour += 12;
                        } else if (ampm === 'AM' && hour === 12) {
                            hour = 0;
                        }
                        
                        result = new Date(year, month, day, hour, minute);
                    } else {
                        result = new Date(year, month, day);
                    }
                } else {
                    result = new Date(dateStr);
                }
            } else {
                result = new Date(dateStr);
            }
            
            // Cache the result
            dateCache.set(dateStr, result);
            return result;
        }
        
        // Convert GMT date to franchise timezone (uses CONFIG.timezone, defaults to Central Time)
        function convertGMTtoLocal(gmtDateStr) {
            if (!gmtDateStr) return null;
            
            // Parse the GMT date string
            const gmtDate = new Date(gmtDateStr);
            if (isNaN(gmtDate.getTime())) return gmtDate;
            
            // Convert to franchise timezone using CONFIG setting
            const timezone = CONFIG.timezone || 'America/Chicago';
            const localDateStr = gmtDate.toLocaleString('en-US', { timeZone: timezone });
            return new Date(localDateStr);
        }

        function isIntroOffer(service) {
            if (!service) return false;
            const serviceLower = service.toLowerCase();
            return serviceLower.includes('intro') || serviceLower.includes('introductory');
        }
        
        // Sentiment Analysis Function for cancellation reasons
        function analyzeSentiment(reason) {
            const lowerReason = reason.toLowerCase();
            
            // Negative sentiment keywords
            const negativeWords = ['expensive', 'cost', 'price', 'afford', 'too much', 'financial', 'money', 
                                  'disappointed', 'unhappy', 'poor', 'bad', 'worst', 'terrible', 'horrible',
                                  'pain', 'hurt', 'injury', 'problem', 'issue', 'dissatisfied', 'frustrat',
                                  'rude', 'unprofessional', 'late', 'cancel', 'wait', 'inconvenient'];
            
            // Neutral sentiment keywords
            const neutralWords = ['moving', 'relocated', 'schedule', 'time', 'busy', 'travel', 'distance',
                                 'far', 'changed', 'switch', 'prefer', 'different', 'other', 'work', 'job'];
            
            // Positive sentiment keywords (rare but possible)
            const positiveWords = ['achieved', 'goal', 'success', 'better', 'improved', 'healed', 'recovered'];
            
            let negativeScore = 0;
            let neutralScore = 0;
            let positiveScore = 0;
            
            negativeWords.forEach(word => {
                if (lowerReason.includes(word)) negativeScore++;
            });
            neutralWords.forEach(word => {
                if (lowerReason.includes(word)) neutralScore++;
            });
            positiveWords.forEach(word => {
                if (lowerReason.includes(word)) positiveScore++;
            });
            
            // Determine overall sentiment
            if (positiveScore > negativeScore && positiveScore > neutralScore) {
                return { sentiment: 'Positive', emoji: 'üòä', color: '#28a745' };
            } else if (negativeScore > positiveScore && negativeScore > neutralScore) {
                return { sentiment: 'Negative', emoji: 'üòû', color: '#dc3545' };
            } else {
                return { sentiment: 'Neutral', emoji: 'üòê', color: '#ffc107' };
            }
        }
        
        // Helper function to check if a date is in the future
        // Returns true if the date should be EXCLUDED (i.e., it's after today)
        // NOTE: Membership data (renewals) should NOT use this filter as future renewals are useful
        function shouldFilterFutureDate(dateStr) {
            if (!dateStr || dateStr === '' || dateStr === 'N/A') {
                return false; // No valid date provided, include it
            }
            
            try {
                // Parse the data date
                let dataDate;
                
                if (typeof dateStr === 'string') {
                    const dateStrTrimmed = dateStr.trim();
                    
                    // Handle GMT or ISO format dates
                    if (dateStrTrimmed.includes('GMT') || dateStrTrimmed.includes('T') || dateStrTrimmed.includes('Z')) {
                        dataDate = new Date(dateStrTrimmed);
                    }
                    // Handle other date formats
                    else if (dateStrTrimmed.includes('-') || dateStrTrimmed.includes('/')) {
                        dataDate = parseDate(dateStrTrimmed);
                    }
                    // Fallback to standard Date parsing
                    else {
                        dataDate = new Date(dateStrTrimmed);
                    }
                } else if (dateStr instanceof Date) {
                    dataDate = dateStr;
                } else {
                    return false;
                }
                
                // Validate the parsed date
                if (isNaN(dataDate.getTime())) {
                    return false; // If parsing failed, include the date
                }
                
                // Get today's date at start of day
                const today = new Date();
                today.setHours(23, 59, 59, 999); // End of today
                
                // Return true if dataDate is in the future (should be filtered out)
                const isFuture = dataDate > today;
                
                // Debug logging for December dates
                if (dataDate.getMonth() === 11) { // December is month 11
                    console.log(`üîÆ Future date check: ${dateStr} -> ${dataDate.toLocaleDateString()} is ${isFuture ? 'FUTURE (filtered)' : 'NOT FUTURE (kept)'}, today end: ${today.toLocaleString()}`);
                }
                
                return isFuture;
            } catch (error) {
                console.warn('Error filtering future date:', dateStr, error);
                return false; // If there's an error, include the date
            }
        }
        
        // Helper function to check if a date should be filtered based on CONFIG.notBeforeDate
        // Returns true if the date should be EXCLUDED (i.e., it's before the notBeforeDate)
        // NOTE: This filter is NOT applied to Leads data - only to appointments, payroll, 
        // time tracking, commissions, memberships, cancellations, frozen memberships, and renewals
        function shouldFilterDate(dateStr) {
            if (!CONFIG.notBeforeDate) {
                return false; // No filter set, include all dates
            }
            
            if (!dateStr || dateStr === '' || dateStr === 'N/A') {
                return false; // No valid date provided, include it
            }
            
            try {
                // Parse the data date
                let dataDate;
                
                // Handle different date formats
                if (typeof dateStr === 'string') {
                    const dateStrTrimmed = dateStr.trim();
                    
                    // Handle GMT or ISO format dates (e.g., "2024-01-15T10:30:00Z" or "2024-01-15 10:30 AM GMT")
                    if (dateStrTrimmed.includes('GMT') || dateStrTrimmed.includes('T') || dateStrTrimmed.includes('Z')) {
                        dataDate = new Date(dateStrTrimmed);
                    }
                    // Handle dates that parseDate can handle
                    else if (dateStrTrimmed.includes('-') || dateStrTrimmed.includes('/')) {
                        dataDate = parseDate(dateStrTrimmed);
                    }
                    // Fallback to standard Date parsing
                    else {
                        dataDate = new Date(dateStrTrimmed);
                    }
                } else if (dateStr instanceof Date) {
                    dataDate = dateStr;
                } else {
                    // Unknown date type, include it
                    return false;
                }
                
                // Validate the parsed date
                if (isNaN(dataDate.getTime())) {
                    console.warn('Invalid date parsed:', dateStr);
                    return false; // If parsing failed, include the date
                }
                
                // Parse the notBeforeDate (format: YYYY-MM-DD)
                const notBeforeDate = new Date(CONFIG.notBeforeDate);
                notBeforeDate.setHours(0, 0, 0, 0); // Set to start of day
                
                // Set data date to start of day for fair comparison
                const dataDateNormalized = new Date(dataDate);
                dataDateNormalized.setHours(0, 0, 0, 0);
                
                // Return true if dataDate is before notBeforeDate (should be filtered out)
                return dataDateNormalized < notBeforeDate;
            } catch (error) {
                console.warn('Error filtering date:', dateStr, error);
                return false; // If there's an error, include the date
            }
        }
        
        // File Upload Handlers
        document.getElementById('leadsFile').addEventListener('change', function(e) {
            const files = Array.from(e.target.files);
            if (files.length === 0) return;
            
            document.getElementById('leadsStatus').innerHTML = '<span class="spinner"></span> Processing...';
            
            // Process multiple files if provided
            let processedFiles = 0;
            const totalFiles = files.length;
            
            files.forEach(file => {
                Papa.parse(file, {
                    header: true,
                    skipEmptyLines: true,
                    complete: function(results) {
                        // Auto-detect file type based on columns
                        const columns = results.meta.fields || [];
                        const hasConvertedTo = columns.some(col => col.toLowerCase().includes('converted to'));
                        const hasLeadSource = columns.some(col => col.toLowerCase().includes('lead source'));
                        
                        if (hasConvertedTo && hasLeadSource) {
                            // This is the Leads Converted Report
                            leadsConvertedData = results.data;
                            window.leadsConvertedData = leadsConvertedData;
                            
                            // Update converted status
                            const converted = leadsConvertedData.filter(row => {
                                const convertedTo = (row['Converted to'] || '').trim();
                                return convertedTo && convertedTo !== 'N/A' && convertedTo !== '';
                            }).length;
                            
                            const sources = new Set(leadsConvertedData.map(r => r['Lead source'] || 'Unknown')).size;
                            document.getElementById('leadsConvertedStatus').innerHTML = 
                                `<span style="color: var(--success); font-weight: 600;">‚úÖ ${formatNumber(leadsConvertedData.length)} leads, ${converted} converted, ${sources} sources</span>`;
                        } else {
                            // This is the regular Leads file
                            leadsData = results.data;
                        }
                        
                        processedFiles++;
                        
                        // After all files are processed, merge data
                        if (processedFiles === totalFiles) {
                            // Merge lead source data if both files were uploaded
                            if (leadsConvertedData.length > 0 && leadsData.length > 0) {
                                const leadSourceMap = new Map();
                                leadsConvertedData.forEach(row => {
                                    const email = (row['E-mail'] || row['Email'] || '').toLowerCase().trim();
                                    const leadSource = row['Lead source'] || '';
                                    if (email && leadSource) {
                                        leadSourceMap.set(email, leadSource);
                                    }
                                });

                                leadsData = leadsData.map(customer => {
                                    const email = (customer['E-mail'] || '').toLowerCase().trim();
                                    if (email && leadSourceMap.has(email)) {
                                        return {
                                            ...customer,
                                            'Aggregator': leadSourceMap.get(email),
                                            'Lead source': leadSourceMap.get(email)
                                        };
                                    }
                                    return customer;
                                });
                            } else if (leadsConvertedData.length > 0 && leadsData.length === 0) {
                                // Use converted data as primary if main leads not loaded
                                leadsData = leadsConvertedData.map(row => {
                                    let type = row['Type'] || '';
                                    if (!type || type.toLowerCase() === 'lead') {
                                        type = (row['Converted to'] && row['Converted to'] !== 'N/A' && row['Converted to'] !== '') ? 'Customer' : 'Lead';
                                    }
                                    
                                    return {
                                        'First name': row['First Name'] || row['First name'] || '',
                                        'Last name': row['Last Name'] || row['Last name'] || '',
                                        'E-mail': row['E-mail'] || row['Email'] || '',
                                        'Type': type,
                                        'Join date': row['Join date'] || row['Converted'] || '',
                                        'First purchase': row['First purchase'] || row['Converted'] || '',
                                        'Aggregator': row['Lead source'] || 'Unknown',
                                        'LTV': row['LTV'] || '0',
                                        'Home location': row['Home location'] || '',
                                        'Converted to': row['Converted to'] || '',
                                        'Converted': row['Converted'] || '',
                                        'Lead source': row['Lead source'] || ''
                                    };
                                });
                            }
                            
                            // Count customers vs leads
                            const customers = leadsData.filter(row => (row['Type'] || '').toLowerCase() === 'customer').length;
                            const leads = leadsData.filter(row => (row['Type'] || '').toLowerCase() === 'lead').length;
                            
                            let statusHTML = '<span style="color: var(--success); font-weight: 600;">‚úÖ ';
                            if (customers > 0 && leads > 0) {
                                statusHTML += `${formatNumber(customers)} customers, ${formatNumber(leads)} leads loaded`;
                            } else if (customers > 0) {
                                statusHTML += `${formatNumber(customers)} customers loaded`;
                            } else if (leads > 0) {
                                statusHTML += `${formatNumber(leads)} leads loaded`;
                            } else {
                                statusHTML += `${formatNumber(leadsData.length)} records loaded`;
                            }
                            statusHTML += '</span>';
                            
                            document.getElementById('leadsStatus').innerHTML = statusHTML;

                            if (appointmentsData.length > 0) {
                                hideEmptyState();
                                applyFilters(); // Re-filter with actual CSV data
                                renderAllTabs();
                            }
                        }
                    },
                    error: function(error) {
                        document.getElementById('leadsStatus').innerHTML = 
                            '<span style="color: var(--danger);">‚ùå Error loading file</span>';
                        console.error('Parse error:', error);
                    }
                });
            });
        });
        
        document.getElementById('leadsConvertedFile').addEventListener('change', function(e) {
            const file = e.target.files[0];
            if (!file) return;
            
            document.getElementById('leadsConvertedStatus').innerHTML = '<span class="spinner"></span> Processing...';
            
            Papa.parse(file, {
                header: true,
                skipEmptyLines: true,
                complete: function(results) {
                    leadsConvertedData = results.data;
                    window.leadsConvertedData = leadsConvertedData;



                    // If main leads CSV already loaded, MERGE lead sources into existing data
                    if (leadsData.length > 0) {

                        // Create a map of email -> lead source from converted data
                        const leadSourceMap = new Map();
                        leadsConvertedData.forEach(row => {
                            const email = (row['E-mail'] || row['Email'] || '').toLowerCase().trim();
                            const leadSource = row['Lead source'] || '';
                            if (email && leadSource) {
                                leadSourceMap.set(email, leadSource);
                            }
                        });

                        // Merge lead sources into existing leadsData
                        let mergedCount = 0;
                        leadsData = leadsData.map(customer => {
                            const email = (customer['E-mail'] || '').toLowerCase().trim();
                            if (email && leadSourceMap.has(email)) {
                                mergedCount++;
                                return {
                                    ...customer,
                                    'Aggregator': leadSourceMap.get(email),
                                    'Lead source': leadSourceMap.get(email)
                                };
                            }
                            return customer;
                        });


                    } else {
                        // Main leads CSV not loaded yet - use converted data as primary

                        leadsData = leadsConvertedData.map(row => {
                            // Determine type - prioritize existing Type field, then check Converted to field
                            let type = row['Type'] || '';
                            if (!type || type.toLowerCase() === 'lead') {
                                // Check if they've been converted
                                type = (row['Converted to'] && row['Converted to'] !== 'N/A' && row['Converted to'] !== '') ? 'Customer' : 'Lead';
                            }
                            
                            return {
                                'First name': row['First Name'] || row['First name'] || '',
                                'Last name': row['Last Name'] || row['Last name'] || '',
                                'E-mail': row['E-mail'] || row['Email'] || '',
                                'Type': type,
                                'Join date': row['Join date'] || row['Converted'] || '',
                                'First purchase': row['First purchase'] || row['Converted'] || '',
                                'Aggregator': row['Lead source'] || 'Unknown',
                                'LTV': row['LTV'] || '0',
                                'Home location': row['Home location'] || '',
                                'Converted to': row['Converted to'] || '',
                                'Converted': row['Converted'] || '',
                                'Lead source': row['Lead source'] || ''
                            };
                        });
                    }
                    
                    // Count conversions and sources
                    const converted = leadsConvertedData.filter(row => {
                        const convertedTo = (row['Converted to'] || '').trim();
                        return convertedTo && convertedTo !== 'N/A' && convertedTo !== '';
                    }).length;
                    
                    const sources = new Set(leadsConvertedData.map(row => row['Lead source']).filter(s => s));
                    
                    let statusHTML = '<span style="color: var(--success); font-weight: 600;">‚úÖ ';
                    statusHTML += `${formatNumber(leadsConvertedData.length)} leads, `;
                    statusHTML += `${formatNumber(converted)} converted, `;
                    statusHTML += `${formatNumber(sources.size)} sources (merged into main data)`;
                    statusHTML += '</span>';
                    
                    document.getElementById('leadsConvertedStatus').innerHTML = statusHTML;

                    if (appointmentsData.length > 0) {
                        hideEmptyState();
                        applyFilters(); // Re-filter with merged data
                        renderAllTabs();
                    }
                },
                error: function(error) {
                    document.getElementById('leadsConvertedStatus').innerHTML = 
                        '<span style="color: var(--danger);">‚ùå Error loading file</span>';
                    console.error('Parse error:', error);
                }
            });
        });
        
        // Magic Upload Handler - Auto-detect and load all file types
        document.getElementById('magicUploadFile').addEventListener('change', async function(e) {
            const files = e.target.files;
            if (!files || files.length === 0) return;
            
            document.getElementById('magicUploadStatus').innerHTML = '<span class="spinner"></span> ü™Ñ Analyzing files...';
            
            const statusMessages = [];
            let filesProcessed = 0;
            const totalFiles = files.length;
            
            for (const file of files) {
                const fileName = file.name.toLowerCase();
                
                try {
                    // Handle ZIP files
                    if (fileName.endsWith('.zip')) {
                        if (fileName.includes('payroll')) {
                            // Trigger payroll zip upload
                            const dataTransfer = new DataTransfer();
                            dataTransfer.items.add(file);
                            document.getElementById('payrollZipFile').files = dataTransfer.files;
                            document.getElementById('payrollZipFile').dispatchEvent(new Event('change'));
                            statusMessages.push(`‚úÖ ${file.name} ‚Üí Payroll ZIP`);
                        } else if (fileName.includes('attendance')) {
                            // Trigger attendance zip upload
                            const dataTransfer = new DataTransfer();
                            dataTransfer.items.add(file);
                            document.getElementById('attendanceZipFile').files = dataTransfer.files;
                            document.getElementById('attendanceZipFile').dispatchEvent(new Event('change'));
                            statusMessages.push(`‚úÖ ${file.name} ‚Üí Attendance ZIP`);
                        } else {
                            statusMessages.push(`‚ö†Ô∏è ${file.name} ‚Üí Unknown ZIP type`);
                        }
                        filesProcessed++;
                        continue;
                    }
                    
                    // Handle CSV files - need to peek at headers
                    if (fileName.endsWith('.csv')) {
                        await new Promise((resolve, reject) => {
                            Papa.parse(file, {
                                header: true,
                                preview: 1,
                                skipEmptyLines: true,
                                complete: function(results) {
                                    if (results.data.length === 0) {
                                        statusMessages.push(`‚ö†Ô∏è ${file.name} ‚Üí Empty file`);
                                        filesProcessed++;
                                        resolve();
                                        return;
                                    }
                                    
                                    const headers = Object.keys(results.data[0]);
                                    const firstRow = results.data[0];
                                    let detected = false;
                                    
                                    // Detect file type by headers
                                    if (headers.includes('Bought Date/Time (GMT)')) {
                                        // Membership sales
                                        const dataTransfer = new DataTransfer();
                                        dataTransfer.items.add(file);
                                        const currentFiles = document.getElementById('membershipsFile').files;
                                        for (let i = 0; i < currentFiles.length; i++) {
                                            dataTransfer.items.add(currentFiles[i]);
                                        }
                                        document.getElementById('membershipsFile').files = dataTransfer.files;
                                        document.getElementById('membershipsFile').dispatchEvent(new Event('change'));
                                        statusMessages.push(`‚úÖ ${file.name} ‚Üí Membership Sales`);
                                        detected = true;
                                    } else if (headers.includes('Cancelled at')) {
                                        // Membership cancellations
                                        const dataTransfer = new DataTransfer();
                                        dataTransfer.items.add(file);
                                        const currentFiles = document.getElementById('membershipsFile').files;
                                        for (let i = 0; i < currentFiles.length; i++) {
                                            dataTransfer.items.add(currentFiles[i]);
                                        }
                                        document.getElementById('membershipsFile').files = dataTransfer.files;
                                        document.getElementById('membershipsFile').dispatchEvent(new Event('change'));
                                        statusMessages.push(`‚úÖ ${file.name} ‚Üí Membership Cancellations`);
                                        detected = true;
                                    } else if (headers.includes('Frozen at')) {
                                        // Frozen memberships
                                        const dataTransfer = new DataTransfer();
                                        dataTransfer.items.add(file);
                                        const currentFiles = document.getElementById('membershipsFile').files;
                                        for (let i = 0; i < currentFiles.length; i++) {
                                            dataTransfer.items.add(currentFiles[i]);
                                        }
                                        document.getElementById('membershipsFile').files = dataTransfer.files;
                                        document.getElementById('membershipsFile').dispatchEvent(new Event('change'));
                                        statusMessages.push(`‚úÖ ${file.name} ‚Üí Frozen Memberships`);
                                        detected = true;
                                    } else if (headers.includes('Converted') && headers.includes('Lead source')) {
                                        // Leads converted
                                        const dataTransfer = new DataTransfer();
                                        dataTransfer.items.add(file);
                                        document.getElementById('leadsConvertedFile').files = dataTransfer.files;
                                        document.getElementById('leadsConvertedFile').dispatchEvent(new Event('change'));
                                        statusMessages.push(`‚úÖ ${file.name} ‚Üí Leads Converted`);
                                        detected = true;
                                    } else if (headers.includes('Type') && (headers.includes('First name') || headers.includes('Join date'))) {
                                        // Leads & customers
                                        const dataTransfer = new DataTransfer();
                                        dataTransfer.items.add(file);
                                        document.getElementById('leadsFile').files = dataTransfer.files;
                                        document.getElementById('leadsFile').dispatchEvent(new Event('change'));
                                        statusMessages.push(`‚úÖ ${file.name} ‚Üí Leads & Customers`);
                                        detected = true;
                                    } else if (headers.includes('Staff Name') && headers.includes('Staff E-mail')) {
                                        // Attendance report
                                        const dataTransfer = new DataTransfer();
                                        dataTransfer.items.add(file);
                                        document.getElementById('attendanceZipFile').files = dataTransfer.files;
                                        document.getElementById('attendanceZipFile').dispatchEvent(new Event('change'));
                                        statusMessages.push(`‚úÖ ${file.name} ‚Üí Attendance Report`);
                                        detected = true;
                                    } else if (headers.includes('Membership') && headers.includes('Amount') && headers.includes('Date') && 
                                               headers.includes('Customer email') &&
                                               firstRow['Membership'] && firstRow['Membership'].includes('Hours/Month')) {
                                        // Membership renewals - CHECK LAST to avoid conflicts with sales
                                        // Need to re-parse the full file since preview only gave us 1 row
                                        Papa.parse(file, {
                                            header: true,
                                            skipEmptyLines: true,
                                            complete: function(fullResults) {
                                                membershipRenewalsData = fullResults.data;
                                                statusMessages.push(`‚úÖ ${file.name} ‚Üí Membership Renewals (${fullResults.data.length} upcoming)`);
                                            }
                                        });
                                        detected = true;
                                    }
                                    
                                    if (!detected) {
                                        statusMessages.push(`‚ö†Ô∏è ${file.name} ‚Üí Unknown CSV type`);
                                    }
                                    
                                    filesProcessed++;
                                    resolve();
                                },
                                error: function(error) {
                                    statusMessages.push(`‚ùå ${file.name} ‚Üí Parse error`);
                                    filesProcessed++;
                                    reject(error);
                                }
                            });
                        });
                    }
                } catch (error) {
                    console.error('Magic upload error for', file.name, error);
                    statusMessages.push(`‚ùå ${file.name} ‚Üí Error`);
                    filesProcessed++;
                }
            }
            
            // Wait a moment for all the triggered uploads to process
            setTimeout(() => {
                document.getElementById('magicUploadStatus').innerHTML = `
                    <div style="font-size: 13px;">
                        <strong>üéâ Magic Upload Complete!</strong><br>
                        ${statusMessages.join('<br>')}
                    </div>
                `;
                
                // If renewals were uploaded and memberships tab exists, re-render it
                if (membershipRenewalsData && membershipRenewalsData.length > 0 && membershipsData && membershipsData.length > 0) {
                    setTimeout(() => {
                        if (renderedTabs.has('memberships')) {
                            renderTab('memberships');
                        }
                    }, 100);
                }
            }, 1000);
        });
        
        document.getElementById('membershipsFile').addEventListener('change', function(e) {
            const files = e.target.files;
            if (!files || files.length === 0) return;
            
            document.getElementById('membershipsStatus').innerHTML = '<span class="spinner"></span> Processing...';
            
            let salesCount = 0;
            let cancellationsCount = 0;
            let frozenCount = 0;
            let filesProcessed = 0;
            let statusMessages = [];
            
            // Process each file
            Array.from(files).forEach((file, index) => {
                Papa.parse(file, {
                    header: true,
                    skipEmptyLines: true,
                    complete: function(results) {
                        if (results.data.length > 0) {
                            // Check if it's sales or cancellations or frozen by looking at headers
                            const headers = Object.keys(results.data[0]);
                            
                            if (headers.includes('Cancelled at')) {
                                // This is a cancellations file - filter by date
                                membershipCancellationsData = results.data.filter(row => {
                                    const dateField = row['Cancelled at'];
                                    return !shouldFilterDate(dateField);
                                });
                                filteredCancellations = [...membershipCancellationsData];
                                cancellationsCount = membershipCancellationsData.length;

                            } else if (headers.includes('Frozen at')) {
                                // This is a frozen memberships file - filter by date
                                window.frozenMembershipsData = results.data.filter(row => {
                                    const dateField = row['Frozen at'];
                                    return !shouldFilterDate(dateField);
                                });
                                frozenCount = window.frozenMembershipsData.length;

                            } else if (headers.includes('Bought Date/Time (GMT)')) {
                                // This is a sales file - filter to only Hour/Month or Hours/Month memberships and by date
                                const allMemberships = results.data;
                                membershipsData = allMemberships.filter(m => {
                                    const membershipName = (m['Membership Name'] || '').toLowerCase();
                                    const isHoursPerMonth = membershipName.includes('hour/month') || membershipName.includes('hours/month');
                                    if (!isHoursPerMonth) return false;
                                    
                                    // Filter by notBeforeDate
                                    const dateField = m['Bought Date/Time (GMT)'];
                                    return !shouldFilterDate(dateField);
                                });
                                window.membershipsData = membershipsData;
                                filteredMemberships = [...membershipsData];
                                salesCount = membershipsData.length;

                            } else if (headers.includes('Membership') && headers.includes('Customer Name') && headers.includes('Date')) {
                                // This is a renewals file - filter by date
                                membershipRenewalsData = results.data.filter(row => {
                                    const dateField = row['Date'];
                                    return !shouldFilterDate(dateField);
                                });
                                statusMessages.push(`‚úÖ ${membershipRenewalsData.length} upcoming renewals`);

                            } else {
                                statusMessages.push(`‚ö†Ô∏è Unknown file type`);
                            }
                        }
                        
                        filesProcessed++;
                        
                        // When all files are processed, update status
                        if (filesProcessed === files.length) {
                            // Build status message showing current state of all files
                            const currentStatus = [];
                            
                            // Check what we have in memory (from all uploads)
                            if (membershipsData.length > 0) {
                                currentStatus.push(`<span style="color: var(--success); font-weight: 600;">‚úÖ ${formatNumber(membershipsData.length)} memberships loaded</span>`);
                            }
                            
                            if (membershipCancellationsData.length > 0) {
                                currentStatus.push(`<span style="color: var(--success); font-weight: 600;">‚úÖ ${formatNumber(membershipCancellationsData.length)} cancellations loaded</span>`);
                            }
                            
                            if (window.frozenMembershipsData && window.frozenMembershipsData.length > 0) {
                                currentStatus.push(`<span style="color: var(--success); font-weight: 600;">‚úÖ ${formatNumber(window.frozenMembershipsData.length)} frozen memberships loaded</span>`);
                            }
                            
                            if (membershipRenewalsData.length > 0) {
                                currentStatus.push(`<span style="color: var(--success); font-weight: 600;">‚úÖ ${formatNumber(membershipRenewalsData.length)} upcoming renewals loaded</span>`);
                            }
                            
                            if (statusMessages.length > 0 && statusMessages[0].includes('‚ö†Ô∏è')) {
                                currentStatus.push(...statusMessages);
                            }
                            
                            if (currentStatus.length > 0) {
                                document.getElementById('membershipsStatus').innerHTML = currentStatus.join('<br>');
                                
                                // Log filtering statistics if date filter is active
                                if (CONFIG.notBeforeDate) {
                                    console.log(`üìÖ Membership Data - Date Filter Active: Excluding data before ${CONFIG.notBeforeDate}`);
                                    if (membershipsData.length > 0) console.log(`‚úÖ ${membershipsData.length} memberships after filtering`);
                                    if (membershipCancellationsData.length > 0) console.log(`‚úÖ ${membershipCancellationsData.length} cancellations after filtering`);
                                    if (window.frozenMembershipsData?.length > 0) console.log(`‚úÖ ${window.frozenMembershipsData.length} frozen memberships after filtering`);
                                    if (membershipRenewalsData.length > 0) console.log(`‚úÖ ${membershipRenewalsData.length} renewals after filtering`);
                                }
                            } else {
                                document.getElementById('membershipsStatus').innerHTML = 
                                    '<span style="color: var(--danger);">‚ùå No valid data found</span>';
                            }

                            if (appointmentsData.length > 0 && (membershipsData.length > 0 || membershipCancellationsData.length > 0 || membershipRenewalsData.length > 0)) {
                                hideEmptyState();
                                renderAllTabs();
                            } else if (membershipRenewalsData.length > 0 && membershipsData.length > 0) {
                                // If only renewals uploaded but we have existing memberships data, re-render memberships tab
                                renderTab('memberships');
                            }
                        }
                    },
                    error: function(error) {
                        filesProcessed++;
                        statusMessages.push(`‚ùå Error in file`);
                        if (filesProcessed === files.length) {
                            document.getElementById('membershipsStatus').innerHTML = 
                                statusMessages.map(msg => `<span style="color: var(--danger); font-weight: 600;">${msg}</span>`).join('<br>');
                        }
                        console.error('Parse error:', error);
                    }
                });
            });
        });
        
        // Zip File Handler for Payroll Data
        document.getElementById('payrollZipFile').addEventListener('change', async function(e) {
            const file = e.target.files[0];
            if (!file) return;
            
            document.getElementById('payrollZipStatus').innerHTML = '<span class="spinner"></span> Processing zip file...';
            
            try {
                const zip = await JSZip.loadAsync(file);
                let allAppointments = [];
                let allTimeTracking = [];
                let allCommissions = [];
                let employeeStats = {};
                
                // Process all files in the zip
                for (const [filename, zipEntry] of Object.entries(zip.files)) {
                    if (zipEntry.dir) continue;
                    
                    const content = await zipEntry.async('text');
                    
                    // Extract employee name from filename
                    const nameParts = filename.match(/momence-payroll-(?:appointments|time)-(.+?)(?:-aggregate)?\.csv/);
                    if (!nameParts) continue;
                    
                    const employeeName = nameParts[1].replace(/-/g, ' ').replace(/\b\w/g, l => l.toUpperCase());
                    
                    // Parse appointments files (not aggregate)
                    if (filename.includes('appointments') && !filename.includes('aggregate')) {
                        Papa.parse(content, {
                            header: true,
                            skipEmptyLines: true,
                            complete: function(results) {
                                // Add employee name and practitioner info to each row
                                results.data.forEach(row => {
                                    const names = employeeName.split(' ');
                                    row['Practitioner First Name'] = names[0];
                                    row['Practitioner Last Name'] = names.slice(1).join(' ');
                                    row['Employee Name'] = employeeName;
                                    
                                    // Convert Time booked (h) to Time (h) for consistency
                                    if (row['Time booked (h)']) {
                                        row['Time (h)'] = row['Time booked (h)'];
                                    }
                                });
                                
                                // Filter out appointments before the notBeforeDate AND future appointments
                                const filteredResults = results.data.filter(row => {
                                    const dateField = row['Date/Time (GMT)'] || row['Date'];
                                    // Exclude if before notBeforeDate OR in the future
                                    return !shouldFilterDate(dateField) && !shouldFilterFutureDate(dateField);
                                });
                                
                                allAppointments = allAppointments.concat(filteredResults);
                            }
                        });
                    }
                    
                    // Parse time tracking files
                    if (filename.includes('time') && !filename.includes('aggregate')) {
                        Papa.parse(content, {
                            header: true,
                            skipEmptyLines: true,
                            complete: function(results) {
                                results.data.forEach(row => {
                                    row['Employee Name'] = employeeName;
                                    // Store for cleaning later
                                    if (!employeeStats[employeeName]) {
                                        employeeStats[employeeName] = { durations: [] };
                                    }
                                    const duration = parseFloat(row['Duration (h)']);
                                    if (!isNaN(duration)) {
                                        employeeStats[employeeName].durations.push(duration);
                                    }
                                });
                                
                                // Filter out time tracking before the notBeforeDate AND future dates
                                const filteredResults = results.data.filter(row => {
                                    const dateField = row['Date'] || row['Date/Time (GMT)'];
                                    return !shouldFilterDate(dateField) && !shouldFilterFutureDate(dateField);
                                });
                                
                                allTimeTracking = allTimeTracking.concat(filteredResults);
                            }
                        });
                    }
                    
                    // Parse commission files
                    if (filename.includes('commissions') && !filename.includes('aggregate')) {
                        Papa.parse(content, {
                            header: true,
                            skipEmptyLines: true,
                            complete: function(results) {
                                // Filter out commissions before the notBeforeDate and keep only Membership/Product types
                                results.data.forEach(row => {
                                    row['Employee Name'] = employeeName;
                                    // Clean product names - remove special characters
                                    if (row['Item name']) {
                                        row['Item name'] = row['Item name']
                                            .replace(/[¬Æ‚Ñ¢¬©√Ç¬Æ]/g, '')           // Remove special characters
                                            .replace(/[\u0080-\u00FF]/g, '')  // Remove extended ASCII
                                            .replace(/\s+/g, ' ')              // Normalize whitespace
                                            .trim();
                                    }
                                });
                                
                                // Filter by date and item type
                                const filteredResults = results.data.filter(row => {
                                    const dateField = row['Date/Time (GMT)'] || row['Date'];
                                    // Exclude if before notBeforeDate OR in the future
                                    if (shouldFilterDate(dateField) || shouldFilterFutureDate(dateField)) {
                                        return false;
                                    }
                                    
                                    // Only include Membership and Product commissions
                                    const itemType = (row['Item type'] || '').toLowerCase();
                                    return itemType === 'membership' || itemType === 'product';
                                });
                                
                                allCommissions = allCommissions || [];
                                allCommissions = allCommissions.concat(filteredResults);
                            }
                        });
                    }
                }
                
                // Wait a bit for all parsing to complete
                await new Promise(resolve => setTimeout(resolve, 500));
                
                // Clean Duration (h) data - replace values > 12 with employee average
                Object.keys(employeeStats).forEach(employeeName => {
                    const durations = employeeStats[employeeName].durations.filter(d => d > 0 && d <= 12);
                    const avgDuration = durations.length > 0 
                        ? durations.reduce((sum, d) => sum + d, 0) / durations.length 
                        : 8; // Default to 8 hours if no valid data
                    employeeStats[employeeName].avgDuration = avgDuration;
                });
                
                // Apply cleaning to time tracking data
                allTimeTracking = allTimeTracking.map(row => {
                    const duration = parseFloat(row['Duration (h)']);
                    if (!isNaN(duration) && duration > 12) {
                        const employeeName = row['Employee Name'];
                        const avgDuration = employeeStats[employeeName]?.avgDuration || 8;
                        row['Duration (h)'] = avgDuration.toFixed(2);
                        row['Original Duration (h)'] = duration.toFixed(2); // Keep original for reference
                        row['Duration Corrected'] = 'Yes';
                    }
                    return row;
                });
                
                // Calculate utilization for each employee
                const employeeUtilization = {};
                Object.keys(employeeStats).forEach(employeeName => {
                    const employeeAppts = allAppointments.filter(a => a['Employee Name'] === employeeName);
                    const employeeTime = allTimeTracking.filter(t => t['Employee Name'] === employeeName);
                    
                    const totalApptHours = employeeAppts.reduce((sum, a) => {
                        const hours = parseFloat(a['Time (h)'] || a['Time booked (h)'] || 0);
                        return sum + hours;
                    }, 0);
                    
                    const totalClockedHours = employeeTime.reduce((sum, t) => {
                        const hours = parseFloat(t['Duration (h)'] || 0);
                        return sum + hours;
                    }, 0);
                    
                    const utilization = totalClockedHours > 0 
                        ? (totalApptHours / totalClockedHours * 100) 
                        : 0;
                    
                    employeeUtilization[employeeName] = {
                        totalApptHours: totalApptHours,
                        totalClockedHours: totalClockedHours,
                        utilization: utilization,
                        appointmentCount: employeeAppts.length,
                        shiftCount: employeeTime.length
                    };
                });
                
                // Store utilization data globally
                window.employeeUtilization = employeeUtilization;
                window.timeTrackingData = allTimeTracking;
                window.commissionsData = allCommissions;
                window.filteredCommissions = [...allCommissions];
                
                // Set appointments data
                appointmentsData = allAppointments;
                filteredAppointments = [...appointmentsData];
                
                // Log filtering statistics if date filter is active
                if (CONFIG.notBeforeDate) {
                    console.log(`üìÖ Date Filter Active: Excluding data before ${CONFIG.notBeforeDate}`);
                    console.log(`üîÆ Future appointments also excluded (today is ${new Date().toLocaleDateString()})`);
                    console.log(`‚úÖ Loaded ${allAppointments.length} appointments after filtering`);
                    console.log(`‚úÖ Loaded ${allTimeTracking.length} time tracking records after filtering`);
                    console.log(`‚úÖ Loaded ${allCommissions.length} commission records after filtering`);
                } else {
                    console.log(`üîÆ Future appointments excluded (today is ${new Date().toLocaleDateString()})`);
                    console.log(`‚úÖ Loaded ${allAppointments.length} appointments`);
                    console.log(`‚úÖ Loaded ${allTimeTracking.length} time tracking records`);
                    console.log(`‚úÖ Loaded ${allCommissions.length} commission records`);
                }
                
                const totalAppts = allAppointments.length;
                const totalEmployees = Object.keys(employeeStats).length;
                const avgUtilization = Object.values(employeeUtilization)
                    .reduce((sum, e) => sum + e.utilization, 0) / totalEmployees;
                
                document.getElementById('payrollZipStatus').innerHTML = 
                    `<span style="color: var(--success); font-weight: 600;">‚úÖ ${formatNumber(totalAppts)} appointments from ${totalEmployees} employees (Avg Utilization: ${avgUtilization.toFixed(1)}%)</span>`;
                
                initializeDashboard();
                
            } catch (error) {
                document.getElementById('payrollZipStatus').innerHTML = 
                    '<span style="color: var(--danger);">‚ùå Error processing zip file</span>';
                console.error('Zip processing error:', error);
            }
        });
        
        // Zip File Handler for Attendance Report (VSP Name Mapping)
        document.getElementById('attendanceZipFile').addEventListener('change', async function(e) {
            const file = e.target.files[0];
            if (!file) return;
            
            document.getElementById('attendanceZipStatus').innerHTML = '<span class="spinner"></span> Processing attendance data...';
            
            // Check if it's a CSV file
            if (file.name.endsWith('.csv')) {
                // Handle CSV file directly
                Papa.parse(file, {
                    header: true,
                    skipEmptyLines: true,
                    complete: function(results) {
                        try {
                            // Store the full attendance data
                            window.attendanceData = results.data;
                            
                            // Build email to name mapping
                            results.data.forEach(row => {
                                const email = (row['Staff E-mail'] || '').toLowerCase().trim();
                                const name = (row['Staff Name'] || '').trim();
                                
                                if (email && name && !staffEmailToName[email]) {
                                    staffEmailToName[email] = name;
                                }
                            });
                            
                            const mappingCount = Object.keys(staffEmailToName).length;
                            const attendanceCount = results.data.length;
                            document.getElementById('attendanceZipStatus').innerHTML = 
                                `<span style="color: var(--success);">‚úÖ Loaded ${attendanceCount} attendance records from ${mappingCount} VSPs</span>`;
                            
                            // Re-render tabs to update staff names and attendance metrics
                            if (appointmentsData.length > 0) {
                                renderAllTabs();
                            }
                        } catch (error) {
                            console.error('CSV processing error:', error);
                            document.getElementById('attendanceZipStatus').innerHTML = 
                                '<span style="color: var(--danger);">‚ùå Error processing CSV: ' + error.message + '</span>';
                        }
                    },
                    error: function(error) {
                        console.error('Parse error:', error);
                        document.getElementById('attendanceZipStatus').innerHTML = 
                            '<span style="color: var(--danger);">‚ùå Error parsing CSV</span>';
                    }
                });
                return;
            }
            
            // Handle ZIP file
            try {
                const zip = await JSZip.loadAsync(file);
                
                let found = false;
                // Look for the combined attendance report
                for (const [filename, zipEntry] of Object.entries(zip.files)) {
                    if (zipEntry.dir) continue;
                    
                    if (filename.includes('attendance-report-combined')) {
                        found = true;
                        const content = await zipEntry.async('text');
                        
                        // Wrap Papa.parse in a Promise to properly await it
                        await new Promise((resolve, reject) => {
                            Papa.parse(content, {
                                header: true,
                                skipEmptyLines: true,
                                complete: function(results) {
                                    try {
                                        // Store the full attendance data
                                        window.attendanceData = results.data;
                                        
                                        // Build email to name mapping
                                        results.data.forEach(row => {
                                            const email = (row['Staff E-mail'] || '').toLowerCase().trim();
                                            const name = (row['Staff Name'] || '').trim();
                                            
                                            if (email && name && !staffEmailToName[email]) {
                                                staffEmailToName[email] = name;
                                            }
                                        });
                                        
                                        const mappingCount = Object.keys(staffEmailToName).length;
                                        const attendanceCount = results.data.length;
                                        document.getElementById('attendanceZipStatus').innerHTML = 
                                            `<span style="color: var(--success);">‚úÖ Loaded ${attendanceCount} attendance records from ${mappingCount} VSPs</span>`;
                                        
                                        // Re-render tabs to update staff names and attendance metrics
                                        if (appointmentsData.length > 0) {
                                            renderAllTabs();
                                        }
                                        
                                        resolve();
                                    } catch (error) {
                                        reject(error);
                                    }
                                },
                                error: function(error) {
                                    console.error('Parse error:', error);
                                    document.getElementById('attendanceZipStatus').innerHTML = 
                                        '<span style="color: var(--danger);">‚ùå Error parsing attendance data</span>';
                                    reject(error);
                                }
                            });
                        });
                        break;
                    }
                }
                
                if (!found) {
                    document.getElementById('attendanceZipStatus').innerHTML = 
                        '<span style="color: var(--warning);">‚ö†Ô∏è No attendance-report-combined file found in zip</span>';
                }
                
            } catch (error) {
                document.getElementById('attendanceZipStatus').innerHTML = 
                    '<span style="color: var(--danger);">‚ùå Error processing zip file: ' + error.message + '</span>';
                console.error('Zip processing error:', error);
            }
        });
        
        // Initialize Dashboard
        function initializeDashboard() {
            if (appointmentsData.length === 0) return;
            
            hideEmptyState();
            
            document.getElementById('filtersSection').style.display = 'block';
            document.getElementById('mainTabs').style.display = 'flex';
            
            populateFilters();
            applyFilters(); // Apply initial filters to populate filtered data
            renderAllTabs();
        }
        
        // Populate Filters
        function populateFilters() {
            const months = new Set();
            const locations = new Set();
            const practitioners = new Set();
            const services = new Set();
            
            appointmentsData.forEach(row => {
                const date = parseDate(row['Appointment Date']);
                const monthKey = `${date.getFullYear()}-${String(date.getMonth() + 1).padStart(2, '0')}`;
                months.add(monthKey);
                
                if (row.Location) locations.add(row.Location);
                if (row['Practitioner First Name'] && row['Practitioner Last Name']) {
                    practitioners.add(`${row['Practitioner First Name']} ${row['Practitioner Last Name']}`);
                }
                if (row['Appointment']) services.add(row['Appointment']);
            });
            
            // Populate month filter
            const monthFilter = document.getElementById('monthFilter');
            monthFilter.innerHTML = '<option value="all">All Months</option>';
            Array.from(months).sort().reverse().forEach(month => {
                const [year, mon] = month.split('-');
                const date = new Date(year, mon - 1);
                const label = date.toLocaleDateString('en-US', { month: 'long', year: 'numeric' });
                monthFilter.innerHTML += `<option value="${month}">${label}</option>`;
            });
            
            // Populate location filter
            const locationFilter = document.getElementById('locationFilter');
            locationFilter.innerHTML = '<option value="all">All Locations</option>';
            Array.from(locations).sort().forEach(loc => {
                locationFilter.innerHTML += `<option value="${loc}">${loc}</option>`;
            });
            
            // Populate practitioner filter
            const practitionerFilter = document.getElementById('practitionerFilter');
            practitionerFilter.innerHTML = '<option value="all">All VSPs</option>';
            Array.from(practitioners).sort().forEach(prac => {
                practitionerFilter.innerHTML += `<option value="${prac}">${prac}</option>`;
            });
            
            // Populate service filter
            const serviceFilter = document.getElementById('serviceFilter');
            serviceFilter.innerHTML = '<option value="all">All Services</option>';
            Array.from(services).sort().forEach(service => {
                serviceFilter.innerHTML += `<option value="${service}">${service}</option>`;
            });
            
            // Add event listeners
            ['monthFilter', 'locationFilter', 'practitionerFilter', 'serviceFilter', 'startDate', 'endDate'].forEach(id => {
                document.getElementById(id).addEventListener('change', applyFilters);
            });
        }
        
        // Display Active Filters
        function displayActiveFilters() {
            const month = document.getElementById('monthFilter').value;
            const location = document.getElementById('locationFilter').value;
            const practitioner = document.getElementById('practitionerFilter').value;
            const service = document.getElementById('serviceFilter').value;
            const startDate = document.getElementById('startDate').value;
            const endDate = document.getElementById('endDate').value;
            
            let badges = [];
            
            if (month !== 'all') {
                const [year, mon] = month.split('-');
                const date = new Date(year, mon - 1);
                const label = date.toLocaleDateString('en-US', { month: 'short', year: 'numeric' });
                badges.push(label);
            }
            if (location !== 'all') badges.push(location);
            if (practitioner !== 'all') badges.push(practitioner);
            if (service !== 'all') badges.push(service.substring(0, 30));
            if (startDate && endDate) badges.push(`${startDate} to ${endDate}`);
            else if (startDate) badges.push(`From ${startDate}`);
            else if (endDate) badges.push(`Until ${endDate}`);
            
            const display = document.getElementById('activeFiltersDisplay');
            if (badges.length > 0) {
                display.innerHTML = '<strong>Active Filters:</strong> ' + 
                    badges.map(b => `<span class="filter-badge">${b}</span>`).join('');
                display.classList.add('show');
            } else {
                display.classList.remove('show');
            }
        }
        
        // Recalculate Utilization Based on Filtered Data
        function recalculateUtilization() {
            if (!window.timeTrackingData || window.timeTrackingData.length === 0) {
                return; // No time tracking data available
            }
            
            const month = document.getElementById('monthFilter').value;
            const startDate = document.getElementById('startDate').value;
            const endDate = document.getElementById('endDate').value;
            
            // Filter time tracking data by the same date range as appointments
            const filteredTimeTracking = window.timeTrackingData.filter(row => {
                const clockedIn = row['Clocked in'] ? new Date(row['Clocked in']) : null;
                if (!clockedIn) return false;
                
                // Month filter
                if (month !== 'all') {
                    const rowMonth = `${clockedIn.getFullYear()}-${String(clockedIn.getMonth() + 1).padStart(2, '0')}`;
                    if (rowMonth !== month) return false;
                }
                
                // Date range filters
                if (startDate && clockedIn < new Date(startDate)) return false;
                if (endDate && clockedIn > new Date(endDate)) return false;
                
                return true;
            });
            
            // Recalculate utilization for each employee based on filtered data
            const employeeUtilization = {};
            
            // Get unique employee names from filtered appointments
            const employeeNames = new Set();
            filteredAppointments.forEach(a => {
                if (a['Employee Name']) {
                    employeeNames.add(a['Employee Name']);
                }
            });
            
            // Calculate utilization for each employee
            employeeNames.forEach(employeeName => {
                const employeeAppts = filteredAppointments.filter(a => a['Employee Name'] === employeeName);
                const employeeTime = filteredTimeTracking.filter(t => t['Employee Name'] === employeeName);
                
                const totalApptHours = employeeAppts.reduce((sum, a) => {
                    const hours = parseFloat(a['Time (h)'] || a['Time booked (h)'] || 0);
                    return sum + hours;
                }, 0);
                
                const totalClockedHours = employeeTime.reduce((sum, t) => {
                    const hours = parseFloat(t['Duration (h)'] || 0);
                    return sum + hours;
                }, 0);
                
                const utilization = totalClockedHours > 0 
                    ? (totalApptHours / totalClockedHours * 100) 
                    : 0;
                
                employeeUtilization[employeeName] = {
                    totalApptHours: totalApptHours,
                    totalClockedHours: totalClockedHours,
                    utilization: utilization,
                    appointmentCount: employeeAppts.length,
                    shiftCount: employeeTime.length
                };
            });
            
            // Update the global employeeUtilization object
            window.employeeUtilization = employeeUtilization;
        }
        
        // Get Active Member Emails (for revenue exclusion)
        function getActiveMemberEmails() {
            const activeMemberEmails = new Set();
            if (membershipsData && membershipsData.length > 0) {
                membershipsData.forEach(m => {
                    // Only include active (non-expired) memberships
                    if (m.Expired !== 'Yes' && m['Customer Email']) {
                        activeMemberEmails.add(m['Customer Email'].toLowerCase().trim());
                    }
                });
            }
            return activeMemberEmails;
        }
        
        // Calculate appointment revenue excluding active members
        function calculateAppointmentRevenue(appointments) {
            const activeMemberEmails = getActiveMemberEmails();
            return appointments.reduce((sum, row) => {
                const customerEmail = (row['Customer Email'] || '').toLowerCase().trim();
                // Exclude revenue from active members
                if (activeMemberEmails.has(customerEmail)) {
                    return sum;
                }
                return sum + parseFloat(row.Revenue || 0);
            }, 0);
        }
        
        // Apply Filters
        function applyFilters() {
            // üêõ DEBUG: Track every time applyFilters is called


            const month = document.getElementById('monthFilter').value;
            const location = document.getElementById('locationFilter').value;
            const practitioner = document.getElementById('practitionerFilter').value;
            const service = document.getElementById('serviceFilter').value;
            const startDate = document.getElementById('startDate').value;
            const endDate = document.getElementById('endDate').value;








            // Check Chris before filtering
            const chrisBeforeFilter = leadsData.find(r => r['E-mail'] && r['E-mail'].toLowerCase().includes('cdahl'));

            // Filter appointments
            filteredAppointments = appointmentsData.filter(row => {
                const date = parseDate(row['Appointment Date']);
                
                // Month filter
                if (month !== 'all') {
                    const rowMonth = `${date.getFullYear()}-${String(date.getMonth() + 1).padStart(2, '0')}`;
                    if (rowMonth !== month) return false;
                }
                
                // Location filter
                if (location !== 'all' && row.Location !== location) return false;
                
                // Practitioner filter
                if (practitioner !== 'all') {
                    const rowPractitioner = `${row['Practitioner First Name']} ${row['Practitioner Last Name']}`;
                    if (rowPractitioner !== practitioner) return false;
                }
                
                // Service filter
                if (service !== 'all' && row['Appointment'] !== service) return false;
                
                // Date range filters
                if (startDate && date < new Date(startDate)) return false;
                if (endDate && date > new Date(endDate)) return false;
                
                return true;
            });
            
            // Filter memberships by date range (use Bought Date/Time converted to local timezone)
            filteredMemberships = membershipsData.filter(row => {
                const boughtDate = row['Bought Date/Time (GMT)'] ? convertGMTtoLocal(row['Bought Date/Time (GMT)']) : null;
                if (!boughtDate) return false;
                
                // Month filter
                if (month !== 'all') {
                    const rowMonth = `${boughtDate.getFullYear()}-${String(boughtDate.getMonth() + 1).padStart(2, '0')}`;
                    if (rowMonth !== month) return false;
                }
                
                // Date range filters
                if (startDate && boughtDate < new Date(startDate)) return false;
                if (endDate && boughtDate > new Date(endDate)) return false;
                
                return true;
            });
            
            // Filter leads by date range (use Join date or First purchase date as fallback)
            
            // üêõ DEBUG: Track Chris through ALL filtering steps



            // Check if leadsData has been loaded yet
            if (leadsData.length === 0) {


                filteredLeads = [];

            } else {
                // Step 0: Check original data
                const chrisInOriginal = leadsData.find(r => r['E-mail'] && r['E-mail'].toLowerCase().includes('cdahl'));



                if (chrisInOriginal) {

                }
                
                // üêõ DEBUG: Log filtering settings





                // Track Chris through the filter
                let chrisPassedDateFilter = false;
                let chrisFailureReason = null;
                
                filteredLeads = leadsData.filter(row => {
                    const isChris = row['E-mail'] && row['E-mail'].toLowerCase().includes('cdahl');
                    
                    // Try Join date first, then First purchase date
                    const joinDate = row['Join date'] ? parseDate(row['Join date']) : 
                                     row['First purchase date'] ? parseDate(row['First purchase date']) : null;
                    
                    if (isChris) {




                    }
                    
                    // If no date at all, include them (they might be legacy data)
                    if (!joinDate) {
                        if (isChris) {

                            chrisPassedDateFilter = true;
                        }
                        return true;
                    }
                    
                    // Month filter
                    if (month !== 'all') {
                        const rowMonth = `${joinDate.getFullYear()}-${String(joinDate.getMonth() + 1).padStart(2, '0')}`;
                        if (isChris) {



                        }
                        if (rowMonth !== month) {
                            if (isChris) {

                                chrisFailureReason = `Month filter (${rowMonth} !== ${month})`;
                            }
                            return false;
                        }
                    }
                    
                    // Date range filters
                    if (startDate && joinDate < new Date(startDate)) {
                        if (isChris) {




                            chrisFailureReason = `Start date (${joinDate} < ${startDate})`;
                        }
                        return false;
                    }
                    
                    if (endDate && joinDate > new Date(endDate)) {
                        if (isChris) {




                            chrisFailureReason = `End date (${joinDate} > ${endDate})`;
                        }
                        return false;
                    }
                    
                    if (isChris) {

                        chrisPassedDateFilter = true;
                    }
                    
                    return true;
                });



                // Check if Chris is in filtered results
                const chrisInFiltered = filteredLeads.find(row => row['E-mail'] && row['E-mail'].toLowerCase().includes('cdahl'));

                if (!chrisInFiltered && chrisInOriginal) {



                } else if (chrisInFiltered) {


                }

            }
            
            // Filter leads converted data by date range
            filteredLeadsConverted = leadsConvertedData.filter(row => {
                const convertedDate = row['Converted'] ? parseDate(row['Converted']) : null;
                if (!convertedDate) return false; // Exclude leads without converted dates
                
                // Month filter
                if (month !== 'all') {
                    const rowMonth = `${convertedDate.getFullYear()}-${String(convertedDate.getMonth() + 1).padStart(2, '0')}`;
                    if (rowMonth !== month) return false;
                }
                
                // Date range filters
                if (startDate && convertedDate < new Date(startDate)) return false;
                if (endDate && convertedDate > new Date(endDate)) return false;
                
                return true;
            });
            
            // Filter membership cancellations by date range (use Cancelled at)
            filteredCancellations = membershipCancellationsData.filter(row => {
                const cancelledDate = row['Cancelled at'] ? parseDate(row['Cancelled at']) : null;
                if (!cancelledDate) return false;
                
                // Month filter
                if (month !== 'all') {
                    const rowMonth = `${cancelledDate.getFullYear()}-${String(cancelledDate.getMonth() + 1).padStart(2, '0')}`;
                    if (rowMonth !== month) return false;
                }
                
                // Date range filters
                if (startDate && cancelledDate < new Date(startDate)) return false;
                if (endDate && cancelledDate > new Date(endDate)) return false;
                
                return true;
            });
            
            // Filter commissions by date range
            if (window.commissionsData && window.commissionsData.length > 0) {
                window.filteredCommissions = window.commissionsData.filter(row => {
                    const commDate = row['Date'] ? new Date(row['Date']) : null;
                    if (!commDate) return false;
                    
                    // Month filter
                    if (month !== 'all') {
                        const rowMonth = `${commDate.getFullYear()}-${String(commDate.getMonth() + 1).padStart(2, '0')}`;
                        if (rowMonth !== month) return false;
                    }
                    
                    // Date range filters
                    if (startDate && commDate < new Date(startDate)) return false;
                    if (endDate && commDate > new Date(endDate)) return false;
                    
                    return true;
                });
            }
            
            // Filter time tracking by date range and location (via practitioners)
            if (window.timeTrackingData && window.timeTrackingData.length > 0) {
                // First, get the list of practitioners from the filtered appointments
                // This ensures we only count time tracking for practitioners at the selected location/filters
                const practitionersInFiltered = new Set();
                filteredAppointments.forEach(row => {
                    const empName = row['Employee Name'];
                    if (empName) {
                        practitionersInFiltered.add(empName);
                    }
                });

                filteredTimeTracking = window.timeTrackingData.filter(row => {
                    if (!row['Employee Name']) return false;
                    
                    // FIXED: Use "Clocked in" not "Clock in date"
                    const clockedDate = parseDate(row['Clocked in']);
                    if (!clockedDate) return false;
                    
                    // CRITICAL: Only include time tracking for practitioners who have appointments in filtered data
                    // If no appointments in filter, exclude ALL time tracking
                    if (!practitionersInFiltered.has(row['Employee Name'])) {
                        return false;
                    }
                    
                    // Month filter
                    if (month !== 'all') {
                        const rowMonth = `${clockedDate.getFullYear()}-${String(clockedDate.getMonth() + 1).padStart(2, '0')}`;
                        if (rowMonth !== month) return false;
                    }
                    
                    // Date range filters
                    if (startDate && clockedDate < new Date(startDate)) return false;
                    if (endDate && clockedDate > new Date(endDate + 'T23:59:59')) return false;
                    
                    // Practitioner filter
                    if (practitioner !== 'all' && row['Employee Name'] !== practitioner) return false;
                    
                    return true;
                });

            } else {
                filteredTimeTracking = [];
            }
            
            // Recalculate utilization based on filtered data
            recalculateUtilization();
            
            // üêõ DEBUG: Final state after all filtering


            const chrisAfterAllFilters = filteredLeads.find(r => r['E-mail'] && r['E-mail'].toLowerCase().includes('cdahl'));

            if (chrisAfterAllFilters) {



            } else if (chrisBeforeFilter) {

            }

            displayActiveFilters();
            renderAllTabs();
        }
        
        // Refresh data with current filters
        function refreshData() {
            applyFilters();
        }
        
        // Quick Filters
        function setQuickFilter(filter) {

            const today = new Date();
            const startDateInput = document.getElementById('startDate');
            const endDateInput = document.getElementById('endDate');
            const monthFilter = document.getElementById('monthFilter');
            
            // Reset filters
            if (filter === 'reset') {

                startDateInput.value = '';
                endDateInput.value = '';
                monthFilter.value = 'all';
                document.getElementById('locationFilter').value = 'all';
                document.getElementById('practitionerFilter').value = 'all';
                document.getElementById('serviceFilter').value = 'all';

                applyFilters();
                return;
            }
            
            // Apply quick filter
            switch(filter) {
                case '7days':
                    const sevenDaysAgo = new Date(today);
                    sevenDaysAgo.setDate(sevenDaysAgo.getDate() - 7);
                    startDateInput.value = sevenDaysAgo.toISOString().split('T')[0];
                    endDateInput.value = today.toISOString().split('T')[0];
                    monthFilter.value = 'all';
                    break;
                case '30days':
                    const thirtyDaysAgo = new Date(today);
                    thirtyDaysAgo.setDate(thirtyDaysAgo.getDate() - 30);
                    startDateInput.value = thirtyDaysAgo.toISOString().split('T')[0];
                    endDateInput.value = today.toISOString().split('T')[0];
                    monthFilter.value = 'all';
                    break;
                case '90days':
                    const ninetyDaysAgo = new Date(today);
                    ninetyDaysAgo.setDate(ninetyDaysAgo.getDate() - 90);
                    startDateInput.value = ninetyDaysAgo.toISOString().split('T')[0];
                    endDateInput.value = today.toISOString().split('T')[0];
                    monthFilter.value = 'all';
                    break;
                case 'thisMonth':
                    const monthStr = `${today.getFullYear()}-${String(today.getMonth() + 1).padStart(2, '0')}`;
                    monthFilter.value = monthStr;
                    startDateInput.value = '';
                    endDateInput.value = '';
                    break;
                case 'lastMonth':
                    const lastMonth = new Date(today.getFullYear(), today.getMonth() - 1, 1);
                    const lastMonthStr = `${lastMonth.getFullYear()}-${String(lastMonth.getMonth() + 1).padStart(2, '0')}`;
                    monthFilter.value = lastMonthStr;
                    startDateInput.value = '';
                    endDateInput.value = '';
                    break;
            }
            
            applyFilters();
        }
        
        // Tab Switching
        // Tab state tracking
        let renderedTabs = new Set();
        let currentActiveTab = 'overview';
        
        function switchTab(tabName) {
            document.querySelectorAll('.tab').forEach(t => t.classList.remove('active'));
            document.querySelectorAll('.tab-content').forEach(c => c.classList.remove('active'));
            
            event.target.classList.add('active');
            document.getElementById(tabName).classList.add('active');
            currentActiveTab = tabName;
            
            // Lazy render: only render tab if not already rendered or if data has changed
            if (!renderedTabs.has(tabName)) {
                renderTab(tabName);
                renderedTabs.add(tabName);
            }
        }
        
        // Get currently active tab
        function getCurrentActiveTab() {
            return currentActiveTab;
        }
        
        // Render specific tab
        function renderTab(tabName) {
            switch(tabName) {
                case 'overview': renderOverviewTab(); break;
                case 'memberships': if (membershipsData.length > 0) renderMembershipsTab(); break;
                case 'leads': renderLeadsTab(); break;
                case 'journey': renderJourneyTab(); break;
                case 'studios': renderStudiosTab(); break;
                case 'schedule': renderScheduleTab(); break;
                case 'customers': renderCustomersTab(); break;
                case 'practitioners': renderPractitionersTab(); break;
                case 'timeline': renderTimelineTab(); break;
                case 'insights': renderInsightsTab(); break;
            }
        }
        
        // Render All Tabs (only called when filters change)
        function renderAllTabs() {
            renderedTabs.clear(); // Clear cache when data changes
            renderOverviewTab(); // Always render overview
            renderedTabs.add('overview');
            
            // Also re-render the currently active tab if it's not overview
            const activeTab = getCurrentActiveTab();
            if (activeTab !== 'overview') {
                renderTab(activeTab);
                renderedTabs.add(activeTab);
            }
            // Other tabs will render lazily when clicked
        }
        
        // Get current period for goal tracking
        function getCurrentPeriod() {
            if (filteredAppointments.length === 0) return 'All Time';
            
            const month = document.getElementById('monthFilter').value;
            if (month !== 'all') {
                const [year, mon] = month.split('-');
                const date = new Date(year, mon - 1);
                return date.toLocaleDateString('en-US', { month: 'long', year: 'numeric' });
            }
            
            // Check if using date range
            const startDate = document.getElementById('startDate').value;
            const endDate = document.getElementById('endDate').value;
            
            if (startDate && endDate) {
                return `${startDate} to ${endDate}`;
            } else if (startDate) {
                return `From ${startDate}`;
            } else if (endDate) {
                return `Until ${endDate}`;
            }
            
            // Check if data spans single month
            const dates = filteredAppointments.map(row => parseDate(row['Appointment Date']));
            const minDate = new Date(Math.min(...dates));
            const maxDate = new Date(Math.max(...dates));
            
            if (minDate.getMonth() === maxDate.getMonth() && minDate.getFullYear() === maxDate.getFullYear()) {
                return minDate.toLocaleDateString('en-US', { month: 'long', year: 'numeric' });
            }
            
            return `${minDate.toLocaleDateString('en-US', { month: 'short', year: 'numeric' })} - ${maxDate.toLocaleDateString('en-US', { month: 'short', year: 'numeric' })}`;
        }

        // OVERVIEW TAB
        function renderOverviewTab() {
            const data = filteredAppointments;
            
            // Calculate appointment revenue EXCLUDING active members
            const apptRevenue = calculateAppointmentRevenue(data);
            
            // Calculate membership revenue if data is available
            let membershipRevenue = 0;
            if (filteredMemberships && filteredMemberships.length > 0) {
                membershipRevenue = filteredMemberships.reduce((sum, m) => sum + parseFloat(m['Paid Amount'] || 0), 0);
            }
            
            const totalRevenue = apptRevenue + membershipRevenue;
            const totalPayout = data.reduce((sum, row) => sum + parseFloat(row['Total Payout'] || 0), 0);
            const totalHours = data.reduce((sum, row) => sum + parseFloat(row['Time (h)'] || 0), 0);
            const avgRevenue = data.length > 0 ? apptRevenue / data.length : 0;
            
            // Calculate total labor costs including non-appointment work
            let totalLaborCost = totalPayout;
            let nonApptHours = 0;
            let nonApptLaborCost = 0;
            
            if (filteredTimeTracking && filteredTimeTracking.length > 0) {
                // Get the list of practitioners who have appointments in the filtered data
                const practitionersInFiltered = new Set();
                data.forEach(row => {
                    const empName = row['Employee Name'];
                    if (empName) {
                        practitionersInFiltered.add(empName);
                    }
                });
                
                // Only count time tracking for practitioners who have appointments in the filtered data
                const relevantTimeTracking = filteredTimeTracking.filter(t => 
                    practitionersInFiltered.has(t['Employee Name'])
                );
                
                const totalClockedHours = relevantTimeTracking.reduce((sum, t) => {
                    const hours = parseFloat(t['Duration (h)'] || 0);
                    return sum + hours;
                }, 0);
                
                // Non-appointment hours = clocked hours - appointment hours
                nonApptHours = Math.max(0, totalClockedHours - totalHours);
                nonApptLaborCost = nonApptHours * CONFIG.baseHourlyRate;
                totalLaborCost = totalPayout + nonApptLaborCost;
            }
            
            // Calculate salary costs for the filtered period
            let salaryCosts = { total: 0, details: [] };
            if (data.length > 0) {
                const dates = data.map(row => parseDate(row['Appointment Date']));
                const minDate = new Date(Math.min(...dates));
                const maxDate = new Date(Math.max(...dates));
                salaryCosts = calculateSalaryCosts(minDate, maxDate);
                totalLaborCost += salaryCosts.total;
            }
            
            const profit = totalRevenue - totalLaborCost;
            const profitMargin = totalRevenue > 0 ? (profit / totalRevenue * 100) : 0;
            
            // Count intro sessions and late cancellations
            const introSessions = data.filter(row => isIntroOffer(row['Appointment'])).length;
            const lateCancellations = data.filter(row => 
                row['Late cancellations'] && row['Late cancellations'].toLowerCase() === 'yes'
            ).length;
            
            // Unique clients
            const uniqueClients = new Set(
                data.map(row => (row['Customer Email'] || '').toLowerCase().trim())
                    .filter(email => email)
            ).size;
            
            // Revenue per hour
            const revenuePerHour = totalHours > 0 ? totalRevenue / totalHours : 0;
            
            // Average ticket size
            const avgTicketSize = data.length > 0 ? totalRevenue / data.length : 0;
            
            // Calculate utilization if data available
            let avgUtilization = null;
            if (window.employeeUtilization) {
                const utilizationValues = Object.values(window.employeeUtilization)
                    .map(e => e.utilization)
                    .filter(u => u > 0);
                if (utilizationValues.length > 0) {
                    avgUtilization = utilizationValues.reduce((sum, u) => sum + u, 0) / utilizationValues.length;
                }
            }
            
            // Client visit frequency
            const clientVisits = {};
            data.forEach(row => {
                const email = row['Customer Email'];
                if (email) {
                    clientVisits[email] = (clientVisits[email] || 0) + 1;
                }
            });
            const newClients = Object.values(clientVisits).filter(v => v === 1).length;
            const returningClients = uniqueClients - newClients;
            const avgVisitsPerClient = uniqueClients > 0 ? data.length / uniqueClients : 0;
            
            // Busiest day
            const dayCount = {};
            data.forEach(row => {
                const date = parseDate(row['Appointment Date']);
                if (date) {
                    const days = ['Sunday', 'Monday', 'Tuesday', 'Wednesday', 'Thursday', 'Friday', 'Saturday'];
                    const day = days[date.getDay()];
                    dayCount[day] = (dayCount[day] || 0) + 1;
                }
            });
            const busiestDay = Object.entries(dayCount).sort((a, b) => b[1] - a[1])[0];
            
            // Top paid service by appointments (excluding demo and intro)
            const serviceCount = {};
            data.forEach(row => {
                const service = row.Appointment;
                if (service && !isIntroOffer(service)) {
                    serviceCount[service] = (serviceCount[service] || 0) + 1;
                }
            });
            const topService = Object.entries(serviceCount).sort((a, b) => b[1] - a[1])[0];
            
            // Number of practitioners
            const uniquePractitioners = new Set(
                data.map(row => `${row['Practitioner First Name']} ${row['Practitioner Last Name']}`)
                    .filter(name => name.trim() !== '')
            ).size;
            const revenuePerPractitioner = uniquePractitioners > 0 ? totalRevenue / uniquePractitioners : 0;
            
            // Calculate comparison data if enabled
            if (document.getElementById('comparisonPeriod').value !== 'none') {
                calculateComparisonData();
            }
            
            let html = `
                ${comparisonData ? `<div class="alert info"><h4>üìä Period Comparison Active</h4><p>Comparing current period to: <strong>${comparisonData.period}</strong></p></div>` : ''}
                
                <div class="metrics-grid">
                    <div class="metric-card compact">
                        <div class="metric-label">Total Revenue</div>
                        <div class="metric-value">
                            ${formatCurrency(totalRevenue)}
                            ${comparisonData ? getComparisonIndicator(totalRevenue, comparisonData.revenue, 'currency') : ''}
                        </div>
                        <div class="metric-subtext">
                            ${membershipRevenue > 0 
                                ? `Appointments: ${formatCurrency(apptRevenue)} | Memberships: ${formatCurrency(membershipRevenue)}`
                                : `From ${formatNumber(data.length)} appointments`
                            }
                        </div>
                        ${comparisonData ? `<div class="comparison-details">vs ${formatCurrency(comparisonData.revenue)} last period</div>` : ''}
                    </div>
                    <div class="metric-card compact">
                        <div class="metric-label">Appointments</div>
                        <div class="metric-value">
                            ${formatNumber(data.length)}
                            ${comparisonData ? getComparisonIndicator(data.length, comparisonData.appointments) : ''}
                        </div>
                        <div class="metric-subtext">Total bookings</div>
                        ${comparisonData ? `<div class="comparison-details">vs ${formatNumber(comparisonData.appointments)} last period</div>` : ''}
                    </div>
                    <div class="metric-card compact">
                        <div class="metric-label">Unique Clients</div>
                        <div class="metric-value">
                            ${formatNumber(uniqueClients)}
                            ${comparisonData ? getComparisonIndicator(uniqueClients, comparisonData.clients) : ''}
                        </div>
                        <div class="metric-subtext">${formatNumber(newClients)} new, ${formatNumber(returningClients)} returning</div>
                        ${comparisonData ? `<div class="comparison-details">vs ${formatNumber(comparisonData.clients)} last period</div>` : ''}
                    </div>
                    ${avgUtilization !== null ? `
                    <div class="metric-card compact success">
                        <div class="metric-label">Utilization</div>
                        <div class="metric-value">${avgUtilization.toFixed(1)}%</div>
                        <div class="metric-subtext">Table time efficiency</div>
                    </div>
                    ` : ''}
                    <div class="metric-card compact">
                        <div class="metric-label">Revenue/Hour</div>
                        <div class="metric-value">${formatCurrency(revenuePerHour)}</div>
                        <div class="metric-subtext">${formatNumber(totalHours)} total hours</div>
                    </div>
                    <div class="metric-card compact">
                        <div class="metric-label">Avg Ticket Size</div>
                        <div class="metric-value">${formatCurrency(avgTicketSize)}</div>
                        <div class="metric-subtext">Per appointment</div>
                    </div>
                    <div class="metric-card compact">
                        <div class="metric-label">Client Frequency</div>
                        <div class="metric-value">${avgVisitsPerClient.toFixed(1)}</div>
                        <div class="metric-subtext">Avg visits per client</div>
                    </div>
                    <div class="metric-card compact">
                        <div class="metric-label">Revenue per VSP</div>
                        <div class="metric-value">${formatCurrency(revenuePerPractitioner)}</div>
                        <div class="metric-subtext">${formatNumber(uniquePractitioners)} VSPs</div>
                    </div>

                    ${membershipRevenue > 0 ? `
                    <div class="metric-card compact" style="background: linear-gradient(135deg, rgba(156, 39, 176, 0.1), rgba(123, 31, 162, 0.05)); border-left: 4px solid #9c27b0;">
                        <div class="metric-label">üí≥ Total Memberships</div>
                        <div class="metric-value">${formatNumber(membershipsData.filter(m => m.Expired !== 'Yes').length)}</div>
                        <div class="metric-subtext">${formatNumber(membershipsData.length)} customers</div>
                    </div>
                    <div class="metric-card compact" style="background: linear-gradient(135deg, rgba(40, 167, 69, 0.1), rgba(32, 201, 151, 0.05)); border-left: 4px solid #28a745;">
                        <div class="metric-label">üíµ Membership Revenue</div>
                        <div class="metric-value">${formatCurrency(membershipRevenue)}</div>
                        <div class="metric-subtext">Avg ${formatCurrency(membershipRevenue / membershipsData.length)} per membership</div>
                    </div>
                    <div class="metric-card compact" style="background: linear-gradient(135deg, rgba(0, 123, 255, 0.1), rgba(0, 86, 179, 0.05)); border-left: 4px solid #007bff;">
                        <div class="metric-label">üîÑ Monthly Recurring Revenue</div>
                        <div class="metric-value">${formatCurrency(membershipsData.filter(m => m['Membership Type'] === 'subscription' && m.Expired !== 'Yes').reduce((sum, m) => sum + (parseFloat(m['Paid Amount']) || 0), 0))}</div>
                        <div class="metric-subtext">From ${formatNumber(membershipsData.filter(m => m['Membership Type'] === 'subscription' && m.Expired !== 'Yes').length)} active subscriptions</div>
                    </div>
                    <div class="metric-card compact" style="background: linear-gradient(135deg, rgba(33, 150, 243, 0.1), rgba(13, 71, 161, 0.05)); border-left: 4px solid #2196f3;">
                        <div class="metric-label">‚ùÑÔ∏è Frozen Memberships</div>
                        <div class="metric-value">${formatNumber(membershipsData.filter(m => m.Frozen === 'Yes').length)}</div>
                        <div class="metric-subtext">${((membershipsData.filter(m => m.Frozen === 'Yes').length / membershipsData.length) * 100).toFixed(1)}% of total memberships</div>
                    </div>
                    <div class="metric-card compact" style="background: linear-gradient(135deg, rgba(244, 67, 54, 0.1), rgba(211, 47, 47, 0.05)); border-left: 4px solid #f44336;">
                        <div class="metric-label">üí∏ Refunded Memberships</div>
                        <div class="metric-value">${formatNumber(membershipsData.filter(m => parseFloat(m.Refunded) > 0).length)}</div>
                        <div class="metric-subtext">${formatCurrency(membershipsData.reduce((sum, m) => sum + (parseFloat(m.Refunded) || 0), 0))} total refunded</div>
                    </div>
                    <div class="metric-card compact" style="background: linear-gradient(135deg, rgba(255, 193, 7, 0.1), rgba(255, 152, 0, 0.05)); border-left: 4px solid #ffc107;">
                        <div class="metric-label">üìä Retention Rate</div>
                        <div class="metric-value">${((membershipsData.filter(m => m.Expired !== 'Yes').length / membershipsData.length) * 100).toFixed(1)}%</div>
                        <div class="metric-subtext">${formatNumber(membershipsData.filter(m => m.Expired !== 'Yes').length)} active of ${formatNumber(membershipsData.length)} total</div>
                    </div>
                    ${membershipCancellationsData && membershipCancellationsData.length > 0 ? `
                    <div class="metric-card compact" style="background: linear-gradient(135deg, rgba(244, 67, 54, 0.15), rgba(211, 47, 47, 0.08)); border-left: 4px solid #f44336;">
                        <div class="metric-label">üö´ Total Cancellations</div>
                        <div class="metric-value">${formatNumber(membershipCancellationsData.length)}</div>
                        <div class="metric-subtext">${((membershipCancellationsData.length / membershipsData.length) * 100).toFixed(1)}% of total sales</div>
                    </div>
                    <div class="metric-card compact" style="background: linear-gradient(135deg, rgba(255, 152, 0, 0.15), rgba(230, 81, 0, 0.08)); border-left: 4px solid #ff9800;">
                        <div class="metric-label">üìä Churn Rate</div>
                        <div class="metric-value">${((membershipCancellationsData.length / membershipsData.length) * 100).toFixed(1)}%</div>
                        <div class="metric-subtext">Cancellations vs sales</div>
                    </div>
                    ` : ''}
                    ` : ''}
                </div>
                
                <div class="table-container" style="background: linear-gradient(135deg, rgba(251, 181, 20, 0.05), rgba(251, 181, 20, 0.02)); border-left: 5px solid var(--highlight);">
                    <h2>Financial Performance</h2>
                    <div class="metrics-grid" style="grid-template-columns: repeat(${3 + (nonApptHours > 0 ? 1 : 0) + (salaryCosts.total > 0 ? 1 : 0)}, 1fr);">
                        <div class="metric-card ${profit > 0 ? 'success' : 'danger'}">
                            <div class="metric-label">Net Profit</div>
                            <div class="metric-value">
                                ${formatCurrency(profit)}
                                ${comparisonData ? getComparisonIndicator(profit, comparisonData.profit, 'currency') : ''}
                            </div>
                            <div class="metric-subtext">${profitMargin.toFixed(1)}% margin</div>
                            ${comparisonData ? `<div class="comparison-details">vs ${formatCurrency(comparisonData.profit)} last period</div>` : ''}
                        </div>
                        <div class="metric-card warning">
                            <div class="metric-label">Total Labor Cost</div>
                            <div class="metric-value">${formatCurrency(totalLaborCost)}</div>
                            <div class="metric-subtext">${((totalLaborCost / totalRevenue) * 100).toFixed(1)}% of revenue</div>
                        </div>
                        <div class="metric-card">
                            <div class="metric-label">Appointment Payouts</div>
                            <div class="metric-value">${formatCurrency(totalPayout)}</div>
                            <div class="metric-subtext">${formatNumber(totalHours)} appt hours</div>
                        </div>
                        ${nonApptHours > 0 ? `
                        <div class="metric-card">
                            <div class="metric-label">Non-Appt Labor</div>
                            <div class="metric-value">${formatCurrency(nonApptLaborCost)}</div>
                            <div class="metric-subtext">${formatNumber(nonApptHours)} hrs @ ${formatCurrency(CONFIG.baseHourlyRate)}/hr</div>
                        </div>
                        ` : ''}
                        ${salaryCosts.total > 0 ? `
                        <div class="metric-card">
                            <div class="metric-label">Salaried Employees</div>
                            <div class="metric-value">${formatCurrency(salaryCosts.total)}</div>
                            <div class="metric-subtext">${salaryCosts.details.length} employee(s)</div>
                        </div>
                        ` : ''}
                    </div>
                    ${(nonApptHours > 0 || salaryCosts.total > 0) ? `
                    <div class="alert info" style="margin-top: 15px;">
                        <h4>üí° Labor Cost Breakdown</h4>
                        <p style="margin: 8px 0;">
                            <strong>Appointment-Based Labor:</strong> ${formatCurrency(totalPayout)} 
                            (${formatNumber(totalHours)} hours at commission rates)<br>
                            ${nonApptHours > 0 ? `<strong>Non-Appointment Labor:</strong> ${formatCurrency(nonApptLaborCost)} 
                            (${formatNumber(nonApptHours)} hours at base rate of ${formatCurrency(CONFIG.baseHourlyRate)}/hr)<br>` : ''}
                            ${salaryCosts.total > 0 ? `<strong>Salaried Employees:</strong> ${formatCurrency(salaryCosts.total)}<br>
                            ${salaryCosts.details.map(emp => 
                                `&nbsp;&nbsp;‚Ä¢ ${emp.name}: ${formatCurrency(emp.proratedCost)} (${emp.daysWorked} days @ ${formatCurrency(emp.annualSalary)}/year)`
                            ).join('<br>')}<br>` : ''}
                            <strong>Total Labor Cost:</strong> ${formatCurrency(totalLaborCost)} 
                            (${((totalLaborCost / totalRevenue) * 100).toFixed(1)}% of revenue)
                        </p>
                        <p style="margin-top: 10px; font-size: 12px; color: #666;">
                            ${nonApptHours > 0 ? 'Non-appointment hours include cleaning, admin work, training, and other clocked time without appointments. ' : ''}
                            ${salaryCosts.total > 0 ? 'Salaried employee costs are prorated based on their start dates. ' : ''}
                            Adjust settings in <strong>‚öôÔ∏è Franchise Configuration</strong> for accurate profitability tracking.
                        </p>
                    </div>
                    ` : ''}
                </div>
                
                <div class="table-container" style="background: linear-gradient(135deg, rgba(220, 53, 69, 0.05), rgba(220, 53, 69, 0.02)); border-left: 5px solid var(--danger);">
                    <h2>Franchise Fees</h2>
                    <div class="metrics-grid" style="grid-template-columns: repeat(4, 1fr);">
                        <div class="metric-card danger">
                            <div class="metric-label">üè¢ Franchise Fee</div>
                            <div class="metric-value">${formatCurrency(totalRevenue * CONFIG.franchiseFeePercent / 100)}</div>
                            <div class="metric-subtext">${CONFIG.franchiseFeePercent}% of revenue</div>
                        </div>
                        <div class="metric-card danger">
                            <div class="metric-label">üéØ Brand Fund</div>
                            <div class="metric-value">${formatCurrency(totalRevenue * CONFIG.brandFundPercent / 100)}</div>
                            <div class="metric-subtext">${CONFIG.brandFundPercent}% of revenue</div>
                        </div>
                        <div class="metric-card danger">
                            <div class="metric-label">üí≥ CC Processing</div>
                            <div class="metric-value">${formatCurrency(totalRevenue * CONFIG.ccFeesPercent / 100)}</div>
                            <div class="metric-subtext">${CONFIG.ccFeesPercent}% of revenue</div>
                        </div>
                        <div class="metric-card danger" style="background: linear-gradient(135deg, rgba(220, 53, 69, 0.15), rgba(220, 53, 69, 0.05));">
                            <div class="metric-label">üí∏ Total Fees</div>
                            <div class="metric-value">${formatCurrency(totalRevenue * (CONFIG.franchiseFeePercent + CONFIG.brandFundPercent + CONFIG.ccFeesPercent) / 100)}</div>
                            <div class="metric-subtext">${((CONFIG.franchiseFeePercent + CONFIG.brandFundPercent + CONFIG.ccFeesPercent)).toFixed(1)}% of revenue</div>
                        </div>
                    </div>
                    <div class="alert info" style="margin-top: 15px;">
                        <h4>üí° Fee Impact on Net Profit</h4>
                        <p style="margin: 8px 0;">
                            <strong>Gross Revenue:</strong> ${formatCurrency(totalRevenue)}<br>
                            <strong>Less: Franchise Fees:</strong> -${formatCurrency(totalRevenue * (CONFIG.franchiseFeePercent + CONFIG.brandFundPercent + CONFIG.ccFeesPercent) / 100)} 
                            (${((CONFIG.franchiseFeePercent + CONFIG.brandFundPercent + CONFIG.ccFeesPercent)).toFixed(1)}% total)<br>
                            <strong>Less: Labor Costs:</strong> -${formatCurrency(totalLaborCost)}<br>
                            <strong>Net Profit After Fees & Labor:</strong> ${formatCurrency(totalRevenue - totalLaborCost - (totalRevenue * (CONFIG.franchiseFeePercent + CONFIG.brandFundPercent + CONFIG.ccFeesPercent) / 100))} 
                            (${((totalRevenue - totalLaborCost - (totalRevenue * (CONFIG.franchiseFeePercent + CONFIG.brandFundPercent + CONFIG.ccFeesPercent) / 100)) / totalRevenue * 100).toFixed(1)}% margin)
                        </p>
                        <p style="margin-top: 10px; font-size: 12px; color: #666;">
                            Configure fee percentages in <strong>‚öôÔ∏è Franchise Configuration</strong> to match your franchise agreement.
                        </p>
                    </div>
                </div>
                
                <div class="charts-grid">
                    <div class="chart-container">
                        <h3>Revenue by Location</h3>
                        <div class="chart-wrapper">
                            <canvas id="revenueByLocationChart"></canvas>
                        </div>
                    </div>
                    
                    <div class="chart-container">
                        <div class="interactive-badge" title="Click on any service to see practitioner breakdown"></div>
                        <h3>Revenue by Service</h3>
                        <div class="chart-wrapper">
                            <canvas id="revenueByServiceChart"></canvas>
                        </div>
                    </div>
                    
                    <div class="chart-container">
                        <h3>Introductory Offers</h3>
                        <div class="chart-wrapper">
                            <canvas id="introSessionsChart"></canvas>
                        </div>
                    </div>
                </div>
                
                <div class="table-container">
                    <h2>AI-Powered Recommendations</h2>
                    <p style="margin-bottom: 20px; color: #666;">Smart insights based on your data patterns and industry best practices.</p>
                    ${(() => {
                        const recommendations = generateSmartRecommendations();
                        if (recommendations.length === 0) {
                            return '<div class="alert success"><h4>üéâ Excellent Performance!</h4><p>Your metrics are strong across the board. Keep up the great work!</p></div>';
                        }
                        return recommendations.slice(0, 3).map(rec => `
                            <div class="recommendation-card">
                                <span class="recommendation-priority ${rec.priority}">${rec.priority.toUpperCase()} PRIORITY</span>
                                <div class="recommendation-title">${rec.title}</div>
                                <p style="margin: 10px 0; color: #666;">${rec.description}</p>
                                <p style="margin: 10px 0;"><strong>Recommended Action:</strong> ${rec.action}</p>
                                <div class="recommendation-impact">
                                    <strong>üí∞ Potential Impact:</strong> ${rec.impact}
                                </div>
                            </div>
                        `).join('');
                    })()}
                    <p style="margin-top: 15px; text-align: center; color: #666; font-style: italic;">
                        View more recommendations in the <strong>üí° Insights</strong> tab
                    </p>
                </div>
            `;
            
            document.getElementById('overview').innerHTML = html;
            
            // Render charts
            setTimeout(() => {
                renderRevenueByLocationChart();
                renderRevenueByServiceChart();
                renderIntroSessionsChart();
            }, 100);
        }
        
        // FUNNEL TAB

        // RETENTION TAB
        function renderRetentionTab() {
            const data = filteredAppointments;
            const activeMemberEmails = getActiveMemberEmails();
            
            // Analyze client visits
            const clientVisits = {};
            const clientFirstVisit = {};
            const clientLastVisit = {};
            const clientRevenue = {};
            
            data.forEach(row => {
                const email = (row['Customer Email'] || '').toLowerCase().trim();
                if (!email) return;
                
                const date = parseDate(row['Appointment Date']);
                const revenue = parseFloat(row.Revenue || 0);
                // Only count revenue if customer is NOT an active member
                const revenueToAdd = activeMemberEmails.has(email) ? 0 : revenue;
                
                if (!clientVisits[email]) {
                    clientVisits[email] = 0;
                    clientFirstVisit[email] = date;
                    clientLastVisit[email] = date;
                    clientRevenue[email] = 0;
                }
                
                clientVisits[email]++;
                clientRevenue[email] += revenueToAdd;
                
                if (date < clientFirstVisit[email]) clientFirstVisit[email] = date;
                if (date > clientLastVisit[email]) clientLastVisit[email] = date;
            });
            
            // Calculate metrics
            const uniqueClients = Object.keys(clientVisits).length;
            const returningClients = Object.values(clientVisits).filter(count => count > 1).length;
            const retentionRate = uniqueClients > 0 ? (returningClients / uniqueClients * 100) : 0;
            const avgVisitsPerClient = uniqueClients > 0 ? data.length / uniqueClients : 0;
            
            // Visit frequency distribution
            const visitDist = { '1 visit': 0, '2-3 visits': 0, '4-6 visits': 0, '7-10 visits': 0, '11+ visits': 0 };
            Object.values(clientVisits).forEach(count => {
                if (count === 1) visitDist['1 visit']++;
                else if (count <= 3) visitDist['2-3 visits']++;
                else if (count <= 6) visitDist['4-6 visits']++;
                else if (count <= 10) visitDist['7-10 visits']++;
                else visitDist['11+ visits']++;
            });
            
            // Calculate average days between visits
            let totalDaysBetween = 0;
            let visitPairs = 0;
            
            Object.keys(clientVisits).forEach(email => {
                if (clientVisits[email] > 1) {
                    const daysBetween = (clientLastVisit[email] - clientFirstVisit[email]) / (1000 * 60 * 60 * 24);
                    const avgDaysForClient = daysBetween / (clientVisits[email] - 1);
                    totalDaysBetween += avgDaysForClient;
                    visitPairs++;
                }
            });
            
            const avgDaysBetweenVisits = visitPairs > 0 ? totalDaysBetween / visitPairs : 0;
            
            // Top clients by visits
            const topClientsByVisits = Object.entries(clientVisits)
                .map(([email, visits]) => ({
                    email,
                    visits,
                    revenue: clientRevenue[email],
                    firstVisit: clientFirstVisit[email],
                    lastVisit: clientLastVisit[email]
                }))
                .sort((a, b) => b.visits - a.visits)
                .slice(0, 10);
            
            // Find client names from data
            const clientNames = {};
            data.forEach(row => {
                const email = (row['Customer Email'] || '').toLowerCase().trim();
                if (email && !clientNames[email]) {
                    clientNames[email] = row['Customer Name'] || email;
                }
            });
            
            let html = `
                <div class="metrics-grid" style="grid-template-columns: repeat(4, 1fr);">
                    <div class="metric-card">
                        <div class="metric-label">Total Clients</div>
                        <div class="metric-value">${formatNumber(uniqueClients)}</div>
                        <div class="metric-subtext">Unique individuals</div>
                    </div>
                    <div class="metric-card ${retentionRate >= 50 ? 'success' : retentionRate >= 30 ? 'warning' : 'danger'}">
                        <div class="metric-label">Retention Rate</div>
                        <div class="metric-value">${retentionRate.toFixed(1)}%</div>
                        <div class="metric-subtext">${formatNumber(returningClients)} returning clients</div>
                    </div>
                    <div class="metric-card">
                        <div class="metric-label">Avg Visits</div>
                        <div class="metric-value">${avgVisitsPerClient.toFixed(1)}</div>
                        <div class="metric-subtext">Per client</div>
                    </div>
                    <div class="metric-card">
                        <div class="metric-label">Avg Days Between</div>
                        <div class="metric-value">${avgDaysBetweenVisits.toFixed(0)}</div>
                        <div class="metric-subtext">Days between visits</div>
                    </div>
                </div>
                
                <div class="alert ${retentionRate >= 50 ? 'success' : 'warning'}">
                    <h4>üîÑ Retention Analysis</h4>
                    <p><strong>Current Status:</strong> ${retentionRate.toFixed(0)}% of clients return for additional appointments.</p>
                    <ul style="margin: 10px 0 0 20px; line-height: 1.8;">
                        <li>${visitDist['1 visit']} clients (${((visitDist['1 visit']/uniqueClients)*100).toFixed(0)}%) visited only once</li>
                        <li>Average ${avgDaysBetweenVisits.toFixed(0)} days between visits for returning clients</li>
                        <li>${returningClients} loyal clients generating repeat business</li>
                    </ul>
                    <p style="margin-top: 15px;"><strong>üí° Recommendations:</strong></p>
                    <ul style="margin: 5px 0 0 20px; line-height: 1.8;">
                        <li>Follow up with one-time visitors within ${Math.ceil(avgDaysBetweenVisits/2)} days</li>
                        <li>Create membership packages for ${visitDist['4-6 visits'] + visitDist['7-10 visits'] + visitDist['11+ visits']} frequent visitors</li>
                        <li>Send rebooking reminders every ${Math.floor(avgDaysBetweenVisits * 0.8)} days</li>
                    </ul>
                </div>
                
                <div class="table-container">
                    <h2>Visit Frequency Distribution</h2>
                    <div style="display: grid; grid-template-columns: repeat(auto-fit, minmax(150px, 1fr)); gap: 15px; margin: 20px 0;">
                        ${Object.entries(visitDist).map(([range, count]) => `
                            <div style="background: var(--gray-light); padding: 20px; border-radius: 8px; text-align: center; border-left: 4px solid var(--accent);">
                                <div style="font-size: 2.5em; font-weight: bold; color: var(--primary);">${formatNumber(count)}</div>
                                <div style="color: #666; font-size: 14px; margin-top: 5px;">${range} visit${range === '1' ? '' : 's'}</div>
                                <div style="color: var(--accent); font-size: 12px; margin-top: 3px;">${((count/uniqueClients)*100).toFixed(1)}%</div>
                            </div>
                        `).join('')}
                    </div>
                </div>
                
                <div class="table-container">
                    <h2>Top 10 Clients by Visit Frequency</h2>
                    <table>
                        <thead>
                            <tr>
                                <th>Rank</th>
                                <th>Client</th>
                                <th>Total Visits</th>
                                <th>Total Revenue</th>
                                <th>Avg/Visit</th>
                                <th>First Visit</th>
                                <th>Last Visit</th>
                                <th>Days Between</th>
                            </tr>
                        </thead>
                        <tbody>
                            ${topClientsByVisits.map((client, i) => {
                                const avgPerVisit = client.revenue / client.visits;
                                const daysBetween = client.visits > 1 
                                    ? Math.round((client.lastVisit - client.firstVisit) / (1000 * 60 * 60 * 24) / (client.visits - 1))
                                    : 'N/A';
                                return `
                                    <tr>
                                        <td><strong>${i === 0 ? 'ü•á' : i === 1 ? 'ü•à' : i === 2 ? 'ü•â' : i + 1}</strong></td>
                                        <td>${clientNames[client.email] || client.email}</td>
                                        <td><strong>${client.visits}</strong></td>
                                        <td>${formatCurrency(client.revenue)}</td>
                                        <td>${formatCurrency(avgPerVisit)}</td>
                                        <td>${client.firstVisit.toLocaleDateString()}</td>
                                        <td>${client.lastVisit.toLocaleDateString()}</td>
                                        <td>${daysBetween}</td>
                                    </tr>
                                `;
                            }).join('')}
                        </tbody>
                    </table>
                </div>
                
                <div class="table-container">
                    <h2>At-Risk Clients</h2>
                    <p style="margin-bottom: 15px; color: #666;">Returning clients who haven't visited in over ${Math.floor(avgDaysBetweenVisits * 1.5)} days (1.5x average gap)</p>
                    ${(() => {
                        const today = new Date();
                        const atRiskClients = topClientsByVisits
                            .filter(client => client.visits > 1)
                            .map(client => {
                                const daysSinceLastVisit = Math.floor((today - client.lastVisit) / (1000 * 60 * 60 * 24));
                                return { ...client, daysSinceLastVisit };
                            })
                            .filter(client => client.daysSinceLastVisit > avgDaysBetweenVisits * 1.5)
                            .sort((a, b) => b.revenue - a.revenue)
                            .slice(0, 20);
                        
                        if (atRiskClients.length === 0) {
                            return '<div class="alert success"><h4>üéâ Great News!</h4><p>No at-risk clients identified. All returning clients are visiting regularly!</p></div>';
                        }
                        
                        const totalAtRiskRevenue = atRiskClients.reduce((sum, c) => sum + c.revenue, 0);
                        
                        return `
                            <div class="alert warning">
                                <h4>üìä At-Risk Analysis</h4>
                                <p><strong>${atRiskClients.length} returning clients</strong> haven't visited recently. They represent <strong>${formatCurrency(totalAtRiskRevenue)}</strong> in historical revenue.</p>
                                <p style="margin-top: 10px;"><strong>Action:</strong> Reach out with a "We miss you" message and a special comeback offer.</p>
                            </div>
                            <table>
                                <thead>
                                    <tr>
                                        <th>Client</th>
                                        <th>Total Visits</th>
                                        <th>Revenue</th>
                                        <th>Last Visit</th>
                                        <th>Days Ago</th>
                                        <th>Status</th>
                                    </tr>
                                </thead>
                                <tbody>
                                    ${atRiskClients.map(client => {
                                        const urgency = client.daysSinceLastVisit > avgDaysBetweenVisits * 2 ? 'HIGH' : 'MEDIUM';
                                        const urgencyColor = urgency === 'HIGH' ? '#dc3545' : '#ffc107';
                                        return `
                                            <tr>
                                                <td>${clientNames[client.email] || client.email}</td>
                                                <td>${client.visits}</td>
                                                <td>${formatCurrency(client.revenue)}</td>
                                                <td>${client.lastVisit.toLocaleDateString()}</td>
                                                <td><strong>${client.daysSinceLastVisit}</strong> days</td>
                                                <td><span style="background: ${urgencyColor}; color: white; padding: 4px 12px; border-radius: 12px; font-size: 11px; font-weight: bold;">${urgency}</span></td>
                                            </tr>
                                        `;
                                    }).join('')}
                                </tbody>
                            </table>
                        `;
                    })()}
                </div>
                
                <div class="charts-grid">
                    <div class="chart-container">
                        <div class="interactive-badge" title="Click on any bar to see detailed client list"></div>
                        <h3>Visit Frequency Distribution</h3>
                        <div class="chart-wrapper">
                            <canvas id="visitFrequencyChart"></canvas>
                        </div>
                    </div>
                    
                    <div class="chart-container">
                        <div class="interactive-badge" title="Click on any segment to see client details"></div>
                        <h3>Retention Breakdown</h3>
                        <div class="chart-wrapper">
                            <canvas id="retentionBreakdownChart"></canvas>
                        </div>
                    </div>
                </div>
            `;
            
            document.getElementById('retention').innerHTML = html;
            
            // Render charts
            setTimeout(() => {
                renderVisitFrequencyChart(visitDist);
                renderRetentionBreakdownChart(uniqueClients - returningClients, returningClients);
            }, 100);
        }
        
        // STUDIOS TAB
        function renderStudiosTab() {
            const data = filteredAppointments;
            const activeMemberEmails = getActiveMemberEmails();
            
            // Get all unique locations
            const locations = [...new Set(data.map(row => row.Location).filter(l => l))].sort();
            
            if (locations.length === 0) {
                document.getElementById('studios').innerHTML = `
                    <div class="alert info">
                        <h4>üìç Studio Analytics</h4>
                        <p>No location data available. Upload appointment data with location information to see studio-specific metrics.</p>
                    </div>
                `;
                return;
            }
            
            // Calculate metrics for each studio
            const studioMetrics = {};
            
            locations.forEach(location => {
                const locationData = data.filter(row => row.Location === location);
                
                // Group by month for trends
                const monthlyData = {};
                
                locationData.forEach(row => {
                    const date = parseDate(row['Appointment Date']);
                    const monthKey = `${date.getFullYear()}-${String(date.getMonth() + 1).padStart(2, '0')}`;
                    
                    if (!monthlyData[monthKey]) {
                        monthlyData[monthKey] = {
                            appointments: 0,
                            revenue: 0,
                            hours: 0,
                            clockedHours: 0,
                            clients: new Set()
                        };
                    }
                    
                    const email = (row['Customer Email'] || '').toLowerCase().trim();
                    const revenue = parseFloat(row.Revenue || 0);
                    const revenueToAdd = activeMemberEmails.has(email) ? 0 : revenue;
                    
                    monthlyData[monthKey].appointments++;
                    monthlyData[monthKey].revenue += revenueToAdd;
                    monthlyData[monthKey].hours += parseFloat(row['Time (h)'] || 0);
                    if (email) monthlyData[monthKey].clients.add(email);
                });
                
                // Add clocked hours if available
                if (window.timeTrackingData && window.timeTrackingData.length > 0) {
                    window.timeTrackingData.forEach(row => {
                        if (row.Location === location) {
                            const clockedIn = row['Clocked in'] ? new Date(row['Clocked in']) : null;
                            if (clockedIn) {
                                const monthKey = `${clockedIn.getFullYear()}-${String(clockedIn.getMonth() + 1).padStart(2, '0')}`;
                                if (monthlyData[monthKey]) {
                                    monthlyData[monthKey].clockedHours += parseFloat(row['Duration (h)'] || 0);
                                }
                            }
                        }
                    });
                }
                
                // Calculate totals and averages
                const totalRevenue = locationData.reduce((sum, row) => {
                    const email = (row['Customer Email'] || '').toLowerCase().trim();
                    const revenue = parseFloat(row.Revenue || 0);
                    return sum + (activeMemberEmails.has(email) ? 0 : revenue);
                }, 0);
                
                const totalAppointments = locationData.length;
                const uniqueClients = new Set(locationData.map(row => (row['Customer Email'] || '').toLowerCase().trim()).filter(e => e)).size;
                const avgRevenuePerAppt = totalAppointments > 0 ? totalRevenue / totalAppointments : 0;
                
                // Calculate lead conversion for this location
                let locationLeads = [];
                let locationIntros = 0;
                let locationPaid = 0;
                
                // Try filteredLeadsConverted first (converted leads report)
                if (filteredLeadsConverted && filteredLeadsConverted.length > 0) {
                    locationLeads = filteredLeadsConverted.filter(lead => lead['Home location'] === location);
                    const convertedLeads = locationLeads.filter(l => {
                        const convertedTo = (l['Converted to'] || '').trim();
                        return convertedTo && convertedTo !== 'N/A' && convertedTo !== '';
                    });
                    locationIntros = convertedLeads.length;
                    locationPaid = convertedLeads.filter(l => (l['Converted to'] || '').toLowerCase().includes('paid')).length;
                } 
                // Fall back to filteredLeads (new leads & customers report)
                else if (filteredLeads && filteredLeads.length > 0) {
                    locationLeads = filteredLeads.filter(lead => (lead['Home location'] || lead['Location']) === location);
                    const customers = locationLeads.filter(l => l.Type === 'Customer');
                    locationIntros = customers.length;
                    locationPaid = customers.filter(l => parseLTV(l.LTV) > 0).length;
                }
                
                const leadToIntroRate = locationLeads.length > 0 ? (locationIntros / locationLeads.length * 100) : 0;
                const introToPaidRate = locationIntros > 0 ? (locationPaid / locationIntros * 100) : 0;
                
                studioMetrics[location] = {
                    totalRevenue,
                    totalAppointments,
                    uniqueClients,
                    avgRevenuePerAppt,
                    monthlyData,
                    leads: locationLeads.length,
                    intros: locationIntros,
                    paid: locationPaid,
                    leadToIntroRate,
                    introToPaidRate
                };
            });
            
            // Build HTML with comparison table first
            let html = `
                <h2 style="margin-bottom: 20px;">üìç Studio Performance Overview</h2>
                
                <!-- Studio Comparison Table -->
                <div style="background: white; padding: 25px; border-radius: 15px; box-shadow: 0 5px 15px rgba(0,0,0,0.1); margin-bottom: 30px; overflow-x: auto;">
                    <h3 style="margin-bottom: 15px; color: var(--primary);">üìä Studio Comparison</h3>
                    <table style="width: 100%; border-collapse: collapse; font-size: 14px;">
                        <thead>
                            <tr style="background: var(--primary); color: white; border-bottom: 2px solid var(--accent);">
                                <th style="padding: 12px; text-align: left; font-weight: 600;">Studio</th>
                                <th style="padding: 12px; text-align: right; font-weight: 600;">Total Revenue</th>
                                <th style="padding: 12px; text-align: right; font-weight: 600;">Appointments</th>
                                <th style="padding: 12px; text-align: right; font-weight: 600;">Unique Clients</th>
                                <th style="padding: 12px; text-align: right; font-weight: 600;">Avg $/Appt</th>
                                <th style="padding: 12px; text-align: right; font-weight: 600;">Total Leads</th>
                                <th style="padding: 12px; text-align: right; font-weight: 600;">Lead‚ÜíIntro</th>
                                <th style="padding: 12px; text-align: right; font-weight: 600;">Intro‚ÜíPaid</th>
                            </tr>
                        </thead>
                        <tbody>
            `;
            
            // Sort studios by total revenue for comparison
            const sortedLocations = [...locations].sort((a, b) => 
                studioMetrics[b].totalRevenue - studioMetrics[a].totalRevenue
            );
            
            sortedLocations.forEach((location, idx) => {
                const metrics = studioMetrics[location];
                const rowStyle = idx % 2 === 0 ? 'background: #f9f9f9;' : '';
                html += `
                    <tr style="${rowStyle} border-bottom: 1px solid var(--gray);">
                        <td style="padding: 12px; font-weight: 600; color: var(--primary);">${location}</td>
                        <td style="padding: 12px; text-align: right;">${formatCurrency(metrics.totalRevenue)}</td>
                        <td style="padding: 12px; text-align: right;">${formatNumber(metrics.totalAppointments)}</td>
                        <td style="padding: 12px; text-align: right;">${formatNumber(metrics.uniqueClients)}</td>
                        <td style="padding: 12px; text-align: right;">${formatCurrency(metrics.avgRevenuePerAppt)}</td>
                        <td style="padding: 12px; text-align: right;">${metrics.leads > 0 ? formatNumber(metrics.leads) : 'N/A'}</td>
                        <td style="padding: 12px; text-align: right; ${metrics.leadToIntroRate > 50 ? 'color: var(--success); font-weight: 600;' : ''}">${metrics.leads > 0 ? metrics.leadToIntroRate.toFixed(1) + '%' : 'N/A'}</td>
                        <td style="padding: 12px; text-align: right; ${metrics.introToPaidRate > 50 ? 'color: var(--success); font-weight: 600;' : ''}">${metrics.intros > 0 ? metrics.introToPaidRate.toFixed(1) + '%' : 'N/A'}</td>
                    </tr>
                `;
            });
            
            html += `
                        </tbody>
                    </table>
                </div>
                
                <!-- Quick Stats Cards -->
                <div class="metrics-grid" style="grid-template-columns: repeat(${Math.min(locations.length, 4)}, 1fr); margin-bottom: 30px;">
            `;
            
            sortedLocations.forEach(location => {
                const metrics = studioMetrics[location];
                html += `
                    <div class="metric-card">
                        <div class="metric-label">${location}</div>
                        <div class="metric-value">${formatCurrency(metrics.totalRevenue)}</div>
                        <div class="metric-subtext">${formatNumber(metrics.totalAppointments)} appointments ‚Ä¢ ${formatNumber(metrics.uniqueClients)} clients</div>
                    </div>
                `;
            });
            
            html += `</div>`;
            
            // Add customer distribution by Home Location if available
            if (filteredLeads && filteredLeads.length > 0) {
                const homeLocationCounts = {};
                let totalWithHomeLocation = 0;
                
                filteredLeads.forEach(lead => {
                    const homeLocation = lead['Home location'] || 'Unknown';
                    if (homeLocation !== 'Unknown') {
                        homeLocationCounts[homeLocation] = (homeLocationCounts[homeLocation] || 0) + 1;
                        totalWithHomeLocation++;
                    }
                });
                
                if (totalWithHomeLocation > 0) {
                    html += `
                        <div style="background: white; padding: 25px; border-radius: 15px; box-shadow: 0 5px 15px rgba(0,0,0,0.1); margin-bottom: 30px;">
                            <h3 style="margin-bottom: 15px; color: var(--primary);">üè† Customer Home Location Distribution</h3>
                            <p style="color: #666; margin-bottom: 15px;">Based on ${totalWithHomeLocation.toLocaleString()} customers with recorded home location</p>
                            <div class="metrics-grid" style="grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));">
                    `;
                    
                    Object.entries(homeLocationCounts)
                        .sort((a, b) => b[1] - a[1])
                        .forEach(([location, count]) => {
                            const percentage = ((count / totalWithHomeLocation) * 100).toFixed(1);
                            html += `
                                <div class="metric-card compact">
                                    <div class="metric-label">${location}</div>
                                    <div class="metric-value">${count.toLocaleString()}</div>
                                    <div class="metric-subtext">${percentage}% of customers</div>
                                </div>
                            `;
                        });
                    
                    html += `
                            </div>
                        </div>
                    `;
                }
            }
            
            // Continue with detailed studio sections
            
            // Add detailed studio sections (sorted by revenue)
            sortedLocations.forEach(location => {
                const metrics = studioMetrics[location];
                const months = Object.keys(metrics.monthlyData).sort();
                
                // Calculate utilization for each month
                const monthlyUtilization = months.map(month => {
                    const data = metrics.monthlyData[month];
                    return data.clockedHours > 0 ? (data.hours / data.clockedHours * 100) : null;
                });
                
                const avgUtilization = monthlyUtilization.filter(u => u !== null).length > 0
                    ? monthlyUtilization.filter(u => u !== null).reduce((sum, u) => sum + u, 0) / monthlyUtilization.filter(u => u !== null).length
                    : null;
                
                html += `
                    <div style="background: white; padding: 25px; border-radius: 15px; box-shadow: 0 5px 15px rgba(0,0,0,0.1); margin-bottom: 30px; border-top: 4px solid var(--primary);">
                        <h2 style="margin-bottom: 20px;">üìç ${location}</h2>
                        
                        <div class="metrics-grid" style="grid-template-columns: repeat(5, 1fr); margin-bottom: 20px;">
                            <div class="metric-card compact">
                                <div class="metric-label">Total Revenue</div>
                                <div class="metric-value">${formatCurrency(metrics.totalRevenue)}</div>
                                <div class="metric-subtext">All time</div>
                            </div>
                            <div class="metric-card compact">
                                <div class="metric-label">Appointments</div>
                                <div class="metric-value">${formatNumber(metrics.totalAppointments)}</div>
                                <div class="metric-subtext">${formatNumber(metrics.uniqueClients)} clients</div>
                            </div>
                            <div class="metric-card compact">
                                <div class="metric-label">Avg Revenue/Appt</div>
                                <div class="metric-value">${formatCurrency(metrics.avgRevenuePerAppt)}</div>
                                <div class="metric-subtext">Per appointment</div>
                            </div>
                            ${avgUtilization !== null ? `
                            <div class="metric-card compact success">
                                <div class="metric-label">Avg Utilization</div>
                                <div class="metric-value">${avgUtilization.toFixed(1)}%</div>
                                <div class="metric-subtext">Table time</div>
                            </div>
                            ` : '<div class="metric-card compact"><div class="metric-label">Utilization</div><div class="metric-value">N/A</div></div>'}
                            ${metrics.leads > 0 ? `
                            <div class="metric-card compact">
                                <div class="metric-label">Total Leads</div>
                                <div class="metric-value">${formatNumber(metrics.leads)}</div>
                                <div class="metric-subtext">${metrics.intros} intros</div>
                            </div>
                            ` : '<div class="metric-card compact"><div class="metric-label">Leads</div><div class="metric-value">N/A</div></div>'}
                        </div>
                        
                        ${metrics.leads > 0 ? `
                        <div class="metrics-grid" style="grid-template-columns: repeat(2, 1fr); margin-bottom: 20px;">
                            <div class="metric-card">
                                <div class="metric-label">Lead ‚Üí Intro Conversion</div>
                                <div class="metric-value">${metrics.leadToIntroRate.toFixed(1)}%</div>
                                <div class="metric-subtext">${metrics.intros} of ${metrics.leads} leads</div>
                            </div>
                            <div class="metric-card">
                                <div class="metric-label">Intro ‚Üí Paid Conversion</div>
                                <div class="metric-value">${metrics.introToPaidRate.toFixed(1)}%</div>
                                <div class="metric-subtext">${metrics.paid} of ${metrics.intros} intros</div>
                            </div>
                        </div>
                        ` : ''}
                        
                        <div class="charts-grid">
                            ${avgUtilization !== null ? `
                            <div class="chart-container">
                                <h3>Monthly Utilization Trend</h3>
                                <div class="chart-wrapper">
                                    <canvas id="studioUtilization${location.replace(/\s+/g, '')}Chart"></canvas>
                                </div>
                            </div>
                            ` : ''}
                            
                            ${metrics.leads > 0 ? `
                            <div class="chart-container">
                                <h3>Monthly Conversion Rates</h3>
                                <div class="chart-wrapper">
                                    <canvas id="studioConversion${location.replace(/\s+/g, '')}Chart"></canvas>
                                </div>
                            </div>
                            ` : ''}
                            
                            <div class="chart-container">
                                <h3>Monthly Revenue</h3>
                                <div class="chart-wrapper">
                                    <canvas id="studioRevenue${location.replace(/\s+/g, '')}Chart"></canvas>
                                </div>
                            </div>
                            
                            <div class="chart-container">
                                <h3>Monthly Appointments</h3>
                                <div class="chart-wrapper">
                                    <canvas id="studioAppointments${location.replace(/\s+/g, '')}Chart"></canvas>
                                </div>
                            </div>
                        </div>
                    </div>
                `;
            });
            
            document.getElementById('studios').innerHTML = html;
            
            // Render charts
            setTimeout(() => {
                sortedLocations.forEach(location => {
                    const metrics = studioMetrics[location];
                    const months = Object.keys(metrics.monthlyData).sort();
                    const locationId = location.replace(/\s+/g, '');
                    
                    // Format month labels
                    const monthLabels = months.map(m => {
                        const [year, month] = m.split('-');
                        const date = new Date(year, parseInt(month) - 1);
                        return date.toLocaleDateString('en-US', { month: 'short', year: '2-digit' });
                    });
                    
                    // Utilization chart
                    const utilizationCanvas = document.getElementById(`studioUtilization${locationId}Chart`);
                    if (utilizationCanvas) {
                        const utilizationData = months.map(month => {
                            const data = metrics.monthlyData[month];
                            return data.clockedHours > 0 ? ((data.hours / data.clockedHours) * 100).toFixed(1) : null;
                        });
                        
                        destroyChart(`studioUtilization${locationId}`);
                        const ctx = utilizationCanvas.getContext('2d');
                        allCharts[`studioUtilization${locationId}`] = new Chart(ctx, {
                            type: 'line',
                            data: {
                                labels: monthLabels,
                                datasets: [{
                                    label: 'Utilization %',
                                    data: utilizationData,
                                    borderColor: '#28a745',
                                    backgroundColor: 'rgba(40, 167, 69, 0.1)',
                                    borderWidth: 3,
                                    fill: true,
                                    tension: 0.4
                                }]
                            },
                            options: {
                                responsive: true,
                                maintainAspectRatio: false,
                                plugins: { legend: { display: false } },
                                scales: {
                                    y: {
                                        beginAtZero: true,
                                        max: 100,
                                        ticks: {
                                            callback: function(value) { return value + '%'; }
                                        }
                                    }
                                }
                            }
                        });
                    }
                    
                    // Conversion rates chart
                    const conversionCanvas = document.getElementById(`studioConversion${locationId}Chart`);
                    if (conversionCanvas && metrics.leads > 0) {
                        destroyChart(`studioConversion${locationId}`);
                        const ctx = conversionCanvas.getContext('2d');
                        allCharts[`studioConversion${locationId}`] = new Chart(ctx, {
                            type: 'bar',
                            data: {
                                labels: ['Lead ‚Üí Intro', 'Intro ‚Üí Paid'],
                                datasets: [{
                                    label: 'Conversion Rate %',
                                    data: [metrics.leadToIntroRate, metrics.introToPaidRate],
                                    backgroundColor: ['#71BED2', '#FBB514'],
                                    borderWidth: 0
                                }]
                            },
                            options: {
                                responsive: true,
                                maintainAspectRatio: false,
                                plugins: { legend: { display: false } },
                                scales: {
                                    y: {
                                        beginAtZero: true,
                                        max: 100,
                                        ticks: {
                                            callback: function(value) { return value + '%'; }
                                        }
                                    }
                                }
                            }
                        });
                    }
                    
                    // Revenue chart
                    const revenueCanvas = document.getElementById(`studioRevenue${locationId}Chart`);
                    if (revenueCanvas) {
                        const revenueData = months.map(month => metrics.monthlyData[month].revenue);
                        
                        destroyChart(`studioRevenue${locationId}`);
                        const ctx = revenueCanvas.getContext('2d');
                        allCharts[`studioRevenue${locationId}`] = new Chart(ctx, {
                            type: 'bar',
                            data: {
                                labels: monthLabels,
                                datasets: [{
                                    label: 'Revenue',
                                    data: revenueData,
                                    backgroundColor: '#71BED2',
                                    borderWidth: 0
                                }]
                            },
                            options: {
                                responsive: true,
                                maintainAspectRatio: false,
                                plugins: {
                                    legend: { display: false },
                                    tooltip: {
                                        callbacks: {
                                            label: function(context) {
                                                return formatCurrency(context.parsed.y);
                                            }
                                        }
                                    }
                                },
                                scales: {
                                    y: {
                                        beginAtZero: true,
                                        ticks: {
                                            callback: function(value) {
                                                return formatCurrency(value);
                                            }
                                        }
                                    }
                                }
                            }
                        });
                    }
                    
                    // Appointments chart
                    const appointmentsCanvas = document.getElementById(`studioAppointments${locationId}Chart`);
                    if (appointmentsCanvas) {
                        const appointmentsData = months.map(month => metrics.monthlyData[month].appointments);
                        
                        destroyChart(`studioAppointments${locationId}`);
                        const ctx = appointmentsCanvas.getContext('2d');
                        allCharts[`studioAppointments${locationId}`] = new Chart(ctx, {
                            type: 'line',
                            data: {
                                labels: monthLabels,
                                datasets: [{
                                    label: 'Appointments',
                                    data: appointmentsData,
                                    borderColor: '#013160',
                                    backgroundColor: 'rgba(1, 49, 96, 0.1)',
                                    borderWidth: 3,
                                    fill: true,
                                    tension: 0.4
                                }]
                            },
                            options: {
                                responsive: true,
                                maintainAspectRatio: false,
                                plugins: { legend: { display: false } },
                                scales: {
                                    y: {
                                        beginAtZero: true,
                                        ticks: { stepSize: 1 }
                                    }
                                }
                            }
                        });
                    }
                });
            }, 100);
        }
        
        // SCHEDULE OPTIMIZATION TAB
        function renderScheduleTab() {
            const data = filteredAppointments;
            
            // Group appointments by practitioner and date
            const scheduleByPractitioner = {};
            
            data.forEach(row => {
                const practitioner = `${row['Practitioner First Name']} ${row['Practitioner Last Name']}`;
                const date = parseDate(row['Appointment Date']);
                const dateKey = date.toLocaleDateString();
                
                if (!scheduleByPractitioner[practitioner]) {
                    scheduleByPractitioner[practitioner] = {};
                }
                
                if (!scheduleByPractitioner[practitioner][dateKey]) {
                    scheduleByPractitioner[practitioner][dateKey] = [];
                }
                
                scheduleByPractitioner[practitioner][dateKey].push({
                    time: date,
                    duration: parseFloat(row['Time (h)'] || 0),
                    revenue: parseFloat(row.Revenue || 0),
                    service: row['Appointment'] || 'Unknown'
                });
            });
            
            // Calculate gaps and efficiency
            const gapAnalysis = [];
            let totalGaps = 0;
            let totalGapMinutes = 0;
            let totalWorkingHours = 0;
            let totalPayout = 0;
            let totalRevenueForPayout = 0;
            
            Object.entries(scheduleByPractitioner).forEach(([practitioner, dates]) => {
                Object.entries(dates).forEach(([date, appointments]) => {
                    // Sort by time
                    appointments.sort((a, b) => a.time - b.time);
                    
                    if (appointments.length < 2) return;
                    
                    let dayGaps = 0;
                    let dayGapMinutes = 0;
                    let dayWorkingHours = 0;
                    
                    // Calculate gaps between appointments
                    for (let i = 0; i < appointments.length - 1; i++) {
                        const current = appointments[i];
                        const next = appointments[i + 1];
                        
                        const currentEnd = new Date(current.time.getTime() + current.duration * 60 * 60 * 1000);
                        const gapMinutes = (next.time - currentEnd) / (1000 * 60);
                        
                        if (gapMinutes > 15) { // Consider gaps over 15 minutes
                            dayGaps++;
                            dayGapMinutes += gapMinutes;
                            totalGaps++;
                            totalGapMinutes += gapMinutes;
                        }
                        
                        dayWorkingHours += current.duration;
                    }
                    
                    if (appointments.length > 0) {
                        dayWorkingHours += appointments[appointments.length - 1].duration;
                    }
                    
                    totalWorkingHours += dayWorkingHours;
                    
                    const utilizationRate = dayWorkingHours > 0 
                        ? ((dayWorkingHours - (dayGapMinutes / 60)) / dayWorkingHours * 100) 
                        : 0;
                    
                    if (dayGaps > 0) {
                        gapAnalysis.push({
                            practitioner,
                            date,
                            appointments: appointments.length,
                            gaps: dayGaps,
                            gapMinutes: dayGapMinutes,
                            workingHours: dayWorkingHours,
                            utilizationRate,
                            potentialRevenue: (dayGapMinutes / 60) * 150
                        });
                    }
                });
            });
            
            // Calculate average hourly payout for lost wages calculation
            data.forEach(row => {
                totalPayout += parseFloat(row['Total Payout'] || 0);
                totalRevenueForPayout += parseFloat(row.Revenue || 0);
            });
            
            const avgPayoutRate = totalRevenueForPayout > 0 ? (totalPayout / totalRevenueForPayout) : 0.5;
            const avgHourlyRevenue = 150; // Assumed from potential revenue calc
            const avgHourlyPayout = avgHourlyRevenue * avgPayoutRate;
            const lostWages = (totalGapMinutes / 60) * avgHourlyPayout;
            
            // Sort by largest gaps
            gapAnalysis.sort((a, b) => b.gapMinutes - a.gapMinutes);
            
            // Calculate overall metrics
            const avgGapMinutes = totalGaps > 0 ? totalGapMinutes / totalGaps : 0;
            const overallUtilization = totalWorkingHours > 0 
                ? ((totalWorkingHours - (totalGapMinutes / 60)) / totalWorkingHours * 100) 
                : 0;
            const potentialRevenue = (totalGapMinutes / 60) * 150;
            const costOfGap = potentialRevenue - lostWages; // Business lost profit (revenue that would have stayed with business)
            
            let html = `
                <div class="metrics-grid" style="grid-template-columns: repeat(6, 1fr);">
                    <div class="metric-card ${overallUtilization >= 80 ? 'success' : overallUtilization >= 60 ? 'warning' : 'danger'}">
                        <div class="metric-label">Schedule Efficiency</div>
                        <div class="metric-value">${overallUtilization.toFixed(1)}%</div>
                        <div class="metric-subtext">Overall utilization</div>
                    </div>
                    <div class="metric-card">
                        <div class="metric-label">Total Gaps</div>
                        <div class="metric-value">${formatNumber(totalGaps)}</div>
                        <div class="metric-subtext">${(totalGapMinutes / 60).toFixed(1)} hours</div>
                    </div>
                    <div class="metric-card">
                        <div class="metric-label">Avg Gap Duration</div>
                        <div class="metric-value">${avgGapMinutes.toFixed(0)} min</div>
                        <div class="metric-subtext">Per gap</div>
                    </div>
                    <div class="metric-card warning">
                        <div class="metric-label">Cost of Gap</div>
                        <div class="metric-value">${formatCurrency(costOfGap)}</div>
                        <div class="metric-subtext">Lost business profit</div>
                    </div>
                    <div class="metric-card danger">
                        <div class="metric-label">Lost Wages</div>
                        <div class="metric-value">${formatCurrency(lostWages)}</div>
                        <div class="metric-subtext">VSP opportunity cost</div>
                    </div>
                    <div class="metric-card success">
                        <div class="metric-label">Potential Revenue</div>
                        <div class="metric-value">${formatCurrency(potentialRevenue)}</div>
                        <div class="metric-subtext">From filling gaps</div>
                    </div>
                </div>
                
                <div class="table-container" style="position: relative;">
                    <div class="interactive-badge" title="Click any day to see detailed breakdown" style="position: absolute; top: 15px; right: 15px; display: flex;"></div>
                    <h2>Appointment Heatmap by Location</h2>
                    <p style="margin-bottom: 15px; color: #666;">Busiest appointment times by day and hour (Monday-Saturday). Click any day to see detailed breakdown.</p>
                    <div id="heatmapContainer"></div>
                </div>
                
                <div class="alert ${overallUtilization >= 80 ? 'success' : overallUtilization >= 60 ? 'warning' : 'info'}">
                    <h4>‚è∞ Schedule Optimization Insights</h4>
                    <p>
                        ${overallUtilization >= 80 
                            ? '‚úÖ Excellent scheduling efficiency! Your practitioners have minimal gaps.' 
                            : overallUtilization >= 60
                            ? '‚ö†Ô∏è Good scheduling, but there are opportunities to fill gaps and increase revenue.'
                            : 'üìà Significant scheduling gaps detected. Optimizing could substantially increase revenue.'}
                    </p>
                    <ul style="margin: 10px 0 0 20px; line-height: 1.8;">
                        <li>Offer discounted "fill-in" appointments for last-minute bookings</li>
                        <li>Block schedule appointments closer together when possible</li>
                        <li>Consider adding express services (30-45 min) to fill small gaps</li>
                        <li>Review practitioner availability patterns to match demand</li>
                        <li><strong>Cost to business:</strong> ${formatCurrency(costOfGap)} in lost profit from scheduling gaps</li>
                        <li><strong>Lost wages for VSPs:</strong> ${formatCurrency(lostWages)} in opportunity cost</li>
                        <li><strong>Potential additional revenue:</strong> ${formatCurrency(potentialRevenue)} by filling all gaps</li>
                    </ul>
                </div>
                
                <div class="table-container">
                    <h2>Top 20 Days with Largest Scheduling Gaps</h2>
                    <p style="margin-bottom: 15px; color: #666;">Opportunities to optimize scheduling and increase revenue</p>
                    <table>
                        <thead>
                            <tr>
                                <th>Practitioner</th>
                                <th>Date</th>
                                <th>Appointments</th>
                                <th>Gaps</th>
                                <th>Gap Time</th>
                                <th>Utilization</th>
                                <th>Opportunity</th>
                            </tr>
                        </thead>
                        <tbody>
                            ${gapAnalysis.slice(0, 20).map(day => `
                                <tr>
                                    <td>${day.practitioner}</td>
                                    <td>${day.date}</td>
                                    <td>${day.appointments}</td>
                                    <td>${day.gaps}</td>
                                    <td>${day.gapMinutes.toFixed(0)} min</td>
                                    <td><span style="color: ${day.utilizationRate >= 80 ? 'var(--success)' : day.utilizationRate >= 60 ? 'var(--warning)' : 'var(--danger)'}">${day.utilizationRate.toFixed(1)}%</span></td>
                                    <td>${formatCurrency(day.potentialRevenue)}</td>
                                </tr>
                            `).join('')}
                        </tbody>
                    </table>
                </div>
            `;
            
            document.getElementById('schedule').innerHTML = html;
            
            // Render heatmap after setting innerHTML
            setTimeout(() => {
                renderHeatmap();
            }, 100);
        }
        
        // CLIENT SEGMENTATION FUNCTIONS
        function calculateClientSegments() {
            const today = new Date();
            const segments = {
                vip: [],
                atRisk: [],
                newClient: [],
                highFrequency: [],
                inactivePaidMember: []
            };
            
            // Get current VIP threshold from LTV tier configuration
            const currentTierConfig = LTV_TIERS[CONFIG.ltvTiers];
            const vipMin = currentTierConfig.vipMin;
            
            // Create a map of customer data with visit information
            const customerMap = {};
            
            // Aggregate data from leadsData
            filteredLeads.forEach(lead => {
                const email = lead['E-mail'];
                if (email && !customerMap[email]) {
                    customerMap[email] = {
                        firstName: lead['First name'],
                        lastName: lead['Last name'],
                        email: email,
                        type: lead.Type,
                        ltv: parseLTV(lead.LTV),
                        joinDate: lead['Join date'],
                        visits: [],
                        totalVisits: 0,
                        lastVisitDate: null,
                        hasActiveMembership: false,
                        membershipName: null,
                        membershipAmount: 0
                    };
                }
            });
            
            // Add membership information
            filteredMemberships.forEach(membership => {
                const email = membership['Customer Email'];
                const expired = membership.Expired === 'Yes';
                const frozen = membership.Frozen === 'Yes';
                
                if (email && customerMap[email] && !expired && !frozen) {
                    customerMap[email].hasActiveMembership = true;
                    customerMap[email].membershipName = membership['Membership Name'];
                    customerMap[email].membershipAmount = parseFloat(membership['Paid Amount'] || 0);
                }
            });
            
            // Add appointment visit data
            filteredAppointments.forEach(appt => {
                const email = appt['Customer Email'];
                const apptDate = new Date(appt['Appointment Date']);
                
                if (email && customerMap[email]) {
                    customerMap[email].visits.push(apptDate);
                    customerMap[email].totalVisits++;
                    
                    if (!customerMap[email].lastVisitDate || apptDate > customerMap[email].lastVisitDate) {
                        customerMap[email].lastVisitDate = apptDate;
                    }
                }
            });
            
            // Categorize customers into segments
            Object.values(customerMap).forEach(customer => {
                // VIP tier (use dynamic vipMin from tier configuration)
                if (customer.ltv > vipMin) {
                    segments.vip.push({...customer, segment: 'VIP'});
                }
                
                // Inactive Paid Member (has active membership but no visit in 30+ days)
                if (customer.hasActiveMembership) {
                    const daysSinceLastVisit = customer.lastVisitDate 
                        ? Math.floor((today - customer.lastVisitDate) / (1000 * 60 * 60 * 24))
                        : 999; // Large number if no visit ever
                    
                    if (daysSinceLastVisit >= 30) {
                        segments.inactivePaidMember.push({
                            ...customer, 
                            daysSinceLastVisit, 
                            segment: 'Inactive Paid Member'
                        });
                    }
                }
                
                // At-risk tier (haven't visited in 45+ days, with at least $50 revenue)
                if (customer.lastVisitDate) {
                    const daysSinceLastVisit = Math.floor((today - customer.lastVisitDate) / (1000 * 60 * 60 * 24));
                    if (daysSinceLastVisit >= 45 && customer.totalVisits > 0 && customer.ltv >= 50) {
                        segments.atRisk.push({...customer, daysSinceLastVisit, segment: 'At-Risk'});
                    }
                }
                
                // New client tier (<3 visits, with at least $50 revenue)
                if (customer.totalVisits > 0 && customer.totalVisits < 3 && customer.ltv >= 50) {
                    segments.newClient.push({...customer, segment: 'New Client'});
                }
                
                // High-frequency tier (weekly visitors - 4+ visits per month)
                if (customer.visits.length >= 4) {
                    // Calculate visit frequency
                    const sortedVisits = customer.visits.sort((a, b) => a - b);
                    const firstVisit = sortedVisits[0];
                    const lastVisit = sortedVisits[sortedVisits.length - 1];
                    const daysBetween = Math.floor((lastVisit - firstVisit) / (1000 * 60 * 60 * 24)) || 1;
                    const visitsPerWeek = (customer.visits.length / daysBetween) * 7;
                    
                    if (visitsPerWeek >= 1) {
                        segments.highFrequency.push({...customer, visitsPerWeek, segment: 'High-Frequency'});
                    }
                }
            });
            
            return segments;
        }
        
        function downloadSegmentCSV(segmentName, segmentData) {
            if (segmentData.length === 0) {
                alert('No clients in this segment to download.');
                return;
            }
            
            // Prepare CSV data
            const headers = ['First Name', 'Last Name', 'Email', 'Type', 'LTV', 'Total Visits', 'Last Visit Date', 'Membership', 'Membership Amount', 'Segment Info'];
            const rows = segmentData.map(client => {
                let segmentInfo = '';
                if (client.daysSinceLastVisit !== undefined) {
                    segmentInfo = `${client.daysSinceLastVisit} days since last visit`;
                } else if (client.visitsPerWeek !== undefined) {
                    segmentInfo = `${client.visitsPerWeek.toFixed(1)} visits/week`;
                } else {
                    segmentInfo = client.segment;
                }
                
                return [
                    client.firstName || '',
                    client.lastName || '',
                    client.email || '',
                    client.type || '',
                    client.ltv.toFixed(2),
                    client.totalVisits,
                    client.lastVisitDate ? client.lastVisitDate.toLocaleDateString() : 'N/A',
                    client.membershipName || 'None',
                    client.membershipAmount ? client.membershipAmount.toFixed(2) : '0.00',
                    segmentInfo
                ];
            });
            
            // Create CSV content
            let csvContent = headers.join(',') + '\\n';
            csvContent += rows.map(row => row.map(cell => `"${cell}"`).join(',')).join('\\n');
            
            // Create download link
            const blob = new Blob([csvContent], { type: 'text/csv;charset=utf-8;' });
            const link = document.createElement('a');
            const url = URL.createObjectURL(blob);
            
            link.setAttribute('href', url);
            link.setAttribute('download', `${segmentName.replace(/\\s+/g, '_')}_Segment_${new Date().toISOString().split('T')[0]}.csv`);
            link.style.visibility = 'hidden';
            
            document.body.appendChild(link);
            link.click();
            document.body.removeChild(link);
        }
        
        function showSegmentDetails(segmentName, segmentData) {
            if (segmentData.length === 0) {
                alert('No clients in this segment.');
                return;
            }
            
            // Sort by LTV descending
            const sortedData = [...segmentData].sort((a, b) => b.ltv - a.ltv);
            const totalLTV = sortedData.reduce((sum, c) => sum + c.ltv, 0);
            const avgLTV = totalLTV / sortedData.length;
            const totalVisits = sortedData.reduce((sum, c) => sum + c.totalVisits, 0);
            const totalMembershipRevenue = sortedData.reduce((sum, c) => sum + (c.membershipAmount || 0), 0);
            
            // Determine if this is the inactive paid member segment
            const isInactivePaidSegment = segmentName.includes('Inactive Paid');
            
            let tableRows = sortedData.slice(0, 100).map((client, i) => {
                let extraInfo = '';
                if (client.daysSinceLastVisit !== undefined) {
                    extraInfo = `${client.daysSinceLastVisit} days ago`;
                } else if (client.visitsPerWeek !== undefined) {
                    extraInfo = `${client.visitsPerWeek.toFixed(1)}/week`;
                } else {
                    extraInfo = client.lastVisitDate ? client.lastVisitDate.toLocaleDateString() : 'N/A';
                }
                
                const membershipInfo = client.membershipName ? `${client.membershipName}<br><small>${formatCurrency(client.membershipAmount)}/mo</small>` : 'None';
                
                return `
                    <tr>
                        <td>${i + 1}</td>
                        <td>${client.firstName} ${client.lastName}</td>
                        <td>${client.email}</td>
                        <td><strong>${formatCurrency(client.ltv)}</strong></td>
                        <td>${client.totalVisits}</td>
                        ${isInactivePaidSegment ? `<td>${membershipInfo}</td>` : ''}
                        <td>${extraInfo}</td>
                    </tr>
                `;
            }).join('');
            
            if (sortedData.length > 100) {
                tableRows += `<tr><td colspan="${isInactivePaidSegment ? 7 : 6}" style="text-align: center; color: #666; font-style: italic;">Showing first 100 of ${sortedData.length} clients. Download CSV for complete list.</td></tr>`;
            }
            
            const modalBody = `
                <div class="modal-section">
                    <h4>üìä ${segmentName} Segment Overview</h4>
                    <div class="modal-highlight">
                        <strong>Total Clients:</strong> ${formatNumber(sortedData.length)}<br>
                        <strong>Total LTV:</strong> ${formatCurrency(totalLTV)}<br>
                        <strong>Average LTV:</strong> ${formatCurrency(avgLTV)}<br>
                        <strong>Total Visits:</strong> ${formatNumber(totalVisits)}
                        ${isInactivePaidSegment ? `<br><strong>Monthly Membership Revenue:</strong> ${formatCurrency(totalMembershipRevenue)}` : ''}
                    </div>
                </div>
                
                <div class="modal-section">
                    <h4>üë• Client List</h4>
                    <button class="csv-export-btn" onclick="downloadSegmentCSV('${segmentName}', currentSegmentData)" style="margin-bottom: 15px;">
                        Download Complete List
                    </button>
                    <table class="modal-table">
                        <thead>
                            <tr>
                                <th>#</th>
                                <th>Name</th>
                                <th>Email</th>
                                <th>LTV</th>
                                <th>Visits</th>
                                ${isInactivePaidSegment ? '<th>Membership</th>' : ''}
                                <th>Additional Info</th>
                            </tr>
                        </thead>
                        <tbody>
                            ${tableRows}
                        </tbody>
                    </table>
                </div>
            `;
            
            // Store current segment data globally for download
            window.currentSegmentData = segmentData;
            
            document.getElementById('modalTitle').textContent = `${segmentName} Segment Details`;
            document.getElementById('modalBody').innerHTML = modalBody;
            document.getElementById('dataModal').classList.add('show');
        }
        
        function renderClientSegmentation() {
            const segments = calculateClientSegments();
            
            // Get current VIP threshold from LTV tier configuration
            const currentTierConfig = LTV_TIERS[CONFIG.ltvTiers];
            const vipMin = currentTierConfig.vipMin;
            
            // Calculate summary stats
            const totalSegmented = segments.vip.length + segments.atRisk.length + 
                                   segments.newClient.length + segments.highFrequency.length +
                                   segments.inactivePaidMember.length;
            const vipRevenue = segments.vip.reduce((sum, c) => sum + c.ltv, 0);
            const atRiskRevenue = segments.atRisk.reduce((sum, c) => sum + c.ltv, 0);
            const inactiveMemberRevenue = segments.inactivePaidMember.reduce((sum, c) => sum + c.membershipAmount, 0);
            const newClientPotential = segments.newClient.length * (filteredLeads.reduce((sum, l) => sum + parseLTV(l.LTV), 0) / filteredLeads.length);
            
            return `
                <div class="segmentation-container">
                    <div class="segmentation-header">
                        <h2>Advanced Client Segmentation</h2>
                        <p style="color: #666; font-size: 14px;">Strategic client groups for targeted engagement and retention</p>
                    </div>
                    
                    <div class="segmentation-grid">
                        <!-- VIP Tier -->
                        <div class="segment-card vip">
                            <div class="segment-icon">üëë</div>
                            <div class="segment-title">VIP Clients</div>
                            <div class="segment-description">High-value clients with >${formatCurrency(vipMin)} lifetime value</div>
                            <div class="segment-count">${formatNumber(segments.vip.length)}</div>
                            <div class="segment-stats">
                                <div class="segment-stats-row">
                                    <span>Total Revenue:</span>
                                    <strong>${formatCurrency(vipRevenue)}</strong>
                                </div>
                                <div class="segment-stats-row">
                                    <span>Avg LTV:</span>
                                    <strong>${segments.vip.length > 0 ? formatCurrency(vipRevenue / segments.vip.length) : '$0'}</strong>
                                </div>
                            </div>
                            <div class="segment-actions">
                                <button class="segment-btn view" onclick="showSegmentDetails('VIP Clients', currentSegments.vip)">
                                    üëÅÔ∏è View
                                </button>
                                <button class="segment-btn download" onclick="downloadSegmentCSV('VIP_Clients', currentSegments.vip)">
                                    üì• Export
                                </button>
                            </div>
                        </div>
                        
                        <!-- Inactive Paid Member Tier -->
                        <div class="segment-card inactive-paid">
                            <div class="segment-icon">üí≥</div>
                            <div class="segment-title">Inactive Paid Members</div>
                            <div class="segment-description">Active membership, no visit in 30+ days</div>
                            <div class="segment-count">${formatNumber(segments.inactivePaidMember.length)}</div>
                            <div class="segment-stats">
                                <div class="segment-stats-row">
                                    <span>Monthly Revenue:</span>
                                    <strong>${formatCurrency(inactiveMemberRevenue)}</strong>
                                </div>
                                <div class="segment-stats-row">
                                    <span>Avg Days Absent:</span>
                                    <strong>${segments.inactivePaidMember.length > 0 ? Math.round(segments.inactivePaidMember.reduce((sum, c) => sum + c.daysSinceLastVisit, 0) / segments.inactivePaidMember.length) : 0}</strong>
                                </div>
                            </div>
                            <div class="segment-actions">
                                <button class="segment-btn view" onclick="showSegmentDetails('Inactive Paid Members', currentSegments.inactivePaidMember)">
                                    üëÅÔ∏è View
                                </button>
                                <button class="segment-btn download" onclick="downloadSegmentCSV('Inactive_Paid_Members', currentSegments.inactivePaidMember)">
                                    üì• Export
                                </button>
                            </div>
                        </div>
                        
                        <!-- At-Risk Tier -->
                        <div class="segment-card at-risk">
                            <div class="segment-icon">‚ö†Ô∏è</div>
                            <div class="segment-title">At-Risk Clients</div>
                            <div class="segment-description">No visit in 45+ days, needs re-engagement</div>
                            <div class="segment-count">${formatNumber(segments.atRisk.length)}</div>
                            <div class="segment-stats">
                                <div class="segment-stats-row">
                                    <span>Revenue at Risk:</span>
                                    <strong>${formatCurrency(atRiskRevenue)}</strong>
                                </div>
                                <div class="segment-stats-row">
                                    <span>Avg Days Absent:</span>
                                    <strong>${segments.atRisk.length > 0 ? Math.round(segments.atRisk.reduce((sum, c) => sum + c.daysSinceLastVisit, 0) / segments.atRisk.length) : 0}</strong>
                                </div>
                            </div>
                            <div class="segment-actions">
                                <button class="segment-btn view" onclick="showSegmentDetails('At-Risk Clients', currentSegments.atRisk)">
                                    üëÅÔ∏è View
                                </button>
                                <button class="segment-btn download" onclick="downloadSegmentCSV('At_Risk_Clients', currentSegments.atRisk)">
                                    üì• Export
                                </button>
                            </div>
                        </div>
                        
                        <!-- New Client Tier -->
                        <div class="segment-card new-client">
                            <div class="segment-icon">üå±</div>
                            <div class="segment-title">New Clients</div>
                            <div class="segment-description">Less than 3 visits, high growth potential</div>
                            <div class="segment-count">${formatNumber(segments.newClient.length)}</div>
                            <div class="segment-stats">
                                <div class="segment-stats-row">
                                    <span>Current LTV:</span>
                                    <strong>${formatCurrency(segments.newClient.reduce((sum, c) => sum + c.ltv, 0))}</strong>
                                </div>
                                <div class="segment-stats-row">
                                    <span>Growth Potential:</span>
                                    <strong>${formatCurrency(newClientPotential)}</strong>
                                </div>
                            </div>
                            <div class="segment-actions">
                                <button class="segment-btn view" onclick="showSegmentDetails('New Clients', currentSegments.newClient)">
                                    üëÅÔ∏è View
                                </button>
                                <button class="segment-btn download" onclick="downloadSegmentCSV('New_Clients', currentSegments.newClient)">
                                    üì• Export
                                </button>
                            </div>
                        </div>
                        
                        <!-- High-Frequency Tier -->
                        <div class="segment-card high-frequency">
                            <div class="segment-icon">‚ö°</div>
                            <div class="segment-title">High-Frequency</div>
                            <div class="segment-description">Weekly visitors, highly engaged clients</div>
                            <div class="segment-count">${formatNumber(segments.highFrequency.length)}</div>
                            <div class="segment-stats">
                                <div class="segment-stats-row">
                                    <span>Total Revenue:</span>
                                    <strong>${formatCurrency(segments.highFrequency.reduce((sum, c) => sum + c.ltv, 0))}</strong>
                                </div>
                                <div class="segment-stats-row">
                                    <span>Total Visits:</span>
                                    <strong>${formatNumber(segments.highFrequency.reduce((sum, c) => sum + c.totalVisits, 0))}</strong>
                                </div>
                            </div>
                            <div class="segment-actions">
                                <button class="segment-btn view" onclick="showSegmentDetails('High-Frequency Clients', currentSegments.highFrequency)">
                                    üëÅÔ∏è View
                                </button>
                                <button class="segment-btn download" onclick="downloadSegmentCSV('High_Frequency_Clients', currentSegments.highFrequency)">
                                    üì• Export
                                </button>
                            </div>
                        </div>
                    </div>
                    
                    <div class="segment-summary">
                        <h3>üìä Segmentation Summary</h3>
                        <div class="summary-grid">
                            <div class="summary-item">
                                <div class="summary-label">Total Segmented</div>
                                <div class="summary-value">${formatNumber(totalSegmented)}</div>
                            </div>
                            <div class="summary-item">
                                <div class="summary-label">VIP Revenue</div>
                                <div class="summary-value">${formatCurrency(vipRevenue)}</div>
                            </div>
                            <div class="summary-item">
                                <div class="summary-label">Unused Memberships</div>
                                <div class="summary-value" style="color: #ff9800;">${formatCurrency(inactiveMemberRevenue)}/mo</div>
                            </div>
                            <div class="summary-item">
                                <div class="summary-label">At-Risk Revenue</div>
                                <div class="summary-value" style="color: #dc3545;">${formatCurrency(atRiskRevenue)}</div>
                            </div>
                            <div class="summary-item">
                                <div class="summary-label">Growth Potential</div>
                                <div class="summary-value" style="color: #28a745;">${formatCurrency(newClientPotential)}</div>
                            </div>
                        </div>
                    </div>
                </div>
            `;
        }
        
        // CUSTOMERS TAB
        function renderCustomersTab() {
            if (filteredLeads.length === 0) {
                document.getElementById('customers').innerHTML = `
                    <div class="alert info">
                        <h4>üìä Customer Analytics</h4>
                        <p>Upload the Leads & Customers CSV file to unlock customer lifetime value analysis, conversion tracking, and segmentation insights.</p>
                    </div>
                `;
                return;
            }
            
            // Store segments globally for access in button clicks
            window.currentSegments = calculateClientSegments();
            
            // Calculate LTV metrics
            const ltvs = filteredLeads.map(row => parseLTV(row.LTV));
            const totalLTV = ltvs.reduce((sum, ltv) => sum + ltv, 0);
            const avgLTV = totalLTV / ltvs.length;
            const maxLTV = Math.max(...ltvs);
            
            const customers = filteredLeads.filter(row => row.Type === 'Customer').length;
            const leads = filteredLeads.filter(row => row.Type === 'Lead').length;
            const conversionRate = ((customers / (customers + leads)) * 100).toFixed(1);
            
            // Get current LTV tier configuration
            const currentTierConfig = LTV_TIERS[CONFIG.ltvTiers];
            const ranges = currentTierConfig.ranges;
            const vipMin = currentTierConfig.vipMin;
            
            const zeroLTV = ltvs.filter(ltv => ltv === 0).length;
            const tier1 = ltvs.filter(ltv => ltv > 0 && ltv <= ranges[0]).length;
            const tier2 = ltvs.filter(ltv => ltv > ranges[0] && ltv <= ranges[1]).length;
            const tier3 = ltvs.filter(ltv => ltv > ranges[1] && ltv <= ranges[2]).length;
            const tier4 = ltvs.filter(ltv => ltv > ranges[2] && ltv <= ranges[3]).length;
            const tier5 = ltvs.filter(ltv => ltv > ranges[3] && ltv <= ranges[4]).length;
            const tier6 = ltvs.filter(ltv => ltv > ranges[4]).length;
            
            // üêõ DEBUG: Log detailed LTV information















            // Find Chris Dahl specifically
            const chrisDahl = filteredLeads.find(lead => 
                lead['E-mail'] && lead['E-mail'].toLowerCase().includes('cdahl@aquali.com')
            );

            if (chrisDahl) {
                const chrisLTV = parseLTV(chrisDahl.LTV);








            } else {

            }
            
            // Show top 10 LTV values

            const top10 = [...filteredLeads]
                .map(lead => ({
                    name: `${lead['First name']} ${lead['Last name']}`,
                    email: lead['E-mail'],
                    rawLTV: lead.LTV,
                    parsedLTV: parseLTV(lead.LTV)
                }))
                .sort((a, b) => b.parsedLTV - a.parsedLTV)
                .slice(0, 10);
            top10.forEach((lead, i) => {

            });
            
            // Show tier 6 members (VIP)
            const tier6Members = filteredLeads.filter(lead => parseLTV(lead.LTV) > ranges[4]);

            tier6Members.slice(0, 20).forEach(lead => {

            });

            // Top customers
            const sortedByLTV = [...filteredLeads]
                .sort((a, b) => parseLTV(b.LTV) - parseLTV(a.LTV))
                .slice(0, 10);
            
            let html = `
                <div class="alert ${zeroLTV > filteredLeads.length * 0.3 ? 'warning' : 'info'}">
                    <h3>üí∞ Revenue Opportunity</h3>
                    <p><strong>${formatNumber(zeroLTV)}</strong> customers have $0 lifetime value (${((zeroLTV/filteredLeads.length)*100).toFixed(1)}% of total).</p>
                    <p style="margin-top: 10px;"><strong>Potential Revenue:</strong> ${formatCurrency(zeroLTV * avgLTV)} if converted at average LTV</p>
                </div>
                
                ${renderClientSegmentation()}
                
                <div class="metrics-grid" style="grid-template-columns: repeat(4, 1fr);">
                    <div class="metric-card">
                        <div class="metric-label">Total LTV</div>
                        <div class="metric-value">${formatCurrency(totalLTV)}</div>
                        <div class="metric-subtext">All customers</div>
                    </div>
                    <div class="metric-card">
                        <div class="metric-label">Average LTV</div>
                        <div class="metric-value">${formatCurrency(avgLTV)}</div>
                        <div class="metric-subtext">Per customer</div>
                    </div>
                    <div class="metric-card">
                        <div class="metric-label">Conversion Rate</div>
                        <div class="metric-value">${conversionRate}%</div>
                        <div class="metric-subtext">${customers} customers | ${leads} leads</div>
                    </div>
                    <div class="metric-card">
                        <div class="metric-label">VIP Customers</div>
                        <div class="metric-value">${formatNumber(tier6)}</div>
                        <div class="metric-subtext">>${formatCurrency(vipMin)} LTV</div>
                    </div>
                </div>
                
                <div style="background: #f8f9fa; padding: 20px; border-radius: 10px; margin-bottom: 30px; border-left: 4px solid #dc3545;">
                    <div style="display: flex; justify-content: space-between; align-items: center;">
                        <div>
                            <h3 style="margin: 0 0 5px 0; color: #dc3545;">‚ö†Ô∏è ${formatNumber(zeroLTV)} Customers at $0 LTV</h3>
                            <p style="margin: 0; color: #666;">These customers represent untapped revenue potential</p>
                        </div>
                        <div style="text-align: right;">
                            <div style="font-size: 12px; color: #666;">Percentage of Total</div>
                            <div style="font-size: 32px; font-weight: bold; color: #dc3545;">${((zeroLTV/filteredLeads.length)*100).toFixed(1)}%</div>
                        </div>
                    </div>
                </div>
                
                <div class="charts-grid">
                    <div class="chart-container">
                        <div class="interactive-badge" title="Click on any bar to see customer list"></div>
                        <h3>LTV Distribution (Customers with Revenue)</h3>
                        <div class="chart-wrapper">
                            <canvas id="ltvDistributionChart"></canvas>
                        </div>
                    </div>
                    
                    <div class="chart-container">
                        <h3>Customer Types</h3>
                        <div class="chart-wrapper">
                            <canvas id="customerTypesChart"></canvas>
                        </div>
                    </div>
                </div>
                
                <!-- Retention Analysis Section -->
                ${(() => {
                    // Analyze client visits for retention metrics
                    const data = filteredAppointments;
                    const activeMemberEmails = getActiveMemberEmails();
                    const clientVisits = {};
                    const clientFirstVisit = {};
                    const clientLastVisit = {};
                    const clientRevenue = {};
                    
                    data.forEach(row => {
                        const email = (row['Customer Email'] || '').toLowerCase().trim();
                        if (!email) return;
                        
                        const date = parseDate(row['Appointment Date']);
                        const revenue = parseFloat(row.Revenue || 0);
                        const revenueToAdd = activeMemberEmails.has(email) ? 0 : revenue;
                        
                        if (!clientVisits[email]) {
                            clientVisits[email] = 0;
                            clientFirstVisit[email] = date;
                            clientLastVisit[email] = date;
                            clientRevenue[email] = 0;
                        }
                        
                        clientVisits[email]++;
                        clientRevenue[email] += revenueToAdd;
                        
                        if (date < clientFirstVisit[email]) clientFirstVisit[email] = date;
                        if (date > clientLastVisit[email]) clientLastVisit[email] = date;
                    });
                    
                    const uniqueClients = Object.keys(clientVisits).length;
                    const returningClients = Object.values(clientVisits).filter(count => count > 1).length;
                    const retentionRate = uniqueClients > 0 ? (returningClients / uniqueClients * 100) : 0;
                    const avgVisitsPerClient = uniqueClients > 0 ? data.length / uniqueClients : 0;
                    
                    const visitDist = { '1 visit': 0, '2-3 visits': 0, '4-6 visits': 0, '7-10 visits': 0, '11+ visits': 0 };
                    Object.values(clientVisits).forEach(count => {
                        if (count === 1) visitDist['1 visit']++;
                        else if (count <= 3) visitDist['2-3 visits']++;
                        else if (count <= 6) visitDist['4-6 visits']++;
                        else if (count <= 10) visitDist['7-10 visits']++;
                        else visitDist['11+ visits']++;
                    });
                    
                    let totalDaysBetween = 0;
                    let visitPairs = 0;
                    Object.keys(clientVisits).forEach(email => {
                        if (clientVisits[email] > 1) {
                            const daysBetween = (clientLastVisit[email] - clientFirstVisit[email]) / (1000 * 60 * 60 * 24);
                            const avgDaysForClient = daysBetween / (clientVisits[email] - 1);
                            totalDaysBetween += avgDaysForClient;
                            visitPairs++;
                        }
                    });
                    const avgDaysBetweenVisits = visitPairs > 0 ? totalDaysBetween / visitPairs : 0;
                    
                    return `
                        <div style="margin: 30px 0;">
                            <h2 style="margin-bottom: 20px;">üîÑ Retention Analysis</h2>
                            <div class="metrics-grid" style="grid-template-columns: repeat(4, 1fr); margin-bottom: 20px;">
                                <div class="metric-card">
                                    <div class="metric-label">Total Clients</div>
                                    <div class="metric-value">${formatNumber(uniqueClients)}</div>
                                    <div class="metric-subtext">Unique individuals</div>
                                </div>
                                <div class="metric-card ${retentionRate >= 50 ? 'success' : retentionRate >= 30 ? 'warning' : 'danger'}">
                                    <div class="metric-label">Retention Rate</div>
                                    <div class="metric-value">${retentionRate.toFixed(1)}%</div>
                                    <div class="metric-subtext">${formatNumber(returningClients)} returning clients</div>
                                </div>
                                <div class="metric-card">
                                    <div class="metric-label">Avg Visits</div>
                                    <div class="metric-value">${avgVisitsPerClient.toFixed(1)}</div>
                                    <div class="metric-subtext">Per client</div>
                                </div>
                                <div class="metric-card">
                                    <div class="metric-label">Avg Days Between</div>
                                    <div class="metric-value">${avgDaysBetweenVisits.toFixed(0)}</div>
                                    <div class="metric-subtext">Days between visits</div>
                                </div>
                            </div>
                            
                            <div class="alert ${retentionRate >= 50 ? 'success' : 'warning'}">
                                <h4>üîÑ Retention Status</h4>
                                <p><strong>Current Status:</strong> ${retentionRate.toFixed(0)}% of clients return for additional appointments.</p>
                                <ul style="margin: 10px 0 0 20px; line-height: 1.8;">
                                    <li>${visitDist['1 visit']} clients (${((visitDist['1 visit']/uniqueClients)*100).toFixed(0)}%) visited only once</li>
                                    <li>Average ${avgDaysBetweenVisits.toFixed(0)} days between visits for returning clients</li>
                                    <li>${returningClients} loyal clients generating repeat business</li>
                                </ul>
                                <p style="margin-top: 15px;"><strong>üí° Recommendations:</strong></p>
                                <ul style="margin: 5px 0 0 20px; line-height: 1.8;">
                                    <li>Follow up with one-time visitors within ${Math.ceil(avgDaysBetweenVisits/2)} days</li>
                                    <li>Create membership packages for ${visitDist['4-6 visits'] + visitDist['7-10 visits'] + visitDist['11+ visits']} frequent visitors</li>
                                    <li>Send rebooking reminders every ${Math.floor(avgDaysBetweenVisits * 0.8)} days</li>
                                </ul>
                            </div>
                            
                            <div style="margin: 20px 0;">
                                <h3>Visit Frequency Distribution</h3>
                                <div style="display: grid; grid-template-columns: repeat(auto-fit, minmax(150px, 1fr)); gap: 15px;">
                                    ${Object.entries(visitDist).map(([range, count]) => `
                                        <div style="background: var(--gray-light); padding: 20px; border-radius: 8px; text-align: center; border-left: 4px solid var(--accent);">
                                            <div style="font-size: 2.5em; font-weight: bold; color: var(--primary);">${formatNumber(count)}</div>
                                            <div style="color: #666; font-size: 14px; margin-top: 5px;">${range}</div>
                                            <div style="color: var(--accent); font-size: 12px; margin-top: 3px;">${((count/uniqueClients)*100).toFixed(1)}%</div>
                                        </div>
                                    `).join('')}
                                </div>
                            </div>
                        </div>
                    `;
                })()}
                
                <div class="table-container">
                    <h2>Top 10 Customers by Lifetime Value</h2>
                    <table>
                        <thead>
                            <tr>
                                <th>Rank</th>
                                <th>Name</th>
                                <th>Email</th>
                                <th>Type</th>
                                <th>First Purchase</th>
                                <th>LTV</th>
                            </tr>
                        </thead>
                        <tbody>
                            ${sortedByLTV.map((c, i) => `
                                <tr>
                                    <td><strong>${i === 0 ? 'ü•á' : i === 1 ? 'ü•à' : i === 2 ? 'ü•â' : i + 1}</strong></td>
                                    <td>${c['First name']} ${c['Last name']}</td>
                                    <td>${c['E-mail']}</td>
                                    <td>${c.Type}</td>
                                    <td>${c['First purchase'] || 'N/A'}</td>
                                    <td><strong>${formatCurrency(parseLTV(c.LTV))}</strong></td>
                                </tr>
                            `).join('')}
                        </tbody>
                    </table>
                </div>
            `;
            
            document.getElementById('customers').innerHTML = html;
            
            // Render charts
            setTimeout(() => {
                renderLTVDistributionChart(tier1, tier2, tier3, tier4, tier5, tier6);
                renderCustomerTypesChart(customers, leads);
            }, 100);
        }
        
        // PRACTITIONERS TAB
        function renderPractitionersTab() {
            const data = filteredAppointments;
            const activeMemberEmails = getActiveMemberEmails();
            
            // Calculate comprehensive metrics for each practitioner (from leaderboard)
            const practitionerStats = {};
            
            data.forEach(row => {
                const name = `${row['Practitioner First Name']} ${row['Practitioner Last Name']}`.trim();
                if (!name) return;
                
                if (!practitionerStats[name]) {
                    practitionerStats[name] = {
                        revenue: 0,
                        appointments: 0,
                        clients: new Set(),
                        hours: 0,
                        payout: 0,
                        lateCancel: 0,
                        services: new Set()
                    };
                }
                
                const email = (row['Customer Email'] || '').toLowerCase().trim();
                const revenue = parseFloat(row.Revenue || 0);
                
                practitionerStats[name].revenue += revenue;
                practitionerStats[name].appointments++;
                practitionerStats[name].clients.add(email);
                practitionerStats[name].hours += parseFloat(row['Time (h)'] || 0);
                practitionerStats[name].payout += parseFloat(row['Total Payout'] || 0);
                if (row['Late cancellations'] && row['Late cancellations'].toLowerCase() === 'yes') {
                    practitionerStats[name].lateCancel++;
                }
                practitionerStats[name].services.add(row.Appointment);
            });
            
            // Calculate scores and rankings
            const practitioners = Object.entries(practitionerStats).map(([name, stats]) => {
                const clientCount = stats.clients.size;
                const revenuePerHour = stats.hours > 0 ? stats.revenue / stats.hours : 0;
                const revenuePerAppt = stats.appointments > 0 ? stats.revenue / stats.appointments : 0;
                const lateCancelRate = stats.appointments > 0 ? (stats.lateCancel / stats.appointments) * 100 : 0;
                const profit = stats.revenue - stats.payout;
                const profitMargin = stats.revenue > 0 ? (profit / stats.revenue) * 100 : 0;
                
                // Get utilization data if available from zip file
                const employeeName = name.toLowerCase().replace(/\s+/g, ' ');
                let utilization = null;
                let clockedHours = 0;
                let shiftCount = 0;
                
                if (window.employeeUtilization) {
                    for (const [empName, empData] of Object.entries(window.employeeUtilization)) {
                        if (empName.toLowerCase().replace(/\s+/g, ' ') === employeeName) {
                            utilization = empData.utilization;
                            clockedHours = empData.totalClockedHours;
                            shiftCount = empData.shiftCount;
                            break;
                        }
                    }
                }
                
                // Get commission data if available (Membership & Product only)
                let commissions = 0;
                let commissionCount = 0;
                if (window.filteredCommissions && window.filteredCommissions.length > 0) {
                    const employeeCommissions = window.filteredCommissions.filter(c => {
                        const commEmpName = (c['Employee Name'] || '').toLowerCase().replace(/\s+/g, ' ');
                        return commEmpName === employeeName;
                    });
                    
                    commissions = employeeCommissions.reduce((sum, c) => {
                        return sum + (parseFloat(c['Commissions earned']) || 0);
                    }, 0);
                    commissionCount = employeeCommissions.length;
                }
                
                // Calculate overall score (weighted)
                const revenueScore = stats.revenue / 100; // $100 = 1 point
                const efficiencyScore = revenuePerHour * 2; // $1/hr = 2 points
                const clientScore = clientCount * 5; // 1 client = 5 points
                const consistencyScore = stats.appointments * 2; // 1 appt = 2 points
                const qualityScore = (100 - lateCancelRate) * 0.5; // Low cancellations = high score
                const utilizationScore = utilization !== null ? utilization * 0.5 : 0; // 1% utilization = 0.5 points
                const commissionScore = commissions / 10; // $10 commission = 1 point
                
                const totalScore = revenueScore + efficiencyScore + clientScore + consistencyScore + qualityScore + utilizationScore + commissionScore;
                
                return {
                    name,
                    revenue: stats.revenue,
                    appointments: stats.appointments,
                    clients: clientCount,
                    hours: stats.hours,
                    revenuePerHour,
                    revenuePerAppt,
                    lateCancelRate,
                    profit,
                    profitMargin,
                    services: stats.services.size,
                    score: totalScore,
                    payout: stats.payout,
                    utilization,
                    clockedHours,
                    shiftCount,
                    commissions,
                    commissionCount
                };
            });
            
            // Filter out Sauna
            const filteredPractitioners = practitioners.filter(p => !p.name.toLowerCase().includes('sauna'));
            
            // Sort by score for leaderboard
            filteredPractitioners.sort((a, b) => b.score - a.score);
            
            // Create simplified practitionerData for existing charts
            const practitionerData = {};
            filteredPractitioners.forEach(p => {
                practitionerData[p.name] = {
                    appointments: p.appointments,
                    revenue: p.revenue,
                    payout: p.payout,
                    hours: p.hours
                };
            });
            
            let html = `
                <div class="alert info">
                    <h3>‚öïÔ∏è VSP Performance & Leaderboard</h3>
                    <p>Comprehensive performance metrics and rankings based on revenue, efficiency, client satisfaction, and consistency.</p>
                </div>
            `;
            
            // Add Performance Analytics tables at the top (before metrics grid and leaderboard)
            html += renderVSPConversionAndUtilization(data, filteredPractitioners);
            
            // Continue with metrics grid
            html += `
                <div class="metrics-grid" style="margin-top: 40px; grid-template-columns: repeat(${filteredPractitioners.some(p => p.utilization !== null) ? (filteredPractitioners.some(p => p.commissions > 0) ? '6' : '5') : (filteredPractitioners.some(p => p.commissions > 0) ? '5' : '4')}, 1fr);">
                    <div class="metric-card">
                        <div class="metric-label">Top Performer</div>
                        <div class="metric-value" style="font-size: 1.5em;">${filteredPractitioners[0]?.name || 'N/A'}</div>
                        <div class="metric-subtext">${filteredPractitioners[0] ? formatNumber(filteredPractitioners[0].score) + ' points' : ''}</div>
                    </div>
                    <div class="metric-card">
                        <div class="metric-label">Highest Revenue</div>
                        <div class="metric-value">${formatCurrency(Math.max(...filteredPractitioners.map(p => p.revenue)))}</div>
                        <div class="metric-subtext">${filteredPractitioners.sort((a,b) => b.revenue - a.revenue)[0]?.name || 'N/A'}</div>
                    </div>
                    <div class="metric-card">
                        <div class="metric-label">Best Efficiency</div>
                        <div class="metric-value">${formatCurrency(Math.max(...filteredPractitioners.map(p => p.revenuePerHour)))}/hr</div>
                        <div class="metric-subtext">${filteredPractitioners.sort((a,b) => b.revenuePerHour - a.revenuePerHour)[0]?.name || 'N/A'}</div>
                    </div>
                    <div class="metric-card">
                        <div class="metric-label">Most Clients</div>
                        <div class="metric-value">${Math.max(...filteredPractitioners.map(p => p.clients))}</div>
                        <div class="metric-subtext">${filteredPractitioners.sort((a,b) => b.clients - a.clients)[0]?.name || 'N/A'}</div>
                    </div>
                    ${filteredPractitioners.some(p => p.utilization !== null) ? `
                    <div class="metric-card success">
                        <div class="metric-label">Avg Utilization</div>
                        <div class="metric-value">${(filteredPractitioners.filter(p => p.utilization !== null).reduce((sum, p) => sum + p.utilization, 0) / filteredPractitioners.filter(p => p.utilization !== null).length).toFixed(1)}%</div>
                        <div class="metric-subtext">Table time efficiency</div>
                    </div>
                    ` : ''}
                    ${filteredPractitioners.some(p => p.commissions > 0) ? `
                    <div class="metric-card" style="background: linear-gradient(135deg, rgba(40, 167, 69, 0.1), rgba(32, 201, 151, 0.05)); border-left: 4px solid #28a745;">
                        <div class="metric-label">Total Commissions</div>
                        <div class="metric-value">${formatCurrency(filteredPractitioners.reduce((sum, p) => sum + p.commissions, 0))}</div>
                        <div class="metric-subtext">Memberships & Products</div>
                    </div>
                    ` : ''}
                </div>
                
                <div class="charts-grid">
                    <div class="chart-container">
                        <div class="interactive-badge" title="Click on any VSP to see full details"></div>
                        <h3>Revenue by VSP</h3>
                        <div class="chart-wrapper">
                            <canvas id="practitionerRevenueChart"></canvas>
                        </div>
                    </div>
                    
                    <div class="chart-container">
                        <div class="interactive-badge" title="Click on any VSP to see full details"></div>
                        <h3>Appointments by VSP</h3>
                        <div class="chart-wrapper">
                            <canvas id="practitionerApptsChart"></canvas>
                        </div>
                    </div>
                </div>
            `;
            
            // Re-sort by score for leaderboard display
            filteredPractitioners.sort((a, b) => b.score - a.score);
            
            // Add leaderboard cards
            filteredPractitioners.forEach((p, index) => {
                const rank = index + 1;
                const rankClass = rank === 1 ? 'gold' : rank === 2 ? 'silver' : rank === 3 ? 'bronze' : 'other';
                const medal = rank === 1 ? 'ü•á' : rank === 2 ? 'ü•à' : rank === 3 ? 'ü•â' : rank;
                
                html += `
                    <div class="leaderboard-card">
                        <div class="leaderboard-content">
                            <div style="display: flex; align-items: center;">
                                <div class="leaderboard-rank ${rankClass}">${medal}</div>
                                <div class="leaderboard-info">
                                    <div class="leaderboard-name">${p.name}</div>
                                    <div class="leaderboard-stats">
                                        <div class="leaderboard-stat">
                                            <strong>${formatCurrency(p.revenue)}</strong> Revenue
                                        </div>
                                        <div class="leaderboard-stat">
                                            <strong>${formatNumber(p.appointments)}</strong> Appointments
                                        </div>
                                        <div class="leaderboard-stat">
                                            <strong>${formatNumber(p.clients)}</strong> Clients
                                        </div>
                                        <div class="leaderboard-stat">
                                            <strong>${formatCurrency(p.revenuePerHour)}/hr</strong> Efficiency
                                        </div>
                                        ${p.clockedHours > 0 ? `
                                        <div class="leaderboard-stat">
                                            <strong>${formatNumber(p.clockedHours)} hrs</strong> Hours Worked
                                        </div>
                                        ` : ''}
                                        ${p.utilization !== null ? `
                                        <div class="leaderboard-stat">
                                            <strong>${p.utilization.toFixed(1)}%</strong> Utilization
                                        </div>
                                        ` : ''}
                                        ${p.commissions > 0 ? `
                                        <div class="leaderboard-stat">
                                            <strong>${formatCurrency(p.commissions)}</strong> Commissions
                                        </div>
                                        ` : ''}
                                        <div class="leaderboard-stat">
                                            <strong>${p.profitMargin.toFixed(0)}%</strong> Margin
                                        </div>
                                        <div class="leaderboard-stat">
                                            <strong>${p.lateCancelRate.toFixed(1)}%</strong> Late Cancel
                                        </div>
                                    </div>
                                </div>
                            </div>
                            <div class="leaderboard-score">
                                <div class="leaderboard-score-label">Score</div>
                                <div class="leaderboard-score-value">${formatNumber(p.score)}</div>
                            </div>
                        </div>
                    </div>
                `;
            });
            
            html += `
                <div class="table-container">
                    <h2>Detailed Performance Metrics</h2>
                    <table>
                        <thead>
                            <tr>
                                <th>Rank</th>
                                <th>VSP</th>
                                <th>Score</th>
                                <th>Revenue</th>
                                <th>Appts</th>
                                <th>$/Hour</th>
                                <th>$/Appt</th>
                                <th>Clients</th>
                                ${filteredPractitioners.some(p => p.utilization !== null) ? '<th>Utilization</th>' : ''}
                                ${filteredPractitioners.some(p => p.commissions > 0) ? '<th>Commissions</th>' : ''}
                                <th>Profit %</th>
                            </tr>
                        </thead>
                        <tbody>
                            ${filteredPractitioners.map((p, i) => `
                                <tr>
                                    <td><strong>${i + 1}</strong></td>
                                    <td>${p.name}</td>
                                    <td><strong>${formatNumber(p.score)}</strong></td>
                                    <td>${formatCurrency(p.revenue)}</td>
                                    <td>${formatNumber(p.appointments)}</td>
                                    <td>${formatCurrency(p.revenuePerHour)}</td>
                                    <td>${formatCurrency(p.revenuePerAppt)}</td>
                                    <td>${formatNumber(p.clients)}</td>
                                    ${p.utilization !== null ? `<td>${p.utilization.toFixed(1)}%</td>` : (filteredPractitioners.some(pr => pr.utilization !== null) ? '<td>-</td>' : '')}
                                    ${p.commissions > 0 ? `<td>${formatCurrency(p.commissions)}</td>` : (filteredPractitioners.some(pr => pr.commissions > 0) ? '<td>-</td>' : '')}
                                    <td>${p.profitMargin.toFixed(1)}%</td>
                                </tr>
                            `).join('')}
                        </tbody>
                    </table>
                </div>
                
                <div class="alert success">
                    <h4>üéØ Performance Insights</h4>
                    <ul style="margin: 10px 0 0 20px; line-height: 1.8;">
                        <li><strong>Top Performer:</strong> ${filteredPractitioners[0]?.name} leads with ${formatNumber(filteredPractitioners[0]?.score)} points, excelling in overall performance.</li>
                        <li><strong>Revenue Leader:</strong> ${filteredPractitioners.sort((a,b) => b.revenue - a.revenue)[0]?.name} generated ${formatCurrency(filteredPractitioners.sort((a,b) => b.revenue - a.revenue)[0]?.revenue)} in revenue.</li>
                        <li><strong>Efficiency Champion:</strong> ${filteredPractitioners.sort((a,b) => b.revenuePerHour - a.revenuePerHour)[0]?.name} achieves ${formatCurrency(filteredPractitioners.sort((a,b) => b.revenuePerHour - a.revenuePerHour)[0]?.revenuePerHour)}/hour.</li>
                        <li><strong>Client Favorite:</strong> ${filteredPractitioners.sort((a,b) => b.clients - a.clients)[0]?.name} serves ${filteredPractitioners.sort((a,b) => b.clients - a.clients)[0]?.clients} unique clients.</li>
                    </ul>
                </div>
            `;
            
            document.getElementById('practitioners').innerHTML = html;
            
            // Render charts
            setTimeout(() => {
                renderPractitionerCharts(practitionerData);
            }, 100);
        }
        
        // Helper function to render VSP Conversion and Utilization tables
        function renderVSPConversionAndUtilization(appointmentsData, practitionersList) {
            let html = '';
            
            // Calculate Utilization Rates by VSP and Month (using existing time tracking data)
            const utilizationByVSPMonth = {};
            
            // Track how many appointments we filter
            let futureApptsFiltered = 0;
            let totalApptsProcessed = 0;
            
            // Process appointments to get appointment hours by VSP and month
            appointmentsData.forEach(appt => {
                try {
                    totalApptsProcessed++;
                    const apptDate = parseDate(appt['Appointment Date']);
                    
                    // Skip future appointments
                    if (shouldFilterFutureDate(appt['Appointment Date'])) {
                        futureApptsFiltered++;
                        return;
                    }
                    
                    const monthKey = `${apptDate.getFullYear()}-${String(apptDate.getMonth() + 1).padStart(2, '0')}`;
                    const vspName = `${appt['Practitioner First Name']} ${appt['Practitioner Last Name']}`.trim();
                    
                    if (!vspName || vspName.toLowerCase().includes('sauna')) return;
                    
                    if (!utilizationByVSPMonth[vspName]) {
                        utilizationByVSPMonth[vspName] = {};
                    }
                    if (!utilizationByVSPMonth[vspName][monthKey]) {
                        utilizationByVSPMonth[vspName][monthKey] = {
                            appointmentHours: 0,
                            clockedHours: 0
                        };
                    }
                    
                    utilizationByVSPMonth[vspName][monthKey].appointmentHours += parseFloat(appt['Time (h)'] || 0);
                } catch (e) {
                    console.error('Error processing appointment for utilization:', e);
                }
            });
            
            // Log filtering results
            console.log(`üîÆ VSP Analytics: Filtered ${futureApptsFiltered} future appointments out of ${totalApptsProcessed} total`);
            
            // Add clocked hours from time tracking data (use actual hours worked)
            if (window.timeTrackingData && window.timeTrackingData.length > 0) {
                // First, group shifts by VSP and date
                const dailyHoursByVSP = {};
                
                window.timeTrackingData.forEach(shift => {
                    try {
                        const clockedIn = shift['Clocked in'] ? new Date(shift['Clocked in']) : null;
                        if (!clockedIn) return;
                        
                        // Skip future time tracking
                        if (shouldFilterFutureDate(shift['Clocked in'])) {
                            return;
                        }
                        
                        const dateKey = clockedIn.toISOString().split('T')[0]; // YYYY-MM-DD
                        const monthKey = `${clockedIn.getFullYear()}-${String(clockedIn.getMonth() + 1).padStart(2, '0')}`;
                        const employeeName = shift['Employee name'] || shift['Employee Name'] || '';
                        const duration = parseFloat(shift['Duration (h)'] || 0);
                        
                        // Find matching VSP
                        Object.keys(utilizationByVSPMonth).forEach(vspName => {
                            const vspLower = vspName.toLowerCase().replace(/\s+/g, ' ').trim();
                            const empLower = employeeName.toLowerCase().replace(/\s+/g, ' ').trim();
                            
                            if (vspLower === empLower) {
                                if (!dailyHoursByVSP[vspName]) {
                                    dailyHoursByVSP[vspName] = {};
                                }
                                if (!dailyHoursByVSP[vspName][dateKey]) {
                                    dailyHoursByVSP[vspName][dateKey] = {
                                        totalHours: 0,
                                        monthKey: monthKey
                                    };
                                }
                                dailyHoursByVSP[vspName][dateKey].totalHours += duration;
                            }
                        });
                    } catch (e) {
                        console.error('Error processing time tracking for utilization:', e);
                    }
                });
                
                // Now add to utilizationByVSPMonth using actual hours (no cap)
                Object.keys(dailyHoursByVSP).forEach(vspName => {
                    Object.keys(dailyHoursByVSP[vspName]).forEach(dateKey => {
                        const dayData = dailyHoursByVSP[vspName][dateKey];
                        const monthKey = dayData.monthKey;
                        
                        // Use actual hours (no cap)
                        const actualHours = dayData.totalHours;
                        
                        if (!utilizationByVSPMonth[vspName][monthKey]) {
                            utilizationByVSPMonth[vspName][monthKey] = {
                                appointmentHours: 0,
                                clockedHours: 0
                            };
                        }
                        utilizationByVSPMonth[vspName][monthKey].clockedHours += actualHours;
                    });
                });
            }
            
            // Alternative: Use attendance data ONLY if time tracking didn't provide clocked hours
            if (window.attendanceData && window.attendanceData.length > 0) {
                // Group attendance data by VSP, date, and month
                const attendanceByVSP = {};
                window.attendanceData.forEach(record => {
                    try {
                        const staffName = (record['Staff Name'] || '').trim();
                        const dateStr = record['Date of reservation'];
                        if (!staffName || !dateStr) return;
                        
                        const date = new Date(dateStr);
                        if (isNaN(date.getTime())) return;
                        
                        const dateKey = date.toISOString().split('T')[0]; // YYYY-MM-DD
                        const monthKey = `${date.getFullYear()}-${String(date.getMonth() + 1).padStart(2, '0')}`;
                        
                        if (!attendanceByVSP[staffName]) {
                            attendanceByVSP[staffName] = {};
                        }
                        if (!attendanceByVSP[staffName][dateKey]) {
                            attendanceByVSP[staffName][dateKey] = {
                                totalTime: 0,
                                monthKey: monthKey
                            };
                        }
                        attendanceByVSP[staffName][dateKey].totalTime += parseFloat(record['Total time (h)'] || 0);
                    } catch (e) {
                        console.error('Error processing attendance record:', e);
                    }
                });
                
                // Update utilization data with attendance info ONLY if clockedHours is still 0
                Object.entries(attendanceByVSP).forEach(([staffName, dates]) => {
                    // Find matching VSP in utilizationByVSPMonth
                    Object.keys(utilizationByVSPMonth).forEach(vspName => {
                        const vspLower = vspName.toLowerCase().replace(/\s+/g, ' ').trim();
                        const staffLower = staffName.toLowerCase().replace(/\s+/g, ' ').trim();
                        
                        if (vspLower === staffLower) {
                            // Aggregate by month using actual hours (no cap)
                            Object.entries(dates).forEach(([dateKey, data]) => {
                                const monthKey = data.monthKey;
                                const actualHours = data.totalTime;
                                
                                // ONLY add attendance hours if this month has NO clocked hours from time tracking
                                if (utilizationByVSPMonth[vspName][monthKey] && utilizationByVSPMonth[vspName][monthKey].clockedHours === 0) {
                                    utilizationByVSPMonth[vspName][monthKey].clockedHours += actualHours;
                                }
                            });
                        }
                    });
                });
                
                }
            
            // Calculate Conversion Rates by VSP and Month
            const conversionByVSPMonth = {};
            
            // Build a map of customer email -> first appointment date and VSP
            const customerFirstAppt = {};
            appointmentsData.forEach(appt => {
                const email = (appt['Customer Email'] || '').toLowerCase().trim();
                if (!email) return;
                
                // Skip future appointments
                if (shouldFilterFutureDate(appt['Appointment Date'])) {
                    return;
                }
                
                const apptDate = parseDate(appt['Appointment Date']);
                const vspName = `${appt['Practitioner First Name']} ${appt['Practitioner Last Name']}`.trim();
                
                if (!customerFirstAppt[email] || apptDate < customerFirstAppt[email].date) {
                    customerFirstAppt[email] = {
                        date: apptDate,
                        vsp: vspName,
                        serviceName: appt['Appointment'] || ''
                    };
                }
            });
            
            // Now check memberships data to see who converted
            if (window.membershipsData && window.membershipsData.length > 0) {
                // Create a set of member emails
                const memberEmails = new Set(
                    window.membershipsData
                        .map(m => (m['Customer Email'] || '').toLowerCase().trim())
                        .filter(e => e)
                );
                
                // For each customer's first appointment, track if they became a member
                Object.entries(customerFirstAppt).forEach(([email, firstAppt]) => {
                    const monthKey = `${firstAppt.date.getFullYear()}-${String(firstAppt.date.getMonth() + 1).padStart(2, '0')}`;
                    const vspName = firstAppt.vsp;
                    
                    if (!vspName || vspName.toLowerCase().includes('sauna')) return;
                    
                    if (!conversionByVSPMonth[vspName]) {
                        conversionByVSPMonth[vspName] = {};
                    }
                    if (!conversionByVSPMonth[vspName][monthKey]) {
                        conversionByVSPMonth[vspName][monthKey] = {
                            introStretches: 0,
                            conversions: 0
                        };
                    }
                    
                    // Count as intro stretch (first appointment)
                    conversionByVSPMonth[vspName][monthKey].introStretches++;
                    
                    // Check if they became a member
                    if (memberEmails.has(email)) {
                        conversionByVSPMonth[vspName][monthKey].conversions++;
                    }
                });
            }
            
            // Get all unique months across all data
            const allMonths = new Set();
            Object.values(conversionByVSPMonth).forEach(vspData => {
                Object.keys(vspData).forEach(month => allMonths.add(month));
            });
            Object.values(utilizationByVSPMonth).forEach(vspData => {
                Object.keys(vspData).forEach(month => allMonths.add(month));
            });
            
            const sortedMonths = Array.from(allMonths).sort();
            
            // Determine quarters to show: last 2 full quarters + any months in current quarter
            const today = new Date();
            const currentYear = today.getFullYear();
            const currentMonth = today.getMonth() + 1; // 1-12
            const currentMonthKey = `${currentYear}-${String(currentMonth).padStart(2, '0')}`;
            
            // Determine current quarter (1-4)
            const currentQuarter = Math.ceil(currentMonth / 3);
            
            // Calculate which quarters to show
            let quartersToShow = [];
            
            // Add last 2 full quarters
            for (let i = 2; i >= 1; i--) {
                let targetQuarter = currentQuarter - i;
                let targetYear = currentYear;
                
                if (targetQuarter <= 0) {
                    targetQuarter += 4;
                    targetYear -= 1;
                }
                
                quartersToShow.push({ year: targetYear, quarter: targetQuarter });
            }
            
            // Add current quarter (partial)
            quartersToShow.push({ year: currentYear, quarter: currentQuarter });
            
            // Build list of months to include
            const monthsToInclude = new Set();
            quartersToShow.forEach(q => {
                const startMonth = (q.quarter - 1) * 3 + 1; // 1, 4, 7, 10
                const endMonth = q.quarter * 3; // 3, 6, 9, 12
                
                for (let m = startMonth; m <= endMonth; m++) {
                    const monthKey = `${q.year}-${String(m).padStart(2, '0')}`;
                    // Only include if we have data and it's not in the future
                    if (monthKey <= currentMonthKey && sortedMonths.includes(monthKey)) {
                        monthsToInclude.add(monthKey);
                    }
                }
            });
            
            const filteredMonths = Array.from(monthsToInclude).sort();
            
            // Build quarter structure for headers
            const quarterStructure = [];
            quartersToShow.forEach(q => {
                const startMonth = (q.quarter - 1) * 3 + 1;
                const endMonth = q.quarter * 3;
                const quarterMonths = [];
                
                for (let m = startMonth; m <= endMonth; m++) {
                    const monthKey = `${q.year}-${String(m).padStart(2, '0')}`;
                    if (filteredMonths.includes(monthKey)) {
                        quarterMonths.push(monthKey);
                    }
                }
                
                if (quarterMonths.length > 0) {
                    quarterStructure.push({
                        label: `Q${q.quarter} ${q.year}`,
                        months: quarterMonths,
                        year: q.year,
                        quarter: q.quarter
                    });
                }
            });
            
            const monthNames = filteredMonths.map(m => {
                const [year, month] = m.split('-');
                const date = new Date(parseInt(year), parseInt(month) - 1);
                return date.toLocaleString('default', { month: 'short' });
            });
            
            // Log which months are being displayed (for debugging)
            console.log(`üìä VSP Analytics: All months found: ${sortedMonths.join(', ')}`);
            console.log(`üìä VSP Analytics: Displaying months (filtered): ${filteredMonths.join(', ')}`);
            console.log(`üìÖ Current month: ${currentMonthKey}`);
            console.log(`üìä Quarter structure:`, quarterStructure);
            
            // Show status message if no data
            if (filteredMonths.length === 0) {
                html += `
                    <div class="alert warning" style="margin-top: 40px;">
                        <h3>üìä VSP Performance Tables</h3>
                        <p><strong>Waiting for data to be loaded...</strong></p>
                        <p>These tables will appear once you upload the required files:</p>
                        <ul style="margin: 10px 0 0 20px;">
                            <li><strong>Conversion Table:</strong> Requires membership sales CSV (with Customer Email column)</li>
                            <li><strong>Utilization Table:</strong> Requires payroll ZIP file with time tracking data</li>
                        </ul>
                        <p style="margin-top: 15px;">
                            Current data status:<br>
                            ‚Ä¢ Appointments: ${appointmentsData.length} records ‚úÖ<br>
                            ‚Ä¢ Memberships: ${window.membershipsData ? window.membershipsData.length + ' records ‚úÖ' : 'Not loaded ‚ùå'}<br>
                            ‚Ä¢ Time Tracking: ${window.timeTrackingData ? window.timeTrackingData.length + ' records ‚úÖ' : 'Not loaded ‚ùå'}
                        </p>
                    </div>
                `;
                return html;
            }
            
            // Add section header for new tables
            html += `
                <div style="margin-top: 20px; padding: 20px; background: linear-gradient(135deg, var(--accent) 0%, var(--primary) 100%); border-radius: 8px; text-align: center;">
                    <h2 style="color: white; margin: 0;">üìä VSP Performance Analytics</h2>
                    <p style="color: white; margin: 5px 0 0 0; font-size: 14px;">Conversion Rates & Utilization Metrics by Month</p>
                </div>
            `;
            
            // Render Conversion Rates Table
            if (Object.keys(conversionByVSPMonth).length > 0 && filteredMonths.length > 0) {
                html += `
                    <div class="table-container" style="margin-top: 30px;">
                        <h2>üìä Conversion of Introductory Stretch to Paid Member</h2>
                        <p style="font-size: 14px; color: #666; margin: 10px 0;">By VSP and Quarter</p>
                        <table class="vsp-table">
                            <thead>
                                <!-- Quarter grouping row -->
                                <tr>
                                    <th rowspan="2" style="background: var(--primary); color: white; vertical-align: middle;">VSP</th>
                                    ${quarterStructure.map(q => 
                                        `<th colspan="${q.months.length + 1}" style="background: var(--primary); color: white; text-align: center;">${q.label} Total</th>`
                                    ).join('')}
                                    <th rowspan="2" style="background: var(--primary); color: white; font-weight: bold; text-align: center; vertical-align: middle;">Overall</th>
                                </tr>
                                <!-- Month row -->
                                <tr>
                                    ${quarterStructure.map(q => {
                                        const monthCells = q.months.map(monthKey => {
                                            const [year, month] = monthKey.split('-');
                                            const date = new Date(parseInt(year), parseInt(month) - 1);
                                            const monthName = date.toLocaleString('default', { month: 'short' });
                                            return `<th style="background: var(--primary); color: white; text-align: center;">${monthName}</th>`;
                                        }).join('');
                                        const totalCell = `<th style="background: var(--accent); color: white; text-align: center; font-weight: bold;">Total</th>`;
                                        return monthCells + totalCell;
                                    }).join('')}
                                </tr>
                            </thead>
                            <tbody>
                `;
                
                // Sort VSPs alphabetically
                const sortedVSPs = Object.keys(conversionByVSPMonth).filter(vsp => !vsp.toLowerCase().includes('sauna')).sort();
                
                sortedVSPs.forEach(vsp => {
                    html += `<tr><td style="font-weight: bold; background: var(--gray-light);">${vsp}</td>`;
                    
                    let overallIntros = 0;
                    let overallConversions = 0;
                    
                    // Output months grouped by quarter with quarter total immediately after
                    quarterStructure.forEach(quarter => {
                        let quarterIntros = 0;
                        let quarterConversions = 0;
                        
                        quarter.months.forEach(monthKey => {
                            const data = conversionByVSPMonth[vsp] && conversionByVSPMonth[vsp][monthKey];
                            if (data && data.introStretches > 0) {
                                const rate = ((data.conversions / data.introStretches) * 100).toFixed(0);
                                quarterIntros += data.introStretches;
                                quarterConversions += data.conversions;
                                
                                // Add color shading based on conversion rate
                                let cellStyle = 'text-align: center;';
                                if (rate >= 50) {
                                    cellStyle = 'text-align: center; background: rgba(0, 102, 204, 0.3);';
                                } else if (rate >= 30) {
                                    cellStyle = 'text-align: center; background: rgba(255, 140, 0, 0.3);';
                                } else if (rate > 0) {
                                    cellStyle = 'text-align: center; background: rgba(139, 0, 139, 0.3);';
                                }
                                
                                const tooltip = `Conversions: ${data.conversions} / Intro Stretches: ${data.introStretches} = ${rate}%`;
                                html += `<td style="${cellStyle}" title="${tooltip}">
                                    <div style="font-weight: bold;">${rate}%</div>
                                    <div style="font-size: 0.7em; color: #666; margin-top: 2px;">${data.conversions}/${data.introStretches}</div>
                                </td>`;
                            } else {
                                html += `<td style="text-align: center; color: #ccc;">-</td>`;
                            }
                        });
                        
                        overallIntros += quarterIntros;
                        overallConversions += quarterConversions;
                        
                        // Output quarter total immediately after months
                        const qRate = quarterIntros > 0 ? ((quarterConversions / quarterIntros) * 100).toFixed(0) : 0;
                        let qCellStyle = 'text-align: center; font-weight: bold; background: rgba(113, 190, 210, 0.2);';
                        if (qRate >= 50) {
                            qCellStyle = 'text-align: center; font-weight: bold; background: rgba(0, 102, 204, 0.4);';
                        } else if (qRate >= 30) {
                            qCellStyle = 'text-align: center; font-weight: bold; background: rgba(255, 140, 0, 0.4);';
                        } else if (qRate > 0) {
                            qCellStyle = 'text-align: center; font-weight: bold; background: rgba(139, 0, 139, 0.4);';
                        }
                        const qTooltip = `Quarter Total: ${quarterConversions} / ${quarterIntros} = ${qRate}%`;
                        html += `<td style="${qCellStyle}" title="${qTooltip}">
                            <div style="font-weight: bold;">${qRate}%</div>
                            <div style="font-size: 0.7em; color: #666; margin-top: 2px;">${quarterConversions}/${quarterIntros}</div>
                        </td>`;
                    });
                    
                    // Output overall total
                    const overallRate = overallIntros > 0 ? ((overallConversions / overallIntros) * 100).toFixed(0) : 0;
                    let overallCellStyle = 'text-align: center; font-weight: bold; background: var(--gray-light);';
                    if (overallRate >= 50) {
                        overallCellStyle = 'text-align: center; font-weight: bold; background: rgba(0, 102, 204, 0.3);';
                    } else if (overallRate >= 30) {
                        overallCellStyle = 'text-align: center; font-weight: bold; background: rgba(255, 140, 0, 0.3);';
                    } else if (overallRate > 0) {
                        overallCellStyle = 'text-align: center; font-weight: bold; background: rgba(139, 0, 139, 0.3);';
                    }
                    const overallTooltip = `Overall: ${overallConversions} / ${overallIntros} = ${overallRate}%`;
                    html += `<td style="${overallCellStyle}" title="${overallTooltip}">
                        <div style="font-weight: bold;">${overallRate}%</div>
                        <div style="font-size: 0.7em; color: #666; margin-top: 2px;">${overallConversions}/${overallIntros}</div>
                    </td>`;
                    html += `</tr>`;
                });
                
                // Add Grand Total row
                html += `<tr style="background: var(--accent); font-weight: bold;">
                    <td style="color: var(--primary);">Grand Total</td>`;
                
                let grandOverallIntros = 0;
                let grandOverallConversions = 0;
                
                // Output months grouped by quarter with quarter total immediately after
                quarterStructure.forEach(quarter => {
                    let qIntros = 0;
                    let qConversions = 0;
                    
                    quarter.months.forEach(monthKey => {
                        let monthIntros = 0;
                        let monthConversions = 0;
                        
                        sortedVSPs.forEach(vsp => {
                            const data = conversionByVSPMonth[vsp] && conversionByVSPMonth[vsp][monthKey];
                            if (data) {
                                monthIntros += data.introStretches;
                                monthConversions += data.conversions;
                            }
                        });
                        
                        qIntros += monthIntros;
                        qConversions += monthConversions;
                        
                        const monthRate = monthIntros > 0 ? ((monthConversions / monthIntros) * 100).toFixed(0) : 0;
                        html += `<td style="text-align: center; color: var(--primary);">
                            <div style="font-weight: bold;">${monthRate}%</div>
                            <div style="font-size: 0.7em; color: #666; margin-top: 2px;">${monthConversions}/${monthIntros}</div>
                        </td>`;
                    });
                    
                    grandOverallIntros += qIntros;
                    grandOverallConversions += qConversions;
                    
                    // Output quarter total immediately after months
                    const qRate = qIntros > 0 ? ((qConversions / qIntros) * 100).toFixed(0) : 0;
                    html += `<td style="text-align: center; color: var(--primary);">
                        <div style="font-weight: bold;">${qRate}%</div>
                        <div style="font-size: 0.7em; color: #666; margin-top: 2px;">${qConversions}/${qIntros}</div>
                    </td>`;
                });
                
                // Overall total
                const grandOverallRate = grandOverallIntros > 0 ? ((grandOverallConversions / grandOverallIntros) * 100).toFixed(0) : 0;
                html += `<td style="text-align: center; color: var(--primary);">
                    <div style="font-weight: bold;">${grandOverallRate}%</div>
                    <div style="font-size: 0.7em; color: #666; margin-top: 2px;">${grandOverallConversions}/${grandOverallIntros}</div>
                </td>`;
                html += `</tr>`;
                
                html += `
                            </tbody>
                        </table>
                        <div class="alert info" style="margin-top: 20px;">
                            <p><strong>Note:</strong> Conversion rate calculated as: (customers with first appointment who became members) / (total customers with first appointments).</p>
                            <p>This measures how effectively each VSP converts new customers into paying members.</p>
                            <ul style="margin: 10px 0 0 20px;">
                                <li><strong>Excellent:</strong> 50%+ (Blue shading)</li>
                                <li><strong>Good:</strong> 30-49% (Orange shading)</li>
                                <li><strong>Needs Improvement:</strong> Below 30% (Purple shading)</li>
                            </ul>
                        </div>
                    </div>
                `;
            }
            
            // Render Utilization Rates Table
            // Always show if we have any utilization data OR if time tracking exists
            const hasUtilizationData = Object.keys(utilizationByVSPMonth).length > 0;
            const hasTimeTracking = window.timeTrackingData && window.timeTrackingData.length > 0;
            
            if ((hasUtilizationData || hasTimeTracking) && filteredMonths.length > 0) {
                html += `
                    <div class="table-container" style="margin-top: 40px;">
                        <h2>‚è±Ô∏è Utilization Rates</h2>
                        <p style="font-size: 14px; color: #666; margin: 10px 0;">By VSP and Quarter (Table Time Efficiency)</p>
                `;
                
                // Add debug info if no data
                if (!hasUtilizationData) {
                    html += `
                        <div class="alert warning" style="margin-bottom: 20px;">
                            <p><strong>‚ö†Ô∏è No utilization data available.</strong></p>
                            <p>Time tracking data: ${hasTimeTracking ? 'Loaded (' + window.timeTrackingData.length + ' records)' : 'Not loaded'}</p>
                            <p>VSPs with appointment hours: ${Object.keys(utilizationByVSPMonth).length}</p>
                        </div>
                    `;
                }
                
                html += `
                        <table class="vsp-table">
                            <thead>
                                <!-- Quarter grouping row -->
                                <tr>
                                    <th rowspan="2" style="background: var(--primary); color: white; vertical-align: middle;">VSP</th>
                                    ${quarterStructure.map(q => 
                                        `<th colspan="${q.months.length + 1}" style="background: var(--primary); color: white; text-align: center;">${q.label} Total</th>`
                                    ).join('')}
                                    <th rowspan="2" style="background: var(--primary); color: white; font-weight: bold; text-align: center; vertical-align: middle;">Overall</th>
                                </tr>
                                <!-- Month row -->
                                <tr>
                                    ${quarterStructure.map(q => {
                                        const monthCells = q.months.map(monthKey => {
                                            const [year, month] = monthKey.split('-');
                                            const date = new Date(parseInt(year), parseInt(month) - 1);
                                            const monthName = date.toLocaleString('default', { month: 'short' });
                                            return `<th style="background: var(--primary); color: white; text-align: center;">${monthName}</th>`;
                                        }).join('');
                                        const totalCell = `<th style="background: var(--accent); color: white; text-align: center; font-weight: bold;">Total</th>`;
                                        return monthCells + totalCell;
                                    }).join('')}
                                </tr>
                            </thead>
                            <tbody>
                `;
                
                // Sort VSPs alphabetically - use all VSPs from appointments data
                let sortedVSPs;
                if (Object.keys(utilizationByVSPMonth).length > 0) {
                    sortedVSPs = Object.keys(utilizationByVSPMonth).filter(vsp => !vsp.toLowerCase().includes('sauna')).sort();
                } else {
                    // If no utilization data, get VSPs from practitionersList
                    sortedVSPs = practitionersList.map(p => p.name).filter(vsp => !vsp.toLowerCase().includes('sauna')).sort();
                }
                
                sortedVSPs.forEach(vsp => {
                    html += `<tr><td style="font-weight: bold; background: var(--gray-light);">${vsp}</td>`;
                    
                    let overallApptHours = 0;
                    let overallClockedHours = 0;
                    
                    // Output months grouped by quarter with quarter total immediately after
                    quarterStructure.forEach(quarter => {
                        let quarterApptHours = 0;
                        let quarterClockedHours = 0;
                        
                        quarter.months.forEach(monthKey => {
                            const data = utilizationByVSPMonth[vsp] && utilizationByVSPMonth[vsp][monthKey];
                            if (data && data.clockedHours > 0) {
                                const rate = ((data.appointmentHours / data.clockedHours) * 100).toFixed(0);
                                quarterApptHours += data.appointmentHours;
                                quarterClockedHours += data.clockedHours;
                                
                                // Color code based on utilization rate
                                let cellStyle = 'text-align: center;';
                                if (rate >= 60) cellStyle += ' background: rgba(0, 102, 204, 0.3);';
                                else if (rate >= 40) cellStyle += ' background: rgba(255, 140, 0, 0.3);';
                                else if (rate < 40 && rate > 0) cellStyle += ' background: rgba(139, 0, 139, 0.3);';
                                
                                const debugInfo = `Appt: ${data.appointmentHours.toFixed(1)}h / Clocked: ${data.clockedHours.toFixed(1)}h = ${rate}%`;
                                html += `<td style="${cellStyle}" title="${debugInfo}">${rate}%</td>`;
                            } else {
                                html += `<td style="text-align: center; color: #ccc;">-</td>`;
                            }
                        });
                        
                        overallApptHours += quarterApptHours;
                        overallClockedHours += quarterClockedHours;
                        
                        // Output quarter total immediately after months
                        const qRate = quarterClockedHours > 0 ? ((quarterApptHours / quarterClockedHours) * 100).toFixed(0) : 0;
                        let qCellStyle = 'text-align: center; font-weight: bold; background: rgba(113, 190, 210, 0.2);';
                        if (qRate >= 60) {
                            qCellStyle = 'text-align: center; font-weight: bold; background: rgba(0, 102, 204, 0.4);';
                        } else if (qRate >= 40) {
                            qCellStyle = 'text-align: center; font-weight: bold; background: rgba(255, 140, 0, 0.4);';
                        } else if (qRate < 40 && qRate > 0) {
                            qCellStyle = 'text-align: center; font-weight: bold; background: rgba(139, 0, 139, 0.4);';
                        }
                        const qTooltip = `Quarter: ${quarterApptHours.toFixed(1)}h / ${quarterClockedHours.toFixed(1)}h = ${qRate}%`;
                        html += `<td style="${qCellStyle}" title="${qTooltip}">${qRate}%</td>`;
                    });
                    
                    // Output overall total
                    const overallRate = overallClockedHours > 0 ? ((overallApptHours / overallClockedHours) * 100).toFixed(0) : 0;
                    let overallCellStyle = 'text-align: center; font-weight: bold; background: var(--gray-light);';
                    if (overallRate >= 60) {
                        overallCellStyle = 'text-align: center; font-weight: bold; background: rgba(0, 102, 204, 0.3);';
                    } else if (overallRate >= 40) {
                        overallCellStyle = 'text-align: center; font-weight: bold; background: rgba(255, 140, 0, 0.3);';
                    } else if (overallRate < 40 && overallRate > 0) {
                        overallCellStyle = 'text-align: center; font-weight: bold; background: rgba(139, 0, 139, 0.3);';
                    }
                    const overallTooltip = `Overall: ${overallApptHours.toFixed(1)}h / ${overallClockedHours.toFixed(1)}h = ${overallRate}%`;
                    html += `<td style="${overallCellStyle}" title="${overallTooltip}">${overallRate}%</td>`;
                    html += `</tr>`;
                });
                
                // Add Grand Total row
                html += `<tr style="background: var(--accent); font-weight: bold;">
                    <td style="color: var(--primary);">Grand Total</td>`;
                
                let grandOverallApptHours = 0;
                let grandOverallClockedHours = 0;
                
                // Output months grouped by quarter with quarter total immediately after
                quarterStructure.forEach(quarter => {
                    let qApptHours = 0;
                    let qClockedHours = 0;
                    
                    quarter.months.forEach(monthKey => {
                        let monthApptHours = 0;
                        let monthClockedHours = 0;
                        
                        sortedVSPs.forEach(vsp => {
                            const data = utilizationByVSPMonth[vsp] && utilizationByVSPMonth[vsp][monthKey];
                            if (data) {
                                monthApptHours += data.appointmentHours;
                                monthClockedHours += data.clockedHours;
                            }
                        });
                        
                        qApptHours += monthApptHours;
                        qClockedHours += monthClockedHours;
                        
                        const monthRate = monthClockedHours > 0 ? ((monthApptHours / monthClockedHours) * 100).toFixed(0) : 0;
                        html += `<td style="text-align: center; color: var(--primary);">${monthRate}%</td>`;
                    });
                    
                    grandOverallApptHours += qApptHours;
                    grandOverallClockedHours += qClockedHours;
                    
                    // Output quarter total immediately after months
                    const qRate = qClockedHours > 0 ? ((qApptHours / qClockedHours) * 100).toFixed(0) : 0;
                    html += `<td style="text-align: center; color: var(--primary);">${qRate}%</td>`;
                });
                
                // Overall total
                const grandOverallRate = grandOverallClockedHours > 0 ? ((grandOverallApptHours / grandOverallClockedHours) * 100).toFixed(0) : 0;
                html += `<td style="text-align: center; color: var(--primary);">${grandOverallRate}%</td>`;
                html += `</tr>`;
                
                html += `
                            </tbody>
                        </table>
                        <div class="alert info" style="margin-top: 20px;">
                            <p><strong>Note:</strong> Utilization rate measures the percentage of clocked-in time spent with clients (table time). Higher rates indicate better efficiency.</p>
                            <ul style="margin: 10px 0 0 20px;">
                                <li><strong>Excellent:</strong> 60%+ (Blue shading)</li>
                                <li><strong>Good:</strong> 40-59% (Orange shading)</li>
                                <li><strong>Needs Improvement:</strong> Below 40% (Purple shading)</li>
                            </ul>
                        </div>
                    </div>
                `;
            }
            
            return html;
        }
        
        // TIMELINE TAB
        function renderTimelineTab() {
            const data = filteredAppointments;
            const activeMemberEmails = getActiveMemberEmails();
            
            // Group by date with comprehensive metrics
            const dailyData = {};
            const clientsByDate = {};
            
            data.forEach(row => {
                const date = parseDate(row['Appointment Date']).toLocaleDateString();
                if (!dailyData[date]) {
                    dailyData[date] = { 
                        revenue: 0, 
                        appointments: 0, 
                        hours: 0,
                        payout: 0,
                        profit: 0,
                        newClients: new Set(),
                        returningClients: new Set(),
                        apptHours: 0,  // For utilization calculation
                        clockedHours: 0  // For utilization calculation
                    };
                    clientsByDate[date] = new Set();
                }
                
                const revenue = parseFloat(row.Revenue || 0);
                const payout = parseFloat(row['Total Payout'] || 0);
                const email = (row['Customer Email'] || '').toLowerCase().trim();
                
                // Only count revenue if customer is NOT an active member
                const revenueToAdd = activeMemberEmails.has(email) ? 0 : revenue;
                
                dailyData[date].revenue += revenueToAdd;
                dailyData[date].appointments++;
                dailyData[date].hours += parseFloat(row['Time (h)'] || 0);
                dailyData[date].apptHours += parseFloat(row['Time (h)'] || 0);  // Track appointment hours
                dailyData[date].payout += payout;
                dailyData[date].profit += (revenueToAdd - payout);
                
                // Track new vs returning clients
                if (email) {
                    clientsByDate[date].add(email);
                    // Check if this client had appointments before this date
                    const priorAppointments = data.filter(r => {
                        const rDate = parseDate(r['Appointment Date']).toLocaleDateString();
                        const rEmail = (r['Customer Email'] || '').toLowerCase().trim();
                        return rEmail === email && new Date(rDate) < new Date(date);
                    });
                    
                    if (priorAppointments.length === 0) {
                        dailyData[date].newClients.add(email);
                    } else {
                        dailyData[date].returningClients.add(email);
                    }
                }
            });
            
            // Add clocked hours to daily data if time tracking is available
            if (window.timeTrackingData && window.timeTrackingData.length > 0) {
                window.timeTrackingData.forEach(row => {
                    const clockedIn = row['Clocked in'] ? new Date(row['Clocked in']) : null;
                    if (clockedIn) {
                        const date = clockedIn.toLocaleDateString();
                        if (dailyData[date]) {
                            dailyData[date].clockedHours += parseFloat(row['Duration (h)'] || 0);
                        }
                    }
                });
                
                // Calculate utilization for each day
                Object.keys(dailyData).forEach(date => {
                    if (dailyData[date].clockedHours > 0) {
                        dailyData[date].utilization = (dailyData[date].apptHours / dailyData[date].clockedHours) * 100;
                    } else {
                        dailyData[date].utilization = null;
                    }
                });
            }
            
            const dates = Object.keys(dailyData).sort((a, b) => new Date(a) - new Date(b));
            const avgDailyRevenue = dates.length > 0 
                ? Object.values(dailyData).reduce((sum, d) => sum + d.revenue, 0) / dates.length 
                : 0;
            const avgDailyAppointments = dates.length > 0
                ? Object.values(dailyData).reduce((sum, d) => sum + d.appointments, 0) / dates.length
                : 0;
            const avgDailyProfit = dates.length > 0
                ? Object.values(dailyData).reduce((sum, d) => sum + d.profit, 0) / dates.length
                : 0;
            
            // Calculate average daily utilization
            const daysWithUtilization = Object.values(dailyData).filter(d => d.utilization !== null && d.utilization !== undefined);
            const avgDailyUtilization = daysWithUtilization.length > 0
                ? daysWithUtilization.reduce((sum, d) => sum + d.utilization, 0) / daysWithUtilization.length
                : null;
            
            const bestDay = dates.reduce((best, date) => {
                return dailyData[date].revenue > (dailyData[best]?.revenue || 0) ? date : best;
            }, dates[0]);
            
            const totalRevenue = Object.values(dailyData).reduce((sum, d) => sum + d.revenue, 0);
            
            let html = `
                <div class="metrics-grid" style="grid-template-columns: repeat(${avgDailyUtilization !== null ? '5' : '4'}, 1fr);">
                    <div class="metric-card">
                        <div class="metric-label">Avg Daily Revenue</div>
                        <div class="metric-value">${formatCurrency(avgDailyRevenue)}</div>
                        <div class="metric-subtext">Per business day</div>
                    </div>
                    <div class="metric-card">
                        <div class="metric-label">Avg Daily Appointments</div>
                        <div class="metric-value">${avgDailyAppointments.toFixed(1)}</div>
                        <div class="metric-subtext">Per business day</div>
                    </div>
                    <div class="metric-card">
                        <div class="metric-label">Avg Daily Profit</div>
                        <div class="metric-value">${formatCurrency(avgDailyProfit)}</div>
                        <div class="metric-subtext">After payouts</div>
                    </div>
                    ${avgDailyUtilization !== null ? `
                    <div class="metric-card success">
                        <div class="metric-label">Avg Daily Utilization</div>
                        <div class="metric-value">${avgDailyUtilization.toFixed(1)}%</div>
                        <div class="metric-subtext">Table time efficiency</div>
                    </div>
                    ` : ''}
                    <div class="metric-card">
                        <div class="metric-label">Best Day</div>
                        <div class="metric-value">${formatCurrency(dailyData[bestDay]?.revenue || 0)}</div>
                        <div class="metric-subtext">${bestDay}</div>
                    </div>
                </div>
                
                <div class="charts-grid">
                    <div class="chart-container full-width">
                        <h3>Daily Revenue Trend</h3>
                        <div class="chart-wrapper">
                            <canvas id="dailyRevenueChart"></canvas>
                        </div>
                    </div>
                    
                    <div class="chart-container full-width">
                        <h3>Daily Appointments</h3>
                        <div class="chart-wrapper">
                            <canvas id="dailyAppointmentsChart"></canvas>
                        </div>
                    </div>
                    
                    ${avgDailyUtilization !== null ? `
                    <div class="chart-container full-width">
                        <h3>Daily Utilization Trend</h3>
                        <div class="chart-wrapper">
                            <canvas id="dailyUtilizationChart"></canvas>
                        </div>
                    </div>
                    ` : ''}
                    
                    <div class="chart-container full-width">
                        <h3>Cumulative Revenue Over Time</h3>
                        <div class="chart-wrapper">
                            <canvas id="cumulativeRevenueChart"></canvas>
                        </div>
                    </div>
                    
                    <div class="chart-container full-width">
                        <h3>Daily Profit Trend</h3>
                        <div class="chart-wrapper">
                            <canvas id="dailyProfitChart"></canvas>
                        </div>
                    </div>
                    
                    <div class="chart-container full-width">
                        <h3>Daily Revenue per Appointment (Efficiency)</h3>
                        <div class="chart-wrapper">
                            <canvas id="dailyRevenuePerApptChart"></canvas>
                        </div>
                    </div>
                    
                    <div class="chart-container full-width">
                        <h3>New vs Returning Clients Per Day</h3>
                        <div class="chart-wrapper">
                            <canvas id="dailyClientTypeChart"></canvas>
                        </div>
                    </div>
                    
                    <div class="chart-container full-width">
                        <h3>Daily Hours Worked</h3>
                        <div class="chart-wrapper">
                            <canvas id="dailyHoursChart"></canvas>
                        </div>
                    </div>
                    
                    <div class="chart-container full-width">
                        <h3>Weekly Membership Sales Trend</h3>
                        <div class="chart-wrapper">
                            <canvas id="membershipWeeklyChart"></canvas>
                        </div>
                    </div>
                    
                    <div class="chart-container full-width">
                        <h3>Weekly Average Membership Sale Value</h3>
                        <div class="chart-wrapper">
                            <canvas id="membershipAvgValueChart"></canvas>
                        </div>
                    </div>
                    
                    ${filteredLeadsConverted.length > 0 ? `
                    <div class="chart-container full-width">
                        <div class="interactive-badge" title="Click on any bar to see lead details"></div>
                        <h3>Daily Leads by All Locations</h3>
                        <div class="chart-wrapper">
                            <canvas id="leadsTimelineAllChart"></canvas>
                        </div>
                    </div>
                    
                    <div class="chart-container full-width">
                        <div class="interactive-badge" title="Click on any bar to see lead details"></div>
                        <h3>Daily Leads by Location (Stacked)</h3>
                        <div class="chart-wrapper">
                            <canvas id="leadsTimelineLocationStackedChart"></canvas>
                        </div>
                    </div>
                    ` : ''}
                    
                    <div class="chart-container full-width">
                        <h3>üí∏ Franchise Fees Timeline (Stacked)</h3>
                        <div class="chart-wrapper">
                            <canvas id="feesTimelineChart"></canvas>
                        </div>
                        <div style="margin-top: 15px; padding: 15px; background: var(--gray-light); border-radius: 8px;">
                            <div style="display: grid; grid-template-columns: repeat(auto-fit, minmax(150px, 1fr)); gap: 15px;">
                                <div style="text-align: center;">
                                    <div style="font-size: 12px; color: #666;">Franchise Fee</div>
                                    <div style="font-size: 16px; font-weight: bold; color: var(--primary);">${formatCurrency(totalRevenue * CONFIG.franchiseFeePercent / 100)}</div>
                                    <div style="font-size: 11px; color: #999;">${CONFIG.franchiseFeePercent}% of revenue</div>
                                </div>
                                <div style="text-align: center;">
                                    <div style="font-size: 12px; color: #666;">Brand Fund</div>
                                    <div style="font-size: 16px; font-weight: bold; color: var(--accent);">${formatCurrency(totalRevenue * CONFIG.brandFundPercent / 100)}</div>
                                    <div style="font-size: 11px; color: #999;">${CONFIG.brandFundPercent}% of revenue</div>
                                </div>
                                <div style="text-align: center;">
                                    <div style="font-size: 12px; color: #666;">CC Processing</div>
                                    <div style="font-size: 16px; font-weight: bold; color: var(--highlight);">${formatCurrency(totalRevenue * CONFIG.ccFeesPercent / 100)}</div>
                                    <div style="font-size: 11px; color: #999;">${CONFIG.ccFeesPercent}% of revenue</div>
                                </div>
                                <div style="text-align: center;">
                                    <div style="font-size: 12px; color: #666;">Total Fees</div>
                                    <div style="font-size: 18px; font-weight: bold; color: var(--danger);">${formatCurrency(totalRevenue * (CONFIG.franchiseFeePercent + CONFIG.brandFundPercent + CONFIG.ccFeesPercent) / 100)}</div>
                                    <div style="font-size: 11px; color: #999;">${((CONFIG.franchiseFeePercent + CONFIG.brandFundPercent + CONFIG.ccFeesPercent)).toFixed(1)}% of revenue</div>
                                </div>
                            </div>
                        </div>
                    </div>
                </div>
            `;
            
            document.getElementById('timeline').innerHTML = html;
            
            // Render charts
            setTimeout(() => {
                renderTimelineCharts(dailyData, dates);
                renderMembershipTimelineCharts();
                if (leadsConvertedData.length > 0) {
                    renderLeadsTimelineCharts();
                }
                
                // Render appointment heatmaps by location
                const locations = [...new Set(data.map(row => row.Location).filter(l => l))].sort();
                locations.forEach(location => {
                    const locationAppts = data.filter(row => row.Location === location);
                    const containerId = `apptHeatmap-${location.replace(/\s+/g, '-')}`;
                    const container = document.getElementById(containerId);
                    if (container) {
                        renderAppointmentHeatmap(locationAppts, containerId, location);
                    }
                });
            }, 100);
        }
        
        // INSIGHTS TAB (with monthly goal tracking)
        function renderInsightsTab() {
            const data = filteredAppointments;
            
            // Calculate various insights - exclude active member revenue
            const totalRevenue = calculateAppointmentRevenue(data);
            const totalPayout = data.reduce((sum, row) => sum + parseFloat(row['Total Payout'] || 0), 0);
            const totalHours = data.reduce((sum, row) => sum + parseFloat(row['Time (h)'] || 0), 0);
            
            // Calculate total labor costs including non-appointment work
            let totalLaborCost = totalPayout;
            let nonApptHours = 0;
            let nonApptLaborCost = 0;
            
            if (filteredTimeTracking && filteredTimeTracking.length > 0) {
                // Get the list of practitioners who have appointments in the filtered data
                const practitionersInFiltered = new Set();
                data.forEach(row => {
                    const empName = row['Employee Name'];
                    if (empName) {
                        practitionersInFiltered.add(empName);
                    }
                });
                
                // Only count time tracking for practitioners who have appointments in the filtered data
                const relevantTimeTracking = filteredTimeTracking.filter(t => 
                    practitionersInFiltered.has(t['Employee Name'])
                );
                
                const totalClockedHours = relevantTimeTracking.reduce((sum, t) => {
                    const hours = parseFloat(t['Duration (h)'] || 0);
                    return sum + hours;
                }, 0);
                
                // Non-appointment hours = clocked hours - appointment hours
                nonApptHours = Math.max(0, totalClockedHours - totalHours);
                nonApptLaborCost = nonApptHours * CONFIG.baseHourlyRate;
                totalLaborCost = totalPayout + nonApptLaborCost;
            }
            
            // Calculate salary costs for the filtered period
            let salaryCosts = { total: 0, details: [] };
            if (data.length > 0) {
                const dates = data.map(row => parseDate(row['Appointment Date']));
                const minDate = new Date(Math.min(...dates));
                const maxDate = new Date(Math.max(...dates));
                salaryCosts = calculateSalaryCosts(minDate, maxDate);
                totalLaborCost += salaryCosts.total;
            }
            
            const profit = totalRevenue - totalLaborCost;
            const profitMargin = totalRevenue > 0 ? (profit / totalRevenue * 100) : 0;
            
            // Client retention
            const clientVisits = {};
            data.forEach(row => {
                const email = (row['Customer Email'] || '').toLowerCase().trim();
                if (email) {
                    clientVisits[email] = (clientVisits[email] || 0) + 1;
                }
            });
            
            const uniqueClients = Object.keys(clientVisits).length;
            const returningClients = Object.values(clientVisits).filter(count => count > 1).length;
            const retentionRate = uniqueClients > 0 ? (returningClients / uniqueClients * 100) : 0;
            
            // Service analysis
            const serviceRevenue = {};
            const serviceCount = {};
            data.forEach(row => {
                const service = row['Appointment'] || 'Unknown';
                serviceRevenue[service] = (serviceRevenue[service] || 0) + parseFloat(row.Revenue || 0);
                serviceCount[service] = (serviceCount[service] || 0) + 1;
            });
            
            const topService = Object.entries(serviceRevenue)
                .sort((a, b) => b[1] - a[1])[0];
            
            // Goals tracking - Monthly basis
            const revenueGoal = CONFIG.goals.monthlyRevenue;
            const appointmentsGoal = CONFIG.goals.monthlyAppointments;
            const revenueProgress = (totalRevenue / revenueGoal) * 100;
            const appointmentsProgress = (data.length / appointmentsGoal) * 100;
            
            const currentPeriod = getCurrentPeriod();
            
            // Calculate intro appointments
            const introAppointments = data.filter(row => isIntroOffer(row['Appointment'])).length;
            const introGoal = CONFIG.goals.monthlyIntroAppointments;
            const introProgress = (introAppointments / introGoal) * 100;
            
            let html = `
                <div class="table-container">
                    <h2>Goal Tracking - ${currentPeriod}</h2>
                    <p style="margin-bottom: 20px; color: #666;">Monthly goals: ${formatCurrency(revenueGoal)} revenue | ${formatNumber(appointmentsGoal)} appointments | ${formatNumber(introGoal)} intro appointments</p>
                    
                    <div class="charts-grid" style="grid-template-columns: 1fr 1fr 1fr;">
                        <div class="chart-container">
                            <h3>üìä Monthly Revenue vs Goal</h3>
                            <div class="chart-wrapper" style="height: 300px;">
                                <canvas id="monthlyRevenueGoalChart"></canvas>
                            </div>
                        </div>
                        <div class="chart-container">
                            <h3>üìä Monthly Paid Appointments vs Goal</h3>
                            <div class="chart-wrapper" style="height: 300px;">
                                <canvas id="monthlyAppointmentsGoalChart"></canvas>
                            </div>
                        </div>
                        <div class="chart-container">
                            <h3>üÜï Monthly Intro Appointments vs Goal</h3>
                            <div class="chart-wrapper" style="height: 300px;">
                                <canvas id="monthlyIntroGoalChart"></canvas>
                            </div>
                        </div>
                    </div>
                    
                    ${revenueProgress < 100 || introProgress < 100 ? `
                        <div class="alert ${revenueProgress >= 70 && introProgress >= 70 ? 'warning' : 'danger'}" style="margin-top: 20px;">
                            <h4>üìä Progress Update</h4>
                            ${revenueProgress < 100 ? `<p><strong>Revenue Gap:</strong> ${formatCurrency(revenueGoal - totalRevenue)} remaining to reach goal</p>` : ''}
                            ${appointmentsProgress < 100 ? `<p><strong>Appointments Gap:</strong> ${formatNumber(appointmentsGoal - data.length)} more appointments needed</p>` : ''}
                            ${introProgress < 100 ? `<p><strong>Intro Appointments Gap:</strong> ${formatNumber(introGoal - introAppointments)} more intro appointments needed</p>` : ''}
                            ${revenueProgress < 100 ? `<p style="margin-top: 10px;"><strong>To reach goal:</strong> Need ${formatCurrency((revenueGoal - totalRevenue)/(appointmentsGoal - data.length || 1))} per appointment</p>` : ''}
                        </div>
                    ` : `
                        <div class="alert success" style="margin-top: 20px;">
                            <h4>üéâ Goals Achieved!</h4>
                            <p>Congratulations! You've met your monthly targets. Keep up the excellent work!</p>
                        </div>
                    `}
                </div>
                
                <div class="metrics-grid" style="grid-template-columns: repeat(4, 1fr);">
                    <div class="metric-card">
                        <div class="metric-label">Profit Margin</div>
                        <div class="metric-value">${profitMargin.toFixed(1)}%</div>
                        <div class="metric-subtext">${formatCurrency(profit)} profit</div>
                    </div>
                    <div class="metric-card ${retentionRate >= 50 ? 'success' : retentionRate >= 30 ? 'warning' : 'danger'}">
                        <div class="metric-label">Client Retention</div>
                        <div class="metric-value">${retentionRate.toFixed(1)}%</div>
                        <div class="metric-subtext">${returningClients} returning clients</div>
                    </div>
                    <div class="metric-card">
                        <div class="metric-label">Top Service</div>
                        <div class="metric-value">${formatCurrency(topService ? topService[1] : 0)}</div>
                        <div class="metric-subtext">${topService ? topService[0].substring(0, 30) : 'N/A'}</div>
                    </div>
                    <div class="metric-card">
                        <div class="metric-label">Unique Clients</div>
                        <div class="metric-value">${formatNumber(uniqueClients)}</div>
                        <div class="metric-subtext">${(data.length/uniqueClients).toFixed(1)} avg visits</div>
                    </div>
                </div>
                
                <div class="alert ${retentionRate >= 50 ? 'success' : 'warning'}">
                    <h4>üí° Key Insights & Recommendations</h4>
                    <ul style="margin: 10px 0 0 20px; line-height: 1.8;">
                        <li><strong>Revenue:</strong> You're at ${revenueProgress.toFixed(0)}% of your monthly goal. ${revenueProgress >= 80 ? 'Great progress! Consider upselling premium services to exceed your target.' : `To reach goal faster, focus on booking ${Math.ceil((CONFIG.monthlyAppointmentGoal - data.length)/7)} more appointments per week.`}</li>
                        <li><strong>Retention:</strong> ${retentionRate.toFixed(0)}% of clients return for multiple visits. ${retentionRate >= 50 ? 'Excellent retention! Consider launching a VIP membership program for your most loyal clients.' : 'Create a 3-visit intro package and follow up within 48 hours of first appointments to boost retention.'}</li>
                        <li><strong>Profitability:</strong> Your profit margin is ${profitMargin.toFixed(1)}%. ${profitMargin >= 30 ? 'Healthy margins! Consider reinvesting 10-15% into marketing to scale growth.' : 'Review practitioner payout structure and optimize scheduling to reduce idle time and improve margins.'}</li>
                        <li><strong>Service Mix:</strong> "${topService ? topService[0] : 'N/A'}" generates the most revenue. Create package deals combining your top service with complementary services to increase average transaction value.</li>
                        <li><strong>Client Engagement:</strong> ${uniqueClients > 0 ? `With ${(data.length/uniqueClients).toFixed(1)} average visits per client, there's opportunity to increase visit frequency. Implement a rebooking incentive (e.g., "Book your next session today and save 10%").` : 'Focus on building your client base through referral programs and local partnerships.'}</li>
                        <li><strong>Revenue Per Client:</strong> ${uniqueClients > 0 ? `Current average is ${formatCurrency(totalRevenue/uniqueClients)} per client. Aim to increase this by 20% through package deals and membership options.` : 'Track this metric as your client base grows to optimize pricing strategy.'}</li>
                    </ul>
                </div>
                
                <div class="table-container">
                    <h2>Action Items</h2>
                    <div style="background: var(--gray-light); padding: 20px; border-radius: 10px; border-left: 4px solid var(--accent);">
                        <h4 style="margin-bottom: 15px; color: var(--primary);">Recommended Actions This Week:</h4>
                        <ol style="margin: 0 0 0 20px; line-height: 2;">
                            <li><strong>Follow-up Campaign:</strong> Contact all one-time visitors from the past 30 days with a special "We miss you" discount offer.</li>
                            <li><strong>Package Creation:</strong> Bundle your top 3 services into an attractive package deal priced 15% below individual session rates.</li>
                            <li><strong>Schedule Optimization:</strong> Review your Schedule tab to identify gaps and opportunities to add 2-3 more appointments per week.</li>
                            <li><strong>Client Feedback:</strong> Send a quick survey to your top 10 clients asking what they love and what could be improved.</li>
                            <li><strong>Referral Program:</strong> Launch a "Bring a Friend" promotion where both the referrer and new client get a discount.</li>
                            ${retentionRate < 50 ? '<li><strong>Retention Focus:</strong> Create an automated email sequence that goes out 7, 14, and 30 days after first visit to encourage rebooking.</li>' : ''}
                            ${profitMargin < 30 ? '<li><strong>Cost Analysis:</strong> Review your top expenses and identify 1-2 areas where you can reduce costs without impacting quality.</li>' : ''}
                        </ol>
                    </div>
                </div>
                
                ${window.attendanceData && window.attendanceData.length > 0 ? `
                <div class="table-container" style="background: linear-gradient(135deg, rgba(113, 190, 210, 0.05), rgba(113, 190, 210, 0.02)); border-left: 5px solid var(--accent);">
                    <h2>üìã Attendance Analytics</h2>
                    <p style="margin-bottom: 15px; color: #666;">Client booking patterns and upcoming appointments</p>
                    
                    ${(() => {
                        // Filter attendance data by current date filters if applicable
                        let attendanceRecords = window.attendanceData;
                        
                        // Count appointments per client
                        const clientAppointments = {};
                        const staffAppointments = {};
                        let upcomingCount = 0;
                        let paidCount = 0;
                        let unpaidCount = 0;
                        const now = new Date();
                        
                        attendanceRecords.forEach(row => {
                            const clientEmail = (row['E-mail'] || '').toLowerCase().trim();
                            const clientName = `${row['First Name'] || ''} ${row['Last Name'] || ''}`.trim();
                            const staffName = row['Staff Name'] || 'Unknown';
                            const reservationDate = row['Date of reservation'];
                            const isPaid = (row['Is paid'] || '').toLowerCase();
                            
                            if (clientEmail && clientName) {
                                if (!clientAppointments[clientEmail]) {
                                    clientAppointments[clientEmail] = {
                                        name: clientName,
                                        count: 0,
                                        upcoming: 0,
                                        paid: 0
                                    };
                                }
                                clientAppointments[clientEmail].count++;
                                
                                // Parse reservation date
                                if (reservationDate) {
                                    const resDate = new Date(reservationDate);
                                    if (resDate > now) {
                                        clientAppointments[clientEmail].upcoming++;
                                        upcomingCount++;
                                    }
                                }
                                
                                if (isPaid === 'yes') {
                                    clientAppointments[clientEmail].paid++;
                                    paidCount++;
                                } else {
                                    unpaidCount++;
                                }
                            }
                            
                            // Count by staff
                            if (staffName) {
                                staffAppointments[staffName] = (staffAppointments[staffName] || 0) + 1;
                            }
                        });
                        
                        // Top 10 most frequent clients
                        const topClients = Object.entries(clientAppointments)
                            .sort((a, b) => b[1].count - a[1].count)
                            .slice(0, 10);
                        
                        // Top VSPs by appointment count
                        const topStaff = Object.entries(staffAppointments)
                            .sort((a, b) => b[1] - a[1])
                            .slice(0, 5);
                        
                        return `
                            <div class="metrics-grid" style="grid-template-columns: repeat(4, 1fr); margin-bottom: 20px;">
                                <div class="metric-card">
                                    <div class="metric-label">üìÖ Total Reservations</div>
                                    <div class="metric-value">${formatNumber(attendanceRecords.length)}</div>
                                    <div class="metric-subtext">From attendance data</div>
                                </div>
                                <div class="metric-card ${upcomingCount > 50 ? 'success' : upcomingCount > 20 ? 'warning' : ''}">
                                    <div class="metric-label">üîÆ Upcoming Appointments</div>
                                    <div class="metric-value">${formatNumber(upcomingCount)}</div>
                                    <div class="metric-subtext">Future bookings</div>
                                </div>
                                <div class="metric-card success">
                                    <div class="metric-label">‚úÖ Paid</div>
                                    <div class="metric-value">${formatNumber(paidCount)}</div>
                                    <div class="metric-subtext">${((paidCount/(paidCount + unpaidCount))*100).toFixed(1)}% of total</div>
                                </div>
                                <div class="metric-card warning">
                                    <div class="metric-label">‚è≥ Unpaid</div>
                                    <div class="metric-value">${formatNumber(unpaidCount)}</div>
                                    <div class="metric-subtext">${((unpaidCount/(paidCount + unpaidCount))*100).toFixed(1)}% of total</div>
                                </div>
                            </div>
                            
                            <div class="charts-grid" style="grid-template-columns: 1fr 1fr;">
                                <div>
                                    <h3>üë• Top 10 Most Frequent Clients</h3>
                                    <p style="font-size: 12px; color: #666; margin: -5px 0 10px 0;">Clients with most appointments booked</p>
                                    <table style="width: 100%;">
                                        <thead>
                                            <tr>
                                                <th style="text-align: left;">Client</th>
                                                <th style="text-align: center;">Total</th>
                                                <th style="text-align: center;">Upcoming</th>
                                                <th style="text-align: center;">Paid</th>
                                            </tr>
                                        </thead>
                                        <tbody>
                                            ${topClients.map(([email, data], index) => `
                                                <tr>
                                                    <td style="font-weight: ${index < 3 ? 'bold' : 'normal'};">
                                                        ${index === 0 ? 'ü•á' : index === 1 ? 'ü•à' : index === 2 ? 'ü•â' : `${index + 1}.`} ${data.name}
                                                    </td>
                                                    <td style="text-align: center; font-weight: bold;">${data.count}</td>
                                                    <td style="text-align: center;">${data.upcoming}</td>
                                                    <td style="text-align: center;">${data.paid}</td>
                                                </tr>
                                            `).join('')}
                                        </tbody>
                                    </table>
                                </div>
                                
                                <div>
                                    <h3>‚≠ê Top VSPs by Appointments Booked</h3>
                                    <p style="font-size: 12px; color: #666; margin: -5px 0 10px 0;">VSPs with most appointments in attendance data</p>
                                    <table style="width: 100%;">
                                        <thead>
                                            <tr>
                                                <th style="text-align: left;">VSP</th>
                                                <th style="text-align: center;">Appointments</th>
                                                <th style="text-align: center;">% of Total</th>
                                            </tr>
                                        </thead>
                                        <tbody>
                                            ${topStaff.map(([name, count], index) => `
                                                <tr>
                                                    <td style="font-weight: ${index < 3 ? 'bold' : 'normal'};">
                                                        ${index === 0 ? 'ü•á' : index === 1 ? 'ü•à' : index === 2 ? 'ü•â' : `${index + 1}.`} ${name}
                                                    </td>
                                                    <td style="text-align: center; font-weight: bold;">${formatNumber(count)}</td>
                                                    <td style="text-align: center;">${((count/attendanceRecords.length)*100).toFixed(1)}%</td>
                                                </tr>
                                            `).join('')}
                                        </tbody>
                                    </table>
                                </div>
                            </div>
                            
                            ${upcomingCount > 0 ? `
                            <div class="alert info" style="margin-top: 15px;">
                                <h4>üìÖ Booking Pipeline</h4>
                                <p>You have <strong>${formatNumber(upcomingCount)}</strong> appointments scheduled. ${upcomingCount > 50 ? 'Strong booking pipeline! ' : upcomingCount > 20 ? 'Moderate booking pipeline. ' : 'Limited upcoming bookings. '}${unpaidCount > 10 ? `Consider sending payment reminders to the <strong>${formatNumber(unpaidCount)}</strong> clients with unpaid reservations.` : ''}</p>
                            </div>
                            ` : ''}
                        `;
                    })()}
                </div>
                ` : ''}
                
                <div class="table-container">
                    <h2>Complete AI Recommendations Report</h2>
                    <p style="margin-bottom: 20px; color: #666;">All personalized recommendations ranked by potential impact.</p>
                    ${(() => {
                        const recommendations = generateSmartRecommendations();
                        if (recommendations.length === 0) {
                            return '<div class="alert success"><h4>üéâ Outstanding Performance!</h4><p>Your business is operating at peak efficiency across all metrics. Continue your current strategies!</p></div>';
                        }
                        return recommendations.map((rec, index) => `
                            <div class="recommendation-card">
                                <div style="display: flex; justify-content: space-between; align-items: start;">
                                    <div style="flex: 1;">
                                        <span class="recommendation-priority ${rec.priority}">#${index + 1} ${rec.priority.toUpperCase()} PRIORITY</span>
                                        <div class="recommendation-title">${rec.title}</div>
                                        <p style="margin: 10px 0; color: #666; line-height: 1.6;">${rec.description}</p>
                                        <p style="margin: 10px 0; padding: 12px; background: rgba(113, 190, 210, 0.1); border-radius: 8px; border-left: 3px solid var(--accent);">
                                            <strong>üìã Action Plan:</strong> ${rec.action}
                                        </p>
                                        <div class="recommendation-impact">
                                            <strong>üí∞ Estimated Impact:</strong> ${rec.impact}
                                        </div>
                                    </div>
                                </div>
                            </div>
                        `).join('');
                    })()}
                </div>
            `;
            
            document.getElementById('insights').innerHTML = html;
            
            // Render monthly goal charts
            renderMonthlyGoalCharts(data, revenueGoal, appointmentsGoal);
        }
        
        // Render monthly goal charts
        function renderMonthlyGoalCharts(appointmentsData, revenueGoal, appointmentsGoal) {
            // Group data by month
            const monthlyData = {};
            const introGoal = CONFIG.goals.monthlyIntroAppointments;
            
            appointmentsData.forEach(row => {
                const date = parseDate(row['Appointment Date']);
                if (date) {
                    const monthKey = `${date.getFullYear()}-${String(date.getMonth() + 1).padStart(2, '0')}`;
                    if (!monthlyData[monthKey]) {
                        monthlyData[monthKey] = {
                            revenue: 0,
                            appointments: 0,
                            introAppointments: 0
                        };
                    }
                    monthlyData[monthKey].revenue += parseFloat(row.Revenue) || 0;
                    
                    // Only count paid (non-intro) appointments toward the appointments goal
                    if (isIntroOffer(row['Appointment'])) {
                        monthlyData[monthKey].introAppointments++;
                    } else {
                        monthlyData[monthKey].appointments++;
                    }
                }
            });
            
            const sortedMonths = Object.keys(monthlyData).sort();
            const monthLabels = sortedMonths.map(month => {
                const [year, mon] = month.split('-');
                const date = new Date(year, mon - 1);
                return date.toLocaleDateString('en-US', { month: 'short', year: 'numeric' });
            });
            
            // Revenue Goal Chart
            const revenueCanvas = document.getElementById('monthlyRevenueGoalChart');
            if (revenueCanvas) {
                destroyChart('monthlyRevenueGoal');
                const ctx = revenueCanvas.getContext('2d');
                
                allCharts.monthlyRevenueGoal = new Chart(ctx, {
                    type: 'bar',
                    data: {
                        labels: monthLabels,
                        datasets: [
                            {
                                label: 'Actual Revenue',
                                data: sortedMonths.map(m => monthlyData[m].revenue),
                                backgroundColor: '#71BED2',
                                borderColor: '#5aa8bf',
                                borderWidth: 2
                            },
                            {
                                label: 'Goal',
                                data: sortedMonths.map(() => revenueGoal),
                                backgroundColor: 'rgba(251, 181, 20, 0.3)',
                                borderColor: '#FBB514',
                                borderWidth: 2,
                                borderDash: [5, 5],
                                type: 'line',
                                fill: false
                            }
                        ]
                    },
                    options: {
                        responsive: true,
                        maintainAspectRatio: false,
                        plugins: {
                            legend: {
                                display: true,
                                position: 'top'
                            },
                            tooltip: {
                                callbacks: {
                                    label: function(context) {
                                        return context.dataset.label + ': ' + formatCurrency(context.parsed.y);
                                    }
                                }
                            }
                        },
                        scales: {
                            y: {
                                beginAtZero: true,
                                ticks: {
                                    callback: function(value) {
                                        return formatCurrency(value);
                                    }
                                }
                            }
                        }
                    }
                });
            }
            
            // Appointments Goal Chart
            const appointmentsCanvas = document.getElementById('monthlyAppointmentsGoalChart');
            if (appointmentsCanvas) {
                destroyChart('monthlyAppointmentsGoal');
                const ctx = appointmentsCanvas.getContext('2d');
                
                allCharts.monthlyAppointmentsGoal = new Chart(ctx, {
                    type: 'bar',
                    data: {
                        labels: monthLabels,
                        datasets: [
                            {
                                label: 'Actual Paid Appointments',
                                data: sortedMonths.map(m => monthlyData[m].appointments),
                                backgroundColor: '#013160',
                                borderColor: '#001a3a',
                                borderWidth: 2
                            },
                            {
                                label: 'Goal',
                                data: sortedMonths.map(() => appointmentsGoal),
                                backgroundColor: 'rgba(251, 181, 20, 0.3)',
                                borderColor: '#FBB514',
                                borderWidth: 2,
                                borderDash: [5, 5],
                                type: 'line',
                                fill: false
                            }
                        ]
                    },
                    options: {
                        responsive: true,
                        maintainAspectRatio: false,
                        plugins: {
                            legend: {
                                display: true,
                                position: 'top'
                            },
                            tooltip: {
                                callbacks: {
                                    label: function(context) {
                                        return context.dataset.label + ': ' + formatNumber(context.parsed.y);
                                    }
                                }
                            }
                        },
                        scales: {
                            y: {
                                beginAtZero: true,
                                ticks: {
                                    stepSize: 10
                                }
                            }
                        }
                    }
                });
            }
            
            // Intro Appointments Goal Chart
            const introCanvas = document.getElementById('monthlyIntroGoalChart');
            if (introCanvas) {
                destroyChart('monthlyIntroGoal');
                const ctx = introCanvas.getContext('2d');
                
                allCharts.monthlyIntroGoal = new Chart(ctx, {
                    type: 'bar',
                    data: {
                        labels: monthLabels,
                        datasets: [
                            {
                                label: 'Actual Intro Appointments',
                                data: sortedMonths.map(m => monthlyData[m].introAppointments),
                                backgroundColor: '#FBB514',
                                borderColor: '#e5a313',
                                borderWidth: 2
                            },
                            {
                                label: 'Goal',
                                data: sortedMonths.map(() => introGoal),
                                backgroundColor: 'rgba(1, 49, 96, 0.3)',
                                borderColor: '#013160',
                                borderWidth: 2,
                                borderDash: [5, 5],
                                type: 'line',
                                fill: false
                            }
                        ]
                    },
                    options: {
                        responsive: true,
                        maintainAspectRatio: false,
                        plugins: {
                            legend: {
                                display: true,
                                position: 'top'
                            },
                            tooltip: {
                                callbacks: {
                                    label: function(context) {
                                        return context.dataset.label + ': ' + formatNumber(context.parsed.y);
                                    }
                                }
                            }
                        },
                        scales: {
                            y: {
                                beginAtZero: true,
                                ticks: {
                                    stepSize: 5
                                }
                            }
                        }
                    }
                });
            }
        }
        
        // PERIOD COMPARISON FUNCTIONS
        let comparisonData = null;
        
        function toggleComparison() {
            const comparisonType = document.getElementById('comparisonPeriod').value;
            if (comparisonType !== 'none') {
                calculateComparisonData();
            } else {
                comparisonData = null;
            }
            renderAllTabs();
        }
        
        function calculateComparisonData() {
            const comparisonType = document.getElementById('comparisonPeriod').value;
            if (comparisonType === 'none') {
                comparisonData = null;
                return;
            }
            
            // Check if appointments data is available
            if (!appointmentsData || appointmentsData.length === 0) {
                comparisonData = null;
                return;
            }
            
            // Get date range from inputs, or calculate from filtered data
            let startDate = document.getElementById('startDate').value ? new Date(document.getElementById('startDate').value) : null;
            let endDate = document.getElementById('endDate').value ? new Date(document.getElementById('endDate').value) : null;
            
            // If no dates specified, use the date range from filtered appointments
            if (!startDate || !endDate) {
                if (filteredAppointments.length === 0) {
                    comparisonData = null;
                    return;
                }
                
                const dates = filteredAppointments
                    .map(row => parseDate(row['Appointment Date']))
                    .filter(date => date)
                    .sort((a, b) => a - b);
                
                if (dates.length === 0) {
                    comparisonData = null;
                    return;
                }
                
                startDate = dates[0];
                endDate = dates[dates.length - 1];
            }
            
            const daysDiff = Math.ceil((endDate - startDate) / (1000 * 60 * 60 * 24));
            let compStart, compEnd;
            
            switch(comparisonType) {
                case 'previous':
                    compStart = new Date(startDate);
                    compStart.setDate(compStart.getDate() - daysDiff);
                    compEnd = new Date(startDate);
                    compEnd.setDate(compEnd.getDate() - 1);
                    break;
                case 'lastMonth':
                    compStart = new Date(startDate);
                    compStart.setMonth(compStart.getMonth() - 1);
                    compEnd = new Date(endDate);
                    compEnd.setMonth(compEnd.getMonth() - 1);
                    break;
                case 'lastQuarter':
                    compStart = new Date(startDate);
                    compStart.setMonth(compStart.getMonth() - 3);
                    compEnd = new Date(endDate);
                    compEnd.setMonth(compEnd.getMonth() - 3);
                    break;
                case 'lastYear':
                    compStart = new Date(startDate);
                    compStart.setFullYear(compStart.getFullYear() - 1);
                    compEnd = new Date(endDate);
                    compEnd.setFullYear(compEnd.getFullYear() - 1);
                    break;
            }
            
            // Filter comparison data from the global appointmentsData
            const compData = appointmentsData.filter(row => {
                const date = parseDate(row['Appointment Date']);
                return date && date >= compStart && date <= compEnd;
            });
            
            comparisonData = {
                revenue: compData.reduce((sum, row) => sum + parseFloat(row.Revenue || 0), 0),
                appointments: compData.length,
                clients: new Set(compData.map(r => r['Customer Email']).filter(e => e)).size,
                profit: compData.reduce((sum, row) => sum + parseFloat(row.Revenue || 0) - parseFloat(row['Total Payout'] || 0), 0),
                period: `${compStart.toLocaleDateString()} - ${compEnd.toLocaleDateString()}`
            };
        }
        
        function getComparisonIndicator(current, previous, format = 'number') {
            if (!comparisonData || previous === 0) return '';
            
            const change = ((current - previous) / previous) * 100;
            const isPositive = change > 0;
            const isNegative = change < 0;
            const arrow = isPositive ? '‚Üë' : isNegative ? '‚Üì' : '‚Üí';
            const className = isPositive ? 'positive' : isNegative ? 'negative' : 'neutral';
            
            let displayValue;
            if (format === 'currency') {
                displayValue = formatCurrency(Math.abs(current - previous));
            } else if (format === 'percent') {
                displayValue = `${Math.abs(change).toFixed(1)}%`;
            } else {
                displayValue = `${Math.abs(change).toFixed(1)}%`;
            }
            
            return `<span class="comparison-indicator ${className}"><span class="comparison-arrow">${arrow}</span>${displayValue}</span>`;
        }
        
        // MEMBERSHIPS TAB
        function renderMembershipsTab() {
            if (!membershipsData || membershipsData.length === 0) {
                document.getElementById('memberships').innerHTML = `
                    <div class="alert info">
                        <h4>üí≥ Membership Analytics</h4>
                        <p>Upload the <strong>Membership Sales CSV</strong> file to unlock comprehensive membership analytics including revenue tracking, retention analysis, and sales performance.</p>
                    </div>
                `;
                return;
            }
            
            // filteredMemberships is already set by applyFilters() with date range filtering
            // Don't overwrite it here!
            
            if (filteredMemberships.length === 0) {
                document.getElementById('memberships').innerHTML = `
                    <div class="alert info">
                        <h4>üí≥ Membership Analytics</h4>
                        <p>No membership records found with "Hour/Month" or "Hours/Month" in the membership name.</p>
                    </div>
                `;
                return;
            }
            
            // Build VSP email-to-name mapping from appointments data
            window.vspEmailToName = {}; // Make global so formatVSPName can access it
            window.customerHomeLocation = {}; // Map customer email to home location - make global
            
            if (appointmentsData && appointmentsData.length > 0) {
                appointmentsData.forEach(appt => {
                    // VSP mapping
                    const staffEmail = (appt['Staff E-mail'] || appt['Staff Email'] || '').toLowerCase().trim();
                    const staffName = (appt['Staff Name'] || '').trim();
                    if (staffEmail && staffName) {
                        window.vspEmailToName[staffEmail] = staffName;
                    }
                    
                    // Customer location mapping
                    const customerEmail = (appt['E-mail'] || appt['Customer Email'] || '').toLowerCase().trim();
                    const location = appt['Location'] || appt['Home location'];
                    if (customerEmail && location && !window.customerHomeLocation[customerEmail]) {
                        window.customerHomeLocation[customerEmail] = location;
                    }
                });
            }
            
            // Also get home location from frozen memberships if available
            if (window.frozenMembershipsData && window.frozenMembershipsData.length > 0) {
                window.frozenMembershipsData.forEach(frozen => {
                    const email = (frozen['Customer email'] || '').toLowerCase().trim();
                    const location = frozen['Home location'];
                    if (email && location && !window.customerHomeLocation[email]) {
                        window.customerHomeLocation[email] = location;
                    }
                });
            }
            
            // Check if there are multiple unique locations
            const uniqueLocations = new Set(Object.values(window.customerHomeLocation).filter(loc => loc && loc !== 'N/A'));
            const showLocationColumn = uniqueLocations.size > 1;
            
            // Helper function to format VSP name as "First L."
            window.formatVSPName = function(emailOrName) {
                if (!emailOrName) return 'Direct/Online';
                
                let name = emailOrName;
                
                // If it's an email, look up the name first
                if (emailOrName.includes('@')) {
                    const emailLower = emailOrName.toLowerCase().trim();
                    if (window.vspEmailToName && window.vspEmailToName[emailLower]) {
                        name = window.vspEmailToName[emailLower];
                    } else {
                        // No mapping found, return username part
                        return emailOrName.split('@')[0];
                    }
                }
                
                if (name === 'Direct/Online') return name;
                
                // Format name as "First L."
                const nameParts = name.trim().split(' ');
                if (nameParts.length >= 2) {
                    const firstName = nameParts[0];
                    const lastInitial = nameParts[nameParts.length - 1].charAt(0).toUpperCase();
                    return `${firstName} ${lastInitial}.`;
                }
                
                return name;
            }
            
            // Make customerHomeLocation available globally for export (already done above)
            window.vspEmailToName = window.vspEmailToName; // Already global
            
            // Parse membership data
            const now = new Date();
            const activeMemberships = [];
            const expiredMemberships = [];
            membershipTypes = {}; // Using global variable
            const dailyRevenue = {};
            const dailyActiveMembers = {}; // Track daily active members
            const dailyFrozenMembers = {}; // Track daily frozen members  
            const dailyRenewals = {}; // Track daily renewals
            const dailyCancellations = {}; // Track daily cancellations
            const monthlyRevenue = {};
            salesByStaff = {}; // Using global variable
            const frozenCount = filteredMemberships.filter(m => m.Frozen === 'Yes').length;
            const refundedCount = filteredMemberships.filter(m => parseFloat(m.Refunded) > 0).length;
            
            let totalRevenue = 0;
            let avgMembershipValue = 0;
            let newSalesCount = 0;
            let renewalsCount = 0;
            let newSalesRevenue = 0;
            let renewalsRevenue = 0;
            
            // First pass: Group memberships by customer to find first VSP and identify new vs renewal
            window.customerFirstVSP = {}; // Make global for export
            const customerPurchaseCount = {};
            
            // Sort memberships by date to properly identify first purchase
            const sortedMemberships = [...filteredMemberships].sort((a, b) => {
                const dateA = a['Bought Date/Time (GMT)'] ? new Date(a['Bought Date/Time (GMT)']) : new Date(0);
                const dateB = b['Bought Date/Time (GMT)'] ? new Date(b['Bought Date/Time (GMT)']) : new Date(0);
                return dateA - dateB;
            });
            
            sortedMemberships.forEach(membership => {
                const email = (membership['Customer Email'] || '').toLowerCase().trim();
                if (!email) return;
                
                const boughtDate = membership['Bought Date/Time (GMT)'] ? convertGMTtoLocal(membership['Bought Date/Time (GMT)']) : null;
                const soldBy = membership['Sold by'] || '';
                
                // Track customer purchase count
                if (!customerPurchaseCount[email]) {
                    customerPurchaseCount[email] = 0;
                }
                customerPurchaseCount[email]++;
                
                // Track first VSP
                if (!window.customerFirstVSP[email]) {
                    window.customerFirstVSP[email] = {
                        vsp: soldBy,
                        date: boughtDate,
                        purchaseId: membership['Purchase ID']
                    };
                }
            });
            
            // Second pass: Process all memberships
            filteredMemberships.forEach(membership => {
                const paidAmount = parseFloat(membership['Paid Amount']) || 0;
                totalRevenue += paidAmount;
                
                // Determine if new sale or renewal
                const email = (membership['Customer Email'] || '').toLowerCase().trim();
                const purchaseId = membership['Purchase ID'];
                const isFirstPurchase = email && window.customerFirstVSP[email] && window.customerFirstVSP[email].purchaseId === purchaseId;
                
                if (isFirstPurchase) {
                    newSalesCount++;
                    newSalesRevenue += paidAmount;
                    membership._isNewSale = true;
                } else if (email && window.customerFirstVSP[email]) {
                    renewalsCount++;
                    renewalsRevenue += paidAmount;
                    membership._isRenewal = true;
                }
                
                // Parse dates
                const boughtDate = membership['Bought Date/Time (GMT)'] ? convertGMTtoLocal(membership['Bought Date/Time (GMT)']) : null;
                const expiryDate = membership['Remaining/ Expiry/ Renewal'] ? new Date(membership['Remaining/ Expiry/ Renewal']) : null;
                const isExpired = membership.Expired === 'Yes';
                
                // Categorize active vs expired
                if (isExpired || (expiryDate && expiryDate < now)) {
                    expiredMemberships.push(membership);
                } else {
                    activeMemberships.push(membership);
                }
                
                // Track membership types
                const type = membership['Membership Name'] || 'Unknown';
                if (!membershipTypes[type]) {
                    membershipTypes[type] = { count: 0, revenue: 0, active: 0, newSales: 0, renewals: 0 };
                }
                membershipTypes[type].count++;
                membershipTypes[type].revenue += paidAmount;
                if (!isExpired && (!expiryDate || expiryDate >= now)) {
                    membershipTypes[type].active++;
                }
                if (membership._isNewSale) {
                    membershipTypes[type].newSales++;
                } else if (membership._isRenewal) {
                    membershipTypes[type].renewals++;
                }
                
                // Track daily revenue
                if (boughtDate) {
                    const dateKey = boughtDate.toISOString().split('T')[0];
                    if (!dailyRevenue[dateKey]) {
                        dailyRevenue[dateKey] = 0;
                    }
                    dailyRevenue[dateKey] += paidAmount;
                    
                    // Track monthly revenue
                    const monthKey = `${boughtDate.getFullYear()}-${String(boughtDate.getMonth() + 1).padStart(2, '0')}`;
                    if (!monthlyRevenue[monthKey]) {
                        monthlyRevenue[monthKey] = 0;
                    }
                    monthlyRevenue[monthKey] += paidAmount;
                }
                
                // Track sales by staff - credit to FIRST VSP for this customer
                let soldBy = membership['Sold by'] || '';
                
                // If customer has a first VSP recorded and this sale has no VSP, credit the first VSP
                if (email && window.customerFirstVSP[email]) {
                    soldBy = window.customerFirstVSP[email].vsp || soldBy;
                }
                
                // If still empty, mark as Direct/Online
                if (!soldBy) {
                    soldBy = 'Direct/Online';
                }
                
                if (!salesByStaff[soldBy]) {
                    salesByStaff[soldBy] = { count: 0, revenue: 0, newSales: 0, renewals: 0 };
                }
                salesByStaff[soldBy].count++;
                salesByStaff[soldBy].revenue += paidAmount;
                if (membership._isNewSale) {
                    salesByStaff[soldBy].newSales++;
                } else if (membership._isRenewal) {
                    salesByStaff[soldBy].renewals++;
                }
            });
            
            avgMembershipValue = totalRevenue / membershipsData.length;
            
            // Track renewals by date (using the purchase date) - do this before the date range loop
            filteredMemberships.forEach(membership => {
                if (membership._isRenewal) {
                    const boughtDate = membership['Bought Date/Time (GMT)'] ? convertGMTtoLocal(membership['Bought Date/Time (GMT)']) : null;
                    if (boughtDate) {
                        const dateKey = boughtDate.toISOString().split('T')[0];
                        if (!dailyRenewals[dateKey]) {
                            dailyRenewals[dateKey] = 0;
                        }
                        dailyRenewals[dateKey]++;
                    }
                }
            });
            
            // Track daily cancellations if we have cancellation data
            if (membershipCancellationsData && membershipCancellationsData.length > 0) {
                membershipCancellationsData.forEach(cancellation => {
                    const cancelDate = cancellation['Cancelled at'] ? new Date(cancellation['Cancelled at']) : null;
                    if (cancelDate) {
                        const dateKey = cancelDate.toISOString().split('T')[0];
                        if (!dailyCancellations[dateKey]) {
                            dailyCancellations[dateKey] = 0;
                        }
                        dailyCancellations[dateKey]++;
                    }
                });
            }
            
            // Calculate MRR (Monthly Recurring Revenue) from active subscriptions
            let mrr = 0;
            activeMemberships.forEach(m => {
                if (m['Membership Type'] === 'subscription') {
                    const amount = parseFloat(m['Paid Amount']) || 0;
                    mrr += amount;
                }
            });
            
            // Sort data for charts
            const sortedDates = Object.keys(dailyRevenue).sort();
            const sortedMonths = Object.keys(monthlyRevenue).sort();
            
            // Calculate cumulative revenue
            const cumulativeRevenue = [];
            let cumSum = 0;
            sortedDates.forEach(date => {
                cumSum += dailyRevenue[date];
                cumulativeRevenue.push({ date, value: cumSum });
            });
            
            // Calculate daily active members
            // For each day in the date range, count how many memberships are active on that day
            const allDates = sortedDates.length > 0 ? sortedDates : [];
            if (allDates.length > 0) {
                const startDate = new Date(allDates[0]);
                const endDate = new Date(allDates[allDates.length - 1]);
                
                // Build a map of frozen memberships by email
                const frozenMembershipsByEmail = {};
                if (window.frozenMembershipsData && window.frozenMembershipsData.length > 0) {
                    window.frozenMembershipsData.forEach(frozen => {
                        const email = (frozen['Customer email'] || '').toLowerCase().trim();
                        const frozenAtStr = frozen['Frozen at'];
                        const frozenDate = frozenAtStr ? new Date(frozenAtStr) : null;
                        const unfreezeDate = frozen['Scheduled unfreeze at'] ? new Date(frozen['Scheduled unfreeze at']) : null;
                        
                        // Normalize dates to midnight for comparison
                        if (frozenDate) {
                            frozenDate.setHours(0, 0, 0, 0);
                        }
                        if (unfreezeDate) {
                            unfreezeDate.setHours(0, 0, 0, 0);
                        }
                        
                        if (email && frozenDate) {
                            if (!frozenMembershipsByEmail[email]) {
                                frozenMembershipsByEmail[email] = [];
                            }
                            frozenMembershipsByEmail[email].push({
                                frozenDate: frozenDate,
                                unfreezeDate: unfreezeDate
                            });
                        }
                    });
                }
                
                // Fill in all dates in the range
                let cumulativeFrozenCount = 0;
                for (let d = new Date(startDate); d <= endDate; d.setDate(d.getDate() + 1)) {
                    const dateKey = d.toISOString().split('T')[0];
                    
                    // Normalize date to midnight for comparison
                    const compareDate = new Date(d);
                    compareDate.setHours(0, 0, 0, 0);
                    
                    // Count memberships that became newly frozen on this specific date
                    let newlyFrozenToday = 0;
                    if (window.frozenMembershipsData && window.frozenMembershipsData.length > 0) {
                        Object.values(frozenMembershipsByEmail).forEach(freezeList => {
                            freezeList.forEach(freeze => {
                                const freezeDateKey = freeze.frozenDate.toISOString().split('T')[0];
                                if (freezeDateKey === dateKey) {
                                    newlyFrozenToday++;
                                }
                            });
                        });
                    }
                    cumulativeFrozenCount += newlyFrozenToday;
                    
                    // Count active UNIQUE customers on this date (not membership rows, to avoid counting renewals multiple times)
                    let totalActiveCount = 0;
                    let frozenCountOnDate = 0;
                    
                    // Track unique customers we've counted
                    const activeCustomersOnDate = new Set();
                    const frozenCustomersOnDate = new Set();
                    
                    filteredMemberships.forEach(membership => {
                        const boughtDate = membership['Bought Date/Time (GMT)'] ? convertGMTtoLocal(membership['Bought Date/Time (GMT)']) : null;
                        const expiryDate = membership['Remaining/ Expiry/ Renewal'] ? new Date(membership['Remaining/ Expiry/ Renewal']) : null;
                        const email = (membership['Customer Email'] || '').toLowerCase().trim();
                        
                        if (!email) return; // Skip if no email
                        
                        if (boughtDate && boughtDate <= compareDate) {
                            // Membership was purchased by this date
                            if (!expiryDate || expiryDate >= compareDate) {
                                // Not expired yet on this date
                                activeCustomersOnDate.add(email);
                                
                                // Check if frozen on this date
                                let isFrozen = false;
                                if (email && frozenMembershipsByEmail[email]) {
                                    frozenMembershipsByEmail[email].forEach(freeze => {
                                        if (freeze.frozenDate <= compareDate) {
                                            // Was frozen by this date
                                            if (!freeze.unfreezeDate || freeze.unfreezeDate > compareDate) {
                                                // Still frozen (no unfreeze date or unfreeze is in the future)
                                                isFrozen = true;
                                            }
                                        }
                                    });
                                }
                                
                                if (isFrozen) {
                                    frozenCustomersOnDate.add(email);
                                }
                            }
                        }
                    });
                    
                    totalActiveCount = activeCustomersOnDate.size;
                    frozenCountOnDate = frozenCustomersOnDate.size;
                    
                    // Active members = total members - cumulative frozen count
                    dailyActiveMembers[dateKey] = totalActiveCount - cumulativeFrozenCount;
                    // Store cumulative frozen count for the "Frozen Members" line
                    dailyFrozenMembers[dateKey] = cumulativeFrozenCount;
                    // Store cumulative frozen count for calculating Total Members line
                    if (!window.dailyCurrentlyFrozen) window.dailyCurrentlyFrozen = {};
                    window.dailyCurrentlyFrozen[dateKey] = cumulativeFrozenCount;
                    
                    // Ensure renewals has a value for every date
                    if (!dailyRenewals[dateKey]) {
                        dailyRenewals[dateKey] = 0;
                    }
                }
            }
            
            // Calculate retention rate
            const totalMemberships = membershipsData.length;
            const retentionRate = ((activeMemberships.length / totalMemberships) * 100).toFixed(1);
            const churnRate = ((expiredMemberships.length / totalMemberships) * 100).toFixed(1);
            
            // Sort membership types by revenue
            const sortedTypes = Object.entries(membershipTypes)
                .sort((a, b) => b[1].revenue - a[1].revenue)
                .slice(0, 10);
            
            // Sort sales staff by count
            const sortedStaff = Object.entries(salesByStaff)
                .sort((a, b) => b[1].count - a[1].count)
                .slice(0, 10);
            
            // Calculate cancellations (expired memberships that were previously active)
            const canceledCount = expiredMemberships.length;
            const canceledRevenueLost = expiredMemberships.reduce((sum, m) => sum + (parseFloat(m['Paid Amount']) || 0), 0);
            
            // Advanced client segmentation
            const highValueClients = filteredMemberships.filter(m => parseFloat(m['Paid Amount']) >= 300).length;
            const subscriptionClients = filteredMemberships.filter(m => m['Membership Type'] === 'subscription').length;
            const packageClients = filteredMemberships.filter(m => m['Membership Type'] === 'package-events').length;
            const avgRevPerMember = totalRevenue / new Set(filteredMemberships.map(m => (m['Customer Email'] || '').toLowerCase())).size;
            const uniqueCustomers = new Set(filteredMemberships.map(m => (m['Customer Email'] || '').toLowerCase())).size;
            
            let html = `
                <div class="section">
                    <h2>Membership Analytics Overview</h2>
                    
                    <!-- Compact Metrics Grid -->
                    <div class="metrics-grid" style="grid-template-columns: repeat(6, 1fr); margin-bottom: 40px;">

                        <div class="metric-card compact" style="background: linear-gradient(135deg, rgba(40, 167, 69, 0.1), rgba(32, 201, 151, 0.05)); border-left: 4px solid #28a745;">
                            <div class="metric-label">üí≥ Active Members</div>
                            <div class="metric-value">${formatNumber(new Set(filteredMemberships.filter(m => m.Expired !== 'Yes' && m.Frozen !== 'Yes').map(m => (m['Customer Email'] || '').toLowerCase().trim())).size)}</div>
                            <div class="metric-subtext">${formatCurrency(newSalesRevenue)} revenue<br>Avg: ${formatCurrency(newSalesRevenue/newSalesCount)}${comparisonData ? `<br><span style="font-size: 10pt; color: #666;">vs comparison period</span>` : ''}</div>
                        </div>
                        
                        <div class="metric-card compact" style="background: linear-gradient(135deg, rgba(0, 123, 255, 0.1), rgba(0, 86, 179, 0.05)); border-left: 4px solid #007bff;">
                            <div class="metric-label">üîÑ Total Renewals</div>
                            <div class="metric-value">${formatNumber(renewalsCount)}</div>
                            <div class="metric-subtext">${formatCurrency(renewalsRevenue)} revenue<br>Avg: ${formatCurrency(renewalsRevenue/renewalsCount)}${comparisonData ? `<br><span style="font-size: 10pt; color: #666;">vs comparison period</span>` : ''}</div>
                        </div>
                        
                        <div class="metric-card compact" style="background: linear-gradient(135deg, rgba(156, 39, 176, 0.1), rgba(123, 31, 162, 0.05)); border-left: 4px solid #9c27b0;">
                            <div class="metric-label">üí∞ Total Revenue</div>
                            <div class="metric-value" style="font-size: 1.4em;">${formatCurrency(totalRevenue)}</div>
                            <div class="metric-subtext">${formatNumber(totalMemberships)} total memberships<br>Avg: ${formatCurrency(avgMembershipValue)}${comparisonData ? `<br><span style="font-size: 10pt; color: #666;">vs comparison period</span>` : ''}</div>
                        </div>
                        
                        <div class="metric-card compact" style="background: linear-gradient(135deg, rgba(255, 99, 132, 0.1), rgba(255, 56, 96, 0.05)); border-left: 4px solid #ff6384;">
                            <div class="metric-label">üìä Renewal Rate</div>
                            <div class="metric-value">${((renewalsCount / totalMemberships) * 100).toFixed(1)}%</div>
                            <div class="metric-subtext">${formatNumber(activeMemberships.length)} active<br>${retentionRate}% retention${comparisonData ? `<br><span style="font-size: 10pt; color: #666;">vs comparison period</span>` : ''}</div>
                        </div>
                        
                        <div class="metric-card compact" style="background: linear-gradient(135deg, rgba(255, 152, 0, 0.1), rgba(245, 124, 0, 0.05)); border-left: 4px solid #ff9800;">
                            <div class="metric-label">‚ùå Cancellations</div>
                            <div class="metric-value">${formatNumber(canceledCount)}</div>
                            <div class="metric-subtext">${churnRate}% churn rate<br>${formatCurrency(canceledRevenueLost)} revenue lost${comparisonData ? `<br><span style="font-size: 10pt; color: #666;">vs comparison period</span>` : ''}</div>
                        </div>
                        
                        <div class="metric-card compact" style="background: linear-gradient(135deg, rgba(33, 150, 243, 0.1), rgba(13, 71, 161, 0.05)); border-left: 4px solid #2196f3;">
                            <div class="metric-label">‚ùÑÔ∏è Frozen</div>
                            <div class="metric-value">${formatNumber(frozenCount)}</div>
                            <div class="metric-subtext">${((frozenCount / totalMemberships) * 100).toFixed(1)}% of total<br>memberships frozen${comparisonData ? `<br><span style="font-size: 10pt; color: #666;">vs comparison period</span>` : ''}</div>
                        </div>
                    </div>
                    
                    <!-- Advanced Client Segmentation -->
                    <div class="metrics-grid" style="grid-template-columns: repeat(4, 1fr); margin-bottom: 20px;">
                        <div class="metric-card compact" style="background: linear-gradient(135deg, rgba(76, 175, 80, 0.1), rgba(56, 142, 60, 0.05)); border-left: 4px solid #4caf50;">
                            <div class="metric-label">üíé High-Value Clients</div>
                            <div class="metric-value">${formatNumber(highValueClients)}</div>
                            <div class="metric-subtext">${((highValueClients / totalMemberships) * 100).toFixed(1)}% of memberships<br>$300+ purchases</div>
                        </div>
                        
                        <div class="metric-card compact" style="background: linear-gradient(135deg, rgba(103, 58, 183, 0.1), rgba(81, 45, 168, 0.05)); border-left: 4px solid #673ab7;">
                            <div class="metric-label">üîÅ Subscription Members</div>
                            <div class="metric-value">${formatNumber(subscriptionClients)}</div>
                            <div class="metric-subtext">${((subscriptionClients / totalMemberships) * 100).toFixed(1)}% recurring<br>MRR: ${formatCurrency(mrr)}</div>
                        </div>
                        
                        <div class="metric-card compact" style="background: linear-gradient(135deg, rgba(0, 188, 212, 0.1), rgba(0, 151, 167, 0.05)); border-left: 4px solid #00bcd4;">
                            <div class="metric-label">üì¶ Package Clients</div>
                            <div class="metric-value">${formatNumber(packageClients)}</div>
                            <div class="metric-subtext">${((packageClients / totalMemberships) * 100).toFixed(1)}% packages<br>One-time purchases</div>
                        </div>
                        
                        <div class="metric-card compact" style="background: linear-gradient(135deg, rgba(255, 87, 34, 0.1), rgba(230, 74, 25, 0.05)); border-left: 4px solid #ff5722;">
                            <div class="metric-label">üë§ Unique Customers</div>
                            <div class="metric-value">${formatNumber(uniqueCustomers)}</div>
                            <div class="metric-subtext">Avg Revenue: ${formatCurrency(avgRevPerMember)}<br>${(totalMemberships / uniqueCustomers).toFixed(1)} purchases/customer</div>
                        </div>
                    </div>
                </div>
                
                <!-- Daily Active Members Chart -->
                <div class="section">
                    <h2>üìà Daily Active Members Trend</h2>
                    <div class="chart-container full-width">
                        <div class="chart-wrapper">
                            <canvas id="dailyActiveMembersChart"></canvas>
                        </div>
                    </div>
                </div>
                
                <!-- Membership Type Breakdown -->
                <div class="section">
                    <h2>Membership Type Analysis</h2>
                    <div class="chart-grid">
                        <div class="chart-container">
                            <h3>Memberships by Type</h3>
                            <div class="chart-wrapper">
                                <canvas id="membershipTypeCountChart"></canvas>
                            </div>
                        </div>
                        
                        <div class="chart-container">
                            <h3>Revenue by Membership Type</h3>
                            <div class="chart-wrapper">
                                <canvas id="membershipTypeRevenueChart"></canvas>
                            </div>
                        </div>
                    </div>
                    
                    <!-- Membership Type Table -->
                    <div class="table-container">
                        <h3>Membership Type Details</h3>
                        <button onclick="exportMembershipTypeData()" style="float: right; padding: 8px 16px; background: var(--accent); color: white; border: none; border-radius: 5px; cursor: pointer; margin-bottom: 10px;">üì• Export to CSV</button>
                        <table>
                            <thead>
                                <tr>
                                    <th>Membership Type</th>
                                    <th>Total</th>
                                    <th>New Sales</th>
                                    <th>Renewals</th>
                                    <th>Active</th>
                                    <th>Expired</th>
                                    <th>Revenue</th>
                                    <th>Avg Value</th>
                                </tr>
                            </thead>
                            <tbody>
                                ${sortedTypes.map(([type, data]) => `
                                    <tr>
                                        <td><strong>${type}</strong></td>
                                        <td>${formatNumber(data.count)}</td>
                                        <td style="color: #28a745;">${formatNumber(data.newSales || 0)}</td>
                                        <td style="color: #007bff;">${formatNumber(data.renewals || 0)}</td>
                                        <td style="color: var(--success);">${formatNumber(data.active)}</td>
                                        <td style="color: var(--danger);">${formatNumber(data.count - data.active)}</td>
                                        <td><strong>${formatCurrency(data.revenue)}</strong></td>
                                        <td>${formatCurrency(data.revenue / data.count)}</td>
                                    </tr>
                                `).join('')}
                            </tbody>
                        </table>
                    </div>
                </div>
                
                <!-- Sales Performance -->
                <div class="section">
                    <h2>Sales Performance by VSP</h2>
                    <div class="chart-grid">
                        <div class="chart-container">
                            <h3>Memberships Sold/Renewed by VSP</h3>
                            <div class="chart-wrapper">
                                <canvas id="membershipStaffCountChart"></canvas>
                            </div>
                        </div>
                        
                        <div class="chart-container">
                            <h3>Revenue by VSP</h3>
                            <div class="chart-wrapper">
                                <canvas id="membershipStaffRevenueChart"></canvas>
                            </div>
                        </div>
                    </div>
                    
                    <!-- Staff Performance Table -->
                    <div class="table-container">
                        <h3>VSP Sales Details</h3>
                        <button onclick="exportStaffSalesData()" style="float: right; padding: 8px 16px; background: var(--accent); color: white; border: none; border-radius: 5px; cursor: pointer; margin-bottom: 10px;">üì• Export to CSV</button>
                        <table>
                            <thead>
                                <tr>
                                    <th>VSP</th>
                                    <th>Total Sales</th>
                                    <th>New Sales</th>
                                    <th>Renewals</th>
                                    <th>Revenue Generated</th>
                                    <th>Avg Sale Value</th>
                                </tr>
                            </thead>
                            <tbody>
                                ${sortedStaff.map(([staff, data]) => `
                                    <tr>
                                        <td><strong>${formatStaffName(staff)}</strong></td>
                                        <td>${formatNumber(data.count)}</td>
                                        <td style="color: #28a745;">${formatNumber(data.newSales || 0)}</td>
                                        <td style="color: #007bff;">${formatNumber(data.renewals || 0)}</td>
                                        <td><strong>${formatCurrency(data.revenue)}</strong></td>
                                        <td>${formatCurrency(data.revenue / data.count)}</td>
                                    </tr>
                                `).join('')}
                            </tbody>
                        </table>
                    </div>
                </div>
                
                <!-- Active vs Expired -->
                <div class="section">
                    <h2>Membership Status Analysis</h2>
                    <div class="chart-grid">
                        <div class="chart-container">
                            <h3>Active vs Expired Memberships</h3>
                            <div class="chart-wrapper">
                                <canvas id="membershipStatusChart"></canvas>
                            </div>
                        </div>
                        
                        <div class="chart-container">
                            <h3>MRR Growth Over Time</h3>
                            <div class="chart-wrapper">
                                <canvas id="membershipMRRChart"></canvas>
                            </div>
                        </div>
                    </div>
                </div>
                
                <!-- Timeline Analysis -->
                <div class="section">
                    <h2>Timeline &amp; Trends</h2>
                    <div class="chart-grid">
                        <div class="chart-container full-width">
                            <h3>Daily New Memberships: New Sales vs Renewals</h3>
                            <div class="chart-wrapper">
                                <canvas id="membershipTimelineChart"></canvas>
                            </div>
                        </div>
                    </div>
                    
                    <!-- Membership Sales Heatmap - Full Width -->
                    <div class="section" style="margin-top: 20px;">
                        <div class="chart-container">
                            <h3>Membership Sales Heatmap</h3>
                            <p style="margin-bottom: 15px; color: #666;">Sales patterns by day and hour. Click any cell for details.</p>
                            <div id="membershipHeatmapContainer"></div>
                        </div>
                    </div>
                </div>
                
                <!-- All Members Table -->
                <div class="section">
                    <h2>üìã All Members</h2>
                    <div class="table-container">
                        <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 15px;">
                            <input type="text" id="memberSearchInput" placeholder="üîç Search by name or membership type..." 
                                   style="padding: 10px; width: 400px; border: 1px solid #ddd; border-radius: 5px; font-size: 14px;">
                            <button onclick="exportAllMembersData()" style="padding: 10px 20px; background: var(--accent); color: white; border: none; border-radius: 5px; cursor: pointer; font-weight: 600;">
                                üì• Export All Members
                            </button>
                        </div>
                        <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 10px;">
                            <div style="color: #666; font-size: 13px;">
                                Showing <strong id="memberTableCount">${formatNumber(filteredMemberships.length)}</strong> members
                                <span id="memberPaginationInfo"></span>
                            </div>
                            <div style="display: flex; gap: 15px; align-items: center;">
                                <div style="display: flex; gap: 10px; align-items: center;">
                                    <label style="font-size: 13px; color: #666;">Show:</label>
                                    <select id="memberPageSize" onchange="updateMembersPagination()" 
                                            style="padding: 5px 10px; border: 1px solid #ddd; border-radius: 5px; font-size: 13px;">
                                        <option value="25">25</option>
                                        <option value="50">50</option>
                                        <option value="100">100</option>
                                        <option value="250">250</option>
                                        <option value="all">All</option>
                                    </select>
                                </div>
                                <div id="memberPaginationControls" style="display: flex; gap: 5px;">
                                    <button onclick="changeMembersPage('first')" style="padding: 5px 10px; border: 1px solid #ddd; border-radius: 5px; background: white; cursor: pointer;">‚èÆÔ∏è</button>
                                    <button onclick="changeMembersPage('prev')" style="padding: 5px 10px; border: 1px solid #ddd; border-radius: 5px; background: white; cursor: pointer;">‚óÄÔ∏è</button>
                                    <span id="memberPageIndicator" style="padding: 5px 15px; font-size: 13px; color: #666;"></span>
                                    <button onclick="changeMembersPage('next')" style="padding: 5px 10px; border: 1px solid #ddd; border-radius: 5px; background: white; cursor: pointer;">‚ñ∂Ô∏è</button>
                                    <button onclick="changeMembersPage('last')" style="padding: 5px 10px; border: 1px solid #ddd; border-radius: 5px; background: white; cursor: pointer;">‚è≠Ô∏è</button>
                                </div>
                                <div style="display: flex; gap: 5px; align-items: center; border-left: 2px solid #ddd; padding-left: 15px;">
                                    <label style="font-size: 13px; color: #666; font-weight: 600;">Filter:</label>
                                    <button id="filterAll" onclick="filterMembersByStatus('all')" 
                                            style="padding: 5px 12px; border: 2px solid #6c757d; border-radius: 5px; background: #6c757d; color: white; cursor: pointer; font-size: 12px; font-weight: 600;">
                                        All
                                    </button>
                                    <button id="filterActive" onclick="filterMembersByStatus('active')" 
                                            style="padding: 5px 12px; border: 2px solid #28a745; border-radius: 5px; background: white; color: #28a745; cursor: pointer; font-size: 12px; font-weight: 600;">
                                        ‚úÖ Active
                                    </button>
                                    <button id="filterFrozen" onclick="filterMembersByStatus('frozen')" 
                                            style="padding: 5px 12px; border: 2px solid #2196f3; border-radius: 5px; background: white; color: #2196f3; cursor: pointer; font-size: 12px; font-weight: 600;">
                                        ‚ùÑÔ∏è Frozen
                                    </button>
                                    <button id="filterExpired" onclick="filterMembersByStatus('expired')" 
                                            style="padding: 5px 12px; border: 2px solid #dc3545; border-radius: 5px; background: white; color: #dc3545; cursor: pointer; font-size: 12px; font-weight: 600;">
                                        ‚ùå Expired
                                    </button>
                                </div>
                            </div>
                        </div>
                        <table id="allMembersTable">
                            <thead>
                                <tr>
                                    <th style="cursor: pointer;" onclick="sortMembersTable('name')">Customer Name ‚Üï</th>
                                    <th style="cursor: pointer;" onclick="sortMembersTable('membership')">Membership Type ‚Üï</th>
                                    <th style="cursor: pointer;" onclick="sortMembersTable('amount')">Amount ‚Üï</th>
                                    <th style="cursor: pointer;" onclick="sortMembersTable('purchased')">Purchased ‚Üï</th>
                                    <th style="cursor: pointer;" onclick="sortMembersTable('expiry')">Expiry ‚Üï</th>
                                    <th style="cursor: pointer;" onclick="sortMembersTable('status')">Status ‚Üï</th>
                                    <th style="cursor: pointer;" onclick="sortMembersTable('type')">Type ‚Üï</th>
                                    <th style="cursor: pointer;" onclick="sortMembersTable('vsp')">Sold By ‚Üï</th>
                                    ${showLocationColumn ? '<th>Location</th>' : ''}
                                </tr>
                            </thead>
                            <tbody id="membersTableBody">
                                ${filteredMemberships.map(m => {
                                    const purchaseDate = m['Bought Date/Time (GMT)'] ? convertGMTtoLocal(m['Bought Date/Time (GMT)']) : null;
                                    const expiryDate = m['Remaining/ Expiry/ Renewal'] ? new Date(m['Remaining/ Expiry/ Renewal']) : null;
                                    const isExpired = m.Expired === 'Yes' || (expiryDate && expiryDate < now);
                                    const isFrozen = m.Frozen === 'Yes';
                                    const isNewSale = m._isNewSale;
                                    const isRenewal = m._isRenewal;
                                    const email = (m['Customer Email'] || '').toLowerCase().trim();
                                    
                                    // Check if member has booked any appointments
                                    const hasBookedSession = email && appointmentsData.some(appt => {
                                        const apptEmail = (appt['Customer Email'] || '').toLowerCase().trim();
                                        return apptEmail === email;
                                    });
                                    
                                    // Get location and abbreviate - use customer home location mapping
                                    let location = window.customerHomeLocation[email] || m['Location'] || m['Home location'] || '';
                                    if (location === 'Eden Prairie') {
                                        location = 'EP';
                                    } else if (location === 'Savage') {
                                        location = 'SVG';
                                    } else if (!location) {
                                        location = 'N/A';
                                    }
                                    
                                    // Get the credited VSP (original seller for renewals)
                                    let creditedVSP = m['Sold by'] || '';
                                    if (email && window.customerFirstVSP[email]) {
                                        creditedVSP = window.customerFirstVSP[email].vsp || creditedVSP;
                                    }
                                    if (!creditedVSP) {
                                        creditedVSP = 'Direct/Online';
                                    }
                                    
                                    // Format VSP name using the existing formatStaffName function
                                    creditedVSP = formatStaffName(creditedVSP);
                                    
                                    // Determine status - no more "Unused", just Active/Frozen/Expired
                                    let statusBadge = '';
                                    let statusColor = '';
                                    let statusKey = '';
                                    
                                    if (isFrozen) {
                                        statusBadge = '‚ùÑÔ∏è Frozen';
                                        statusColor = '#2196f3';
                                        statusKey = 'frozen';
                                    } else if (isExpired) {
                                        statusBadge = '‚ùå Expired';
                                        statusColor = '#dc3545';
                                        statusKey = 'expired';
                                    } else {
                                        statusBadge = '‚úÖ Active';
                                        statusColor = '#28a745';
                                        statusKey = 'active';
                                    }
                                    
                                    // Type badge - just icons
                                    let typeBadge = '';
                                    let typeColor = '';
                                    if (isNewSale) {
                                        typeBadge = 'üÜï';
                                        typeColor = '#28a745';
                                    } else if (isRenewal) {
                                        typeBadge = 'üîÑ';
                                        typeColor = '#007bff';
                                    } else {
                                        typeBadge = '‚ùì';
                                        typeColor = '#6c757d';
                                    }
                                    
                                    return `
                                        <tr data-name="${(m['First Name'] + ' ' + m['Last Name']).toLowerCase()}" 
                                            data-membership="${(m['Membership Name'] || '').toLowerCase()}"
                                            data-status="${statusKey}">
                                            <td><strong>${m['First Name']} ${m['Last Name']}</strong></td>
                                            <td><strong>${m['Membership Name'] || 'Unknown'}</strong></td>
                                            <td><strong>${formatCurrency(parseFloat(m['Paid Amount']) || 0)}</strong></td>
                                            <td>${purchaseDate ? purchaseDate.toLocaleDateString() : 'N/A'}</td>
                                            <td>${expiryDate ? expiryDate.toLocaleDateString() : 'N/A'}</td>
                                            <td><span style="color: ${statusColor}; font-weight: 600;">${statusBadge}</span></td>
                                            <td><span style="font-size: 1.2em;">${typeBadge}</span></td>
                                            <td>${creditedVSP}</td>
                                            ${showLocationColumn ? `<td>${location}</td>` : ''}
                                        </tr>
                                    `;
                                }).join('')}
                            </tbody>
                        </table>
                    </div>
                </div>
            `;
            
            document.getElementById('memberships').innerHTML = html;
            
            // Pagination state for members table
            let membersCurrentPage = 1;
            let membersPageSize = 25;
            let membersFilteredRows = [];
            let membersCurrentStatusFilter = 'all';
            let membersCurrentSearchTerm = '';
            
            // Filter members by status
            window.filterMembersByStatus = function(status) {
                membersCurrentStatusFilter = status;
                
                // Update button styles
                const buttons = ['filterAll', 'filterActive', 'filterFrozen', 'filterExpired'];
                buttons.forEach(btnId => {
                    const btn = document.getElementById(btnId);
                    if (btnId === 'filter' + status.charAt(0).toUpperCase() + status.slice(1) || 
                        (status === 'all' && btnId === 'filterAll')) {
                        // Active button
                        if (btnId === 'filterAll') {
                            btn.style.background = '#6c757d';
                            btn.style.color = 'white';
                        } else if (btnId === 'filterActive') {
                            btn.style.background = '#28a745';
                            btn.style.color = 'white';
                        } else if (btnId === 'filterFrozen') {
                            btn.style.background = '#2196f3';
                            btn.style.color = 'white';
                        } else if (btnId === 'filterExpired') {
                            btn.style.background = '#dc3545';
                            btn.style.color = 'white';
                        }
                    } else {
                        // Inactive button
                        btn.style.background = 'white';
                        if (btnId === 'filterAll') {
                            btn.style.color = '#6c757d';
                        } else if (btnId === 'filterActive') {
                            btn.style.color = '#28a745';
                        } else if (btnId === 'filterFrozen') {
                            btn.style.color = '#2196f3';
                        } else if (btnId === 'filterExpired') {
                            btn.style.color = '#dc3545';
                        }
                    }
                });
                
                // Apply filters
                applyMembersFilters();
            }
            
            // Apply both search and status filters
            function applyMembersFilters() {
                const allRows = document.querySelectorAll('#membersTableBody tr');
                membersFilteredRows = [];
                
                allRows.forEach(row => {
                    const name = row.getAttribute('data-name');
                    const membership = row.getAttribute('data-membership');
                    const rowStatus = row.getAttribute('data-status');
                    
                    // Check search filter
                    const matchesSearch = !membersCurrentSearchTerm || 
                                         name.includes(membersCurrentSearchTerm) || 
                                         membership.includes(membersCurrentSearchTerm);
                    
                    // Check status filter
                    const matchesStatus = membersCurrentStatusFilter === 'all' || 
                                         rowStatus === membersCurrentStatusFilter;
                    
                    if (matchesSearch && matchesStatus) {
                        membersFilteredRows.push(row);
                    }
                });
                
                membersCurrentPage = 1; // Reset to first page on filter change
                displayMembersPage();
            }
            
            // Initialize members table
            function initializeMembersTable() {
                const allRows = document.querySelectorAll('#membersTableBody tr');
                membersFilteredRows = Array.from(allRows);
                membersCurrentPage = 1;
                displayMembersPage();
            }
            
            // Update pagination display
            window.updateMembersPagination = function() {
                const pageSize = document.getElementById('memberPageSize').value;
                membersPageSize = pageSize === 'all' ? membersFilteredRows.length : parseInt(pageSize);
                membersCurrentPage = 1; // Reset to first page when changing page size
                displayMembersPage();
            }
            
            // Display current page
            function displayMembersPage() {
                const totalRows = membersFilteredRows.length;
                const totalPages = Math.ceil(totalRows / membersPageSize);
                
                // Hide ALL rows first
                const allRows = document.querySelectorAll('#membersTableBody tr');
                allRows.forEach(row => row.style.display = 'none');
                
                // Calculate range for current page
                const startIdx = (membersCurrentPage - 1) * membersPageSize;
                const endIdx = Math.min(startIdx + membersPageSize, totalRows);
                
                // Show only the filtered rows for current page
                for (let i = startIdx; i < endIdx; i++) {
                    membersFilteredRows[i].style.display = '';
                }
                
                // Update pagination info
                if (membersPageSize >= totalRows) {
                    document.getElementById('memberPaginationInfo').textContent = '';
                    document.getElementById('memberPageIndicator').textContent = '';
                    document.getElementById('memberPaginationControls').style.display = 'none';
                } else {
                    document.getElementById('memberPaginationInfo').textContent = ` (showing ${startIdx + 1}-${endIdx})`;
                    document.getElementById('memberPageIndicator').textContent = `Page ${membersCurrentPage} of ${totalPages}`;
                    document.getElementById('memberPaginationControls').style.display = 'flex';
                }
                
                // Update visible count
                document.getElementById('memberTableCount').textContent = formatNumber(totalRows);
            }
            
            // Change page
            window.changeMembersPage = function(direction) {
                const totalPages = Math.ceil(membersFilteredRows.length / membersPageSize);
                
                switch(direction) {
                    case 'first':
                        membersCurrentPage = 1;
                        break;
                    case 'prev':
                        membersCurrentPage = Math.max(1, membersCurrentPage - 1);
                        break;
                    case 'next':
                        membersCurrentPage = Math.min(totalPages, membersCurrentPage + 1);
                        break;
                    case 'last':
                        membersCurrentPage = totalPages;
                        break;
                }
                
                displayMembersPage();
            }
            
            // Add search functionality for members table
            document.getElementById('memberSearchInput').addEventListener('input', function(e) {
                membersCurrentSearchTerm = e.target.value.toLowerCase();
                applyMembersFilters();
            });
            
            // Initialize the table
            initializeMembersTable();
            
            // Render charts
            setTimeout(() => {
                // Daily Active Members Chart
                const dailyActiveMembersCanvas = document.getElementById('dailyActiveMembersChart');
                if (dailyActiveMembersCanvas) {
                    destroyChart('dailyActiveMembers');
                    const ctx = dailyActiveMembersCanvas.getContext('2d');
                    
                    const activeDates = Object.keys(dailyActiveMembers).sort();
                    const activeCounts = activeDates.map(date => dailyActiveMembers[date]);
                    const frozenCounts = activeDates.map(date => dailyFrozenMembers[date] || 0);
                    const currentlyFrozenCounts = activeDates.map(date => window.dailyCurrentlyFrozen?.[date] || 0);
                    const totalCounts = activeDates.map((date, i) => activeCounts[i] + currentlyFrozenCounts[i]);
                    const renewalCounts = activeDates.map(date => dailyRenewals[date] || 0);
                    const cancellationCounts = activeDates.map(date => dailyCancellations[date] || 0);
                    
                    const datasets = [
                        {
                            label: 'Active Members',
                            data: activeCounts,
                            borderColor: '#28a745',
                            backgroundColor: 'rgba(40, 167, 69, 0.1)',
                            fill: true,
                            tension: 0.4,
                            borderWidth: 2,
                            pointRadius: 1,
                            pointHoverRadius: 5,
                            yAxisID: 'y'
                        }
                    ];
                    
                    // Only add frozen members line if we have frozen data
                    if (window.frozenMembershipsData && window.frozenMembershipsData.length > 0) {
                        datasets.push({
                            label: 'Cumulative Frozen',
                            data: frozenCounts,
                            borderColor: '#2196f3',
                            backgroundColor: 'rgba(33, 150, 243, 0.1)',
                            fill: true,
                            tension: 0.4,
                            borderWidth: 2,
                            pointRadius: 1,
                            pointHoverRadius: 5,
                            borderDash: [5, 5],
                            yAxisID: 'y'
                        });
                        
                        datasets.push({
                            label: 'Total Members (Active + Frozen)',
                            data: totalCounts,
                            borderColor: '#6c757d',
                            backgroundColor: 'rgba(108, 117, 125, 0.05)',
                            fill: false,
                            tension: 0.4,
                            borderWidth: 1,
                            pointRadius: 1,
                            pointHoverRadius: 5,
                            borderDash: [2, 2],
                            yAxisID: 'y'
                        });
                    }
                    
                    // Add renewals as a bar chart overlay
                    datasets.push({
                        label: 'Daily Renewals',
                        data: renewalCounts,
                        type: 'bar',
                        backgroundColor: 'rgba(255, 193, 7, 0.5)',
                        borderColor: '#ffc107',
                        borderWidth: 1,
                        yAxisID: 'y1'
                    });
                    
                    // Add cancellations as a bar chart overlay
                    if (membershipCancellationsData && membershipCancellationsData.length > 0) {
                        datasets.push({
                            label: 'Daily Cancellations',
                            data: cancellationCounts,
                            type: 'bar',
                            backgroundColor: 'rgba(220, 53, 69, 0.5)',
                            borderColor: '#dc3545',
                            borderWidth: 1,
                            yAxisID: 'y1'
                        });
                    }
                    
                    allCharts.dailyActiveMembers = new Chart(ctx, {
                        type: 'line',
                        data: {
                            labels: activeDates.map(date => new Date(date).toLocaleDateString()),
                            datasets: datasets
                        },
                        options: {
                            responsive: true,
                            maintainAspectRatio: false,
                            interaction: {
                                mode: 'index',
                                intersect: false
                            },
                            plugins: {
                                legend: {
                                    display: true,
                                    position: 'top'
                                },
                                tooltip: {
                                    callbacks: {
                                        label: function(context) {
                                            let label = context.dataset.label || '';
                                            if (label) {
                                                label += ': ';
                                            }
                                            // Just show the number without adding "members" or "renewals"
                                            label += formatNumber(context.parsed.y);
                                            return label;
                                        }
                                    }
                                }
                            },
                            scales: {
                                y: {
                                    type: 'linear',
                                    display: true,
                                    position: 'left',
                                    beginAtZero: true,
                                    ticks: {
                                        callback: function(value) {
                                            return formatNumber(value);
                                        }
                                    },
                                    title: {
                                        display: true,
                                        text: 'Members'
                                    }
                                },
                                y1: {
                                    type: 'linear',
                                    display: true,
                                    position: 'right',
                                    beginAtZero: true,
                                    ticks: {
                                        callback: function(value) {
                                            return formatNumber(value);
                                        }
                                    },
                                    title: {
                                        display: true,
                                        text: 'Daily Renewals'
                                    },
                                    grid: {
                                        drawOnChartArea: false
                                    }
                                },
                                x: {
                                    ticks: {
                                        maxTicksLimit: 15,
                                        maxRotation: 45,
                                        minRotation: 45
                                    },
                                    title: {
                                        display: true,
                                        text: 'Date'
                                    }
                                }
                            }
                        }
                    });
                }



                // Sales Mix Chart - REMOVED
                // Revenue Mix Chart - REMOVED
                // Cumulative Revenue Chart - REMOVED
                // Monthly Revenue Chart - REMOVED
                
                // Membership type count chart
                const typeCountCanvas = document.getElementById('membershipTypeCountChart');
                if (typeCountCanvas) {

                    destroyChart('membershipTypeCount');
                    const ctx = typeCountCanvas.getContext('2d');
                    allCharts.membershipTypeCount = new Chart(ctx, {
                        type: 'doughnut',
                        data: {
                            labels: sortedTypes.map(([type]) => type),
                            datasets: [{
                                data: sortedTypes.map(([, data]) => data.count),
                                backgroundColor: [
                                    '#007bff', '#28a745', '#ffc107', '#dc3545', '#6c757d',
                                    '#17a2b8', '#fd7e14', '#6610f2', '#e83e8c', '#20c997'
                                ]
                            }]
                        },
                        options: {
                            responsive: true,
                            maintainAspectRatio: false,
                            onClick: (event, elements) => {
                                if (elements.length > 0) {
                                    const index = elements[0].index;
                                    const [typeName, typeData] = sortedTypes[index];
                                    const typeMembers = filteredMemberships.filter(m => m['Membership Name'] === typeName);
                                    
                                    let modalContent = `
                                        <h4>${typeName}</h4>
                                        <p><strong>Total:</strong> ${typeData.count} memberships | <strong>Revenue:</strong> ${formatCurrency(typeData.revenue)}</p>
                                        <p><strong>Active:</strong> ${typeData.active} | <strong>Expired:</strong> ${typeData.count - typeData.active}</p>
                                        <p><strong>Average Value:</strong> ${formatCurrency(typeData.revenue / typeData.count)}</p>
                                        <hr>
                                        <h5>Recent Members:</h5>
                                        <table style="width: 100%; font-size: 0.9em;">
                                            <thead>
                                                <tr>
                                                    <th>Customer</th>
                                                    <th>Purchased</th>
                                                    <th>Amount</th>
                                                    <th>Status</th>
                                                </tr>
                                            </thead>
                                            <tbody>
                                                ${typeMembers.slice(0, 10).map(m => `
                                                    <tr>
                                                        <td>${m['First Name']} ${m['Last Name']}</td>
                                                        <td>${convertGMTtoLocal(m['Bought Date/Time (GMT)']).toLocaleDateString()}</td>
                                                        <td>${formatCurrency(parseFloat(m['Paid Amount']))}</td>
                                                        <td style="color: ${m.Expired === 'Yes' ? '#dc3545' : '#28a745'}">${m.Expired === 'Yes' ? 'Expired' : 'Active'}</td>
                                                    </tr>
                                                `).join('')}
                                            </tbody>
                                        </table>
                                    `;
                                    
                                    // Prepare export data
                                    const exportData = typeMembers.map(m => ({
                                        'Customer Name': `${m['First Name']} ${m['Last Name']}`,
                                        'Email': m['Customer Email'],
                                        'Membership Type': m['Membership Name'],
                                        'Purchase Date': convertGMTtoLocal(m['Bought Date/Time (GMT)']).toLocaleDateString(),
                                        'Amount Paid': parseFloat(m['Paid Amount']).toFixed(2),
                                        'Status': m.Expired === 'Yes' ? 'Expired' : 'Active',
                                        'Type': m._isNewSale ? 'New Sale' : (m._isRenewal ? 'Renewal' : 'Unknown')
                                    }));
                                    
                                    showModal(`Membership Type: ${typeName}`, modalContent, exportData);
                                }
                            },
                            plugins: {
                                legend: {
                                    position: 'right'
                                }
                            }
                        }
                    });

                } else {
                    console.error('membershipTypeCountChart canvas not found!');
                }
                
                // Membership type revenue chart (DOUGHNUT with drilldown)
                const typeRevenueCanvas = document.getElementById('membershipTypeRevenueChart');
                if (typeRevenueCanvas) {

                    destroyChart('membershipTypeRevenue');
                    const ctx = typeRevenueCanvas.getContext('2d');
                    allCharts.membershipTypeRevenue = new Chart(ctx, {
                        type: 'doughnut',
                        data: {
                            labels: sortedTypes.map(([type]) => type),
                            datasets: [{
                                data: sortedTypes.map(([, data]) => data.revenue),
                                backgroundColor: [
                                    '#007bff', '#28a745', '#ffc107', '#dc3545', '#6c757d',
                                    '#17a2b8', '#fd7e14', '#6610f2', '#e83e8c', '#20c997'
                                ]
                            }]
                        },
                        options: {
                            responsive: true,
                            maintainAspectRatio: false,
                            onClick: (event, elements) => {
                                if (elements.length > 0) {
                                    const index = elements[0].index;
                                    const [typeName, typeData] = sortedTypes[index];
                                    const typeMembers = filteredMemberships.filter(m => m['Membership Name'] === typeName);
                                    
                                    let modalContent = `
                                        <h4>${typeName}</h4>
                                        <p><strong>Total:</strong> ${typeData.count} memberships | <strong>Revenue:</strong> ${formatCurrency(typeData.revenue)}</p>
                                        <p><strong>Active:</strong> ${typeData.active} | <strong>Expired:</strong> ${typeData.count - typeData.active}</p>
                                        <p><strong>Average Value:</strong> ${formatCurrency(typeData.revenue / typeData.count)}</p>
                                        <hr>
                                        <h5>Recent Members:</h5>
                                        <table style="width: 100%; font-size: 0.9em;">
                                            <thead>
                                                <tr>
                                                    <th>Customer</th>
                                                    <th>Purchased</th>
                                                    <th>Amount</th>
                                                    <th>Status</th>
                                                </tr>
                                            </thead>
                                            <tbody>
                                                ${typeMembers.slice(0, 10).map(m => `
                                                    <tr>
                                                        <td>${m['First Name']} ${m['Last Name']}</td>
                                                        <td>${convertGMTtoLocal(m['Bought Date/Time (GMT)']).toLocaleDateString()}</td>
                                                        <td>${formatCurrency(parseFloat(m['Paid Amount']))}</td>
                                                        <td style="color: ${m.Expired === 'Yes' ? '#dc3545' : '#28a745'}">${m.Expired === 'Yes' ? 'Expired' : 'Active'}</td>
                                                    </tr>
                                                `).join('')}
                                            </tbody>
                                        </table>
                                    `;
                                    
                                    // Prepare export data
                                    const exportData = typeMembers.map(m => ({
                                        'Customer Name': `${m['First Name']} ${m['Last Name']}`,
                                        'Email': m['Customer Email'],
                                        'Membership Type': m['Membership Name'],
                                        'Purchase Date': convertGMTtoLocal(m['Bought Date/Time (GMT)']).toLocaleDateString(),
                                        'Amount Paid': parseFloat(m['Paid Amount']).toFixed(2),
                                        'Status': m.Expired === 'Yes' ? 'Expired' : 'Active',
                                        'Type': m._isNewSale ? 'New Sale' : (m._isRenewal ? 'Renewal' : 'Unknown')
                                    }));
                                    
                                    showModal(`Membership Type Revenue: ${typeName}`, modalContent, exportData);
                                }
                            },
                            plugins: {
                                legend: {
                                    position: 'right'
                                },
                                tooltip: {
                                    callbacks: {
                                        label: function(context) {
                                            return context.label + ': ' + formatCurrency(context.parsed);
                                        }
                                    }
                                }
                            }
                        }
                    });
                }
                
                // Staff count chart
                const staffCountCanvas = document.getElementById('membershipStaffCountChart');
                if (staffCountCanvas) {
                    destroyChart('membershipStaffCount');
                    const ctx = staffCountCanvas.getContext('2d');
                    allCharts.membershipStaffCount = new Chart(ctx, {
                        type: 'bar',
                        data: {
                            labels: sortedStaff.map(([staff]) => formatStaffName(staff)),
                            datasets: [{
                                label: 'Memberships Sold',
                                data: sortedStaff.map(([, data]) => data.count),
                                backgroundColor: '#9c27b0',
                                borderColor: '#7b1fa2',
                                borderWidth: 1
                            }]
                        },
                        options: {
                            responsive: true,
                            maintainAspectRatio: false,
                            indexAxis: 'y',
                            onClick: (event, elements) => {
                                if (elements.length > 0) {
                                    const index = elements[0].index;
                                    const [staffName, staffData] = sortedStaff[index];
                                    const staffMembers = filteredMemberships.filter(m => {
                                        const email = (m['Customer Email'] || '').toLowerCase().trim();
                                        if (email && window.customerFirstVSP[email]) {
                                            return window.customerFirstVSP[email].vsp === staffName;
                                        }
                                        return (m['Sold by'] || 'Direct/Online') === staffName;
                                    });
                                    
                                    let modalContent = `
                                        <h4>Sales Performance: ${formatStaffName(staffName)}</h4>
                                        <p><strong>Memberships Sold:</strong> ${staffData.count}</p>
                                        <p><strong>New Sales:</strong> ${staffData.newSales || 0} | <strong>Renewals:</strong> ${staffData.renewals || 0}</p>
                                        <p><strong>Revenue Generated:</strong> ${formatCurrency(staffData.revenue)}</p>
                                        <p><strong>Average Sale:</strong> ${formatCurrency(staffData.revenue / staffData.count)}</p>
                                        <hr>
                                        <h5>Recent Sales:</h5>
                                        <table style="width: 100%; font-size: 0.9em;">
                                            <thead>
                                                <tr>
                                                    <th>Customer</th>
                                                    <th>Membership</th>
                                                    <th>Date</th>
                                                    <th>Amount</th>
                                                    <th>Type</th>
                                                </tr>
                                            </thead>
                                            <tbody>
                                                ${staffMembers.slice(0, 15).map(m => `
                                                    <tr>
                                                        <td>${m['First Name']} ${m['Last Name']}</td>
                                                        <td>${m['Membership Name']}</td>
                                                        <td>${convertGMTtoLocal(m['Bought Date/Time (GMT)']).toLocaleDateString()}</td>
                                                        <td>${formatCurrency(parseFloat(m['Paid Amount']))}</td>
                                                        <td><span style="padding: 4px 8px; border-radius: 4px; background: ${m._isNewSale ? '#d4edda' : '#cfe2ff'}; color: ${m._isNewSale ? '#155724' : '#084298'};">${m._isNewSale ? 'New Sale' : (m._isRenewal ? 'Renewal' : 'Unknown')}</span></td>
                                                    </tr>
                                                `).join('')}
                                            </tbody>
                                        </table>
                                    `;
                                    
                                    // Prepare export data
                                    const exportData = staffMembers.map(m => ({
                                        'Staff Member': staffName,
                                        'Customer Name': `${m['First Name']} ${m['Last Name']}`,
                                        'Email': m['Customer Email'],
                                        'Membership Type': m['Membership Name'],
                                        'Purchase Date': convertGMTtoLocal(m['Bought Date/Time (GMT)']).toLocaleDateString(),
                                        'Amount Paid': parseFloat(m['Paid Amount']).toFixed(2),
                                        'Sale Type': m._isNewSale ? 'New Sale' : (m._isRenewal ? 'Renewal' : 'Unknown')
                                    }));
                                    
                                    showModal(`Staff Member: ${staffName}`, modalContent, exportData);
                                }
                            },
                            plugins: { legend: { display: false } },
                            scales: {
                                x: {
                                    beginAtZero: true,
                                    ticks: { stepSize: 1 }
                                }
                            }
                        }
                    });
                }
                
                // Staff revenue chart
                const staffRevenueCanvas = document.getElementById('membershipStaffRevenueChart');
                if (staffRevenueCanvas) {
                    destroyChart('membershipStaffRevenue');
                    const ctx = staffRevenueCanvas.getContext('2d');
                    allCharts.membershipStaffRevenue = new Chart(ctx, {
                        type: 'bar',
                        data: {
                            labels: sortedStaff.map(([staff]) => formatStaffName(staff)),
                            datasets: [{
                                label: 'Revenue',
                                data: sortedStaff.map(([, data]) => data.revenue),
                                backgroundColor: '#ff6384',
                                borderColor: '#ff3860',
                                borderWidth: 1
                            }]
                        },
                        options: {
                            responsive: true,
                            maintainAspectRatio: false,
                            indexAxis: 'y',
                            onClick: (event, elements) => {
                                if (elements.length > 0) {
                                    const index = elements[0].index;
                                    const [staffName, staffData] = sortedStaff[index];
                                    const staffMembers = filteredMemberships.filter(m => {
                                        const email = (m['Customer Email'] || '').toLowerCase().trim();
                                        if (email && window.customerFirstVSP[email]) {
                                            return window.customerFirstVSP[email].vsp === staffName;
                                        }
                                        return (m['Sold by'] || 'Direct/Online') === staffName;
                                    });
                                    
                                    let modalContent = `
                                        <h4>Revenue Performance: ${formatStaffName(staffName)}</h4>
                                        <p><strong>Total Revenue:</strong> ${formatCurrency(staffData.revenue)}</p>
                                        <p><strong>Memberships Sold:</strong> ${staffData.count}</p>
                                        <p><strong>New Sales:</strong> ${staffData.newSales || 0} | <strong>Renewals:</strong> ${staffData.renewals || 0}</p>
                                        <p><strong>Average Sale:</strong> ${formatCurrency(staffData.revenue / staffData.count)}</p>
                                        <hr>
                                        <h5>Top Sales:</h5>
                                        <table style="width: 100%; font-size: 0.9em;">
                                            <thead>
                                                <tr>
                                                    <th>Customer</th>
                                                    <th>Membership</th>
                                                    <th>Date</th>
                                                    <th>Amount</th>
                                                    <th>Type</th>
                                                </tr>
                                            </thead>
                                            <tbody>
                                                ${staffMembers.sort((a, b) => parseFloat(b['Paid Amount']) - parseFloat(a['Paid Amount'])).slice(0, 15).map(m => `
                                                    <tr>
                                                        <td>${m['First Name']} ${m['Last Name']}</td>
                                                        <td>${m['Membership Name']}</td>
                                                        <td>${convertGMTtoLocal(m['Bought Date/Time (GMT)']).toLocaleDateString()}</td>
                                                        <td><strong>${formatCurrency(parseFloat(m['Paid Amount']))}</strong></td>
                                                        <td><span style="padding: 4px 8px; border-radius: 4px; background: ${m._isNewSale ? '#d4edda' : '#cfe2ff'}; color: ${m._isNewSale ? '#155724' : '#084298'};">${m._isNewSale ? 'New Sale' : (m._isRenewal ? 'Renewal' : 'Unknown')}</span></td>
                                                    </tr>
                                                `).join('')}
                                            </tbody>
                                        </table>
                                    `;
                                    
                                    // Prepare export data (sorted by amount)
                                    const sortedStaffMembers = staffMembers.sort((a, b) => parseFloat(b['Paid Amount']) - parseFloat(a['Paid Amount']));
                                    const exportData = sortedStaffMembers.map(m => ({
                                        'Staff Member': staffName,
                                        'Customer Name': `${m['First Name']} ${m['Last Name']}`,
                                        'Email': m['Customer Email'],
                                        'Membership Type': m['Membership Name'],
                                        'Purchase Date': convertGMTtoLocal(m['Bought Date/Time (GMT)']).toLocaleDateString(),
                                        'Amount Paid': parseFloat(m['Paid Amount']).toFixed(2),
                                        'Sale Type': m._isNewSale ? 'New Sale' : (m._isRenewal ? 'Renewal' : 'Unknown')
                                    }));
                                    
                                    showModal(`Staff Member: ${staffName}`, modalContent, exportData);
                                }
                            },
                            plugins: { legend: { display: false } },
                            scales: {
                                x: {
                                    beginAtZero: true,
                                    ticks: {
                                        callback: function(value) {
                                            return formatCurrency(value);
                                        }
                                    }
                                }
                            }
                        }
                    });
                }
                
                // Status chart
                const statusCanvas = document.getElementById('membershipStatusChart');
                if (statusCanvas) {
                    destroyChart('membershipStatus');
                    const ctx = statusCanvas.getContext('2d');
                    allCharts.membershipStatus = new Chart(ctx, {
                        type: 'doughnut',
                        data: {
                            labels: ['Active', 'Expired'],
                            datasets: [{
                                data: [activeMemberships.length, expiredMemberships.length],
                                backgroundColor: ['#28a745', '#dc3545']
                            }]
                        },
                        options: {
                            responsive: true,
                            maintainAspectRatio: false,
                            onClick: (event, elements) => {
                                if (elements.length > 0) {
                                    const index = elements[0].index;
                                    const isActive = index === 0;
                                    const statusMembers = isActive ? activeMemberships : expiredMemberships;
                                    const status = isActive ? 'Active' : 'Expired';
                                    
                                    let modalContent = `
                                        <h4>${status} Memberships</h4>
                                        <p><strong>Count:</strong> ${statusMembers.length}</p>
                                        <p><strong>Total Revenue:</strong> ${formatCurrency(statusMembers.reduce((sum, m) => sum + parseFloat(m['Paid Amount'] || 0), 0))}</p>
                                        <hr>
                                        <h5>Recent ${status} Memberships:</h5>
                                        <table style="width: 100%; font-size: 0.9em;">
                                            <thead>
                                                <tr>
                                                    <th>Customer</th>
                                                    <th>Type</th>
                                                    <th>Purchased</th>
                                                    <th>Amount</th>
                                                    ${!isActive ? '<th>Expired</th>' : ''}
                                                </tr>
                                            </thead>
                                            <tbody>
                                                ${statusMembers.slice(0, 15).map(m => `
                                                    <tr>
                                                        <td>${m['First Name']} ${m['Last Name']}</td>
                                                        <td>${m['Membership Name']}</td>
                                                        <td>${convertGMTtoLocal(m['Bought Date/Time (GMT)']).toLocaleDateString()}</td>
                                                        <td>${formatCurrency(parseFloat(m['Paid Amount']))}</td>
                                                        ${!isActive ? `<td>${m['Remaining/ Expiry/ Renewal'] ? new Date(m['Remaining/ Expiry/ Renewal']).toLocaleDateString() : 'N/A'}</td>` : ''}
                                                    </tr>
                                                `).join('')}
                                            </tbody>
                                        </table>
                                    `;
                                    
                                    // Prepare export data
                                    const exportData = statusMembers.map(m => ({
                                        'Status': status,
                                        'Customer Name': `${m['First Name']} ${m['Last Name']}`,
                                        'Email': m['Customer Email'],
                                        'Membership Type': m['Membership Name'],
                                        'Purchase Date': convertGMTtoLocal(m['Bought Date/Time (GMT)']).toLocaleDateString(),
                                        'Amount Paid': parseFloat(m['Paid Amount']).toFixed(2),
                                        'Expiry Date': m['Remaining/ Expiry/ Renewal'] ? new Date(m['Remaining/ Expiry/ Renewal']).toLocaleDateString() : 'N/A',
                                        'Sale Type': m._isNewSale ? 'New Sale' : (m._isRenewal ? 'Renewal' : 'Unknown'),
                                        'Frozen': m.Frozen || 'No',
                                        'Refunded': parseFloat(m.Refunded) > 0 ? 'Yes' : 'No'
                                    }));
                                    
                                    showModal(`${status} Memberships`, modalContent, exportData);
                                }
                            },
                            plugins: {
                                legend: {
                                    position: 'bottom'
                                }
                            }
                        }
                    });
                }
                
                // MRR Growth Chart
                const mrrCanvas = document.getElementById('membershipMRRChart');
                if (mrrCanvas) {
                    destroyChart('membershipMRR');
                    const ctx = mrrCanvas.getContext('2d');
                    
                    // Calculate MRR by month
                    const monthlyMRR = {};
                    sortedMonths.forEach(month => {
                        const monthStart = new Date(month + '-01');
                        const monthEnd = new Date(monthStart.getFullYear(), monthStart.getMonth() + 1, 0);
                        
                        let mrrValue = 0;
                        membershipsData.forEach(m => {
                            if (m['Membership Type'] === 'subscription') {
                                const boughtDate = m['Bought Date/Time (GMT)'] ? convertGMTtoLocal(m['Bought Date/Time (GMT)']) : null;
                                const expiryDate = m['Remaining/ Expiry/ Renewal'] ? new Date(m['Remaining/ Expiry/ Renewal']) : null;
                                const isExpired = m.Expired === 'Yes';
                                
                                // If subscription was active during this month
                                if (boughtDate && boughtDate <= monthEnd && (!isExpired || (expiryDate && expiryDate >= monthStart))) {
                                    mrrValue += parseFloat(m['Paid Amount']) || 0;
                                }
                            }
                        });
                        monthlyMRR[month] = mrrValue;
                    });
                    
                    allCharts.membershipMRR = new Chart(ctx, {
                        type: 'line',
                        data: {
                            labels: sortedMonths.map(m => {
                                const [year, month] = m.split('-');
                                const date = new Date(year, month - 1);
                                return date.toLocaleDateString('en-US', { month: 'short', year: 'numeric' });
                            }),
                            datasets: [{
                                label: 'MRR',
                                data: sortedMonths.map(m => monthlyMRR[m]),
                                borderColor: '#9c27b0',
                                backgroundColor: 'rgba(156, 39, 176, 0.1)',
                                borderWidth: 3,
                                fill: true,
                                tension: 0.4
                            }]
                        },
                        options: {
                            responsive: true,
                            maintainAspectRatio: false,
                            plugins: { legend: { display: false } },
                            scales: {
                                y: {
                                    beginAtZero: true,
                                    ticks: {
                                        callback: function(value) {
                                            return formatCurrency(value);
                                        }
                                    }
                                }
                            }
                        }
                    });
                }
                
                // Timeline chart (daily new memberships - split by new vs renewal)
                const dailyNewSales = {};
                // dailyRenewals already declared at top of function - reuse it
                filteredMemberships.forEach(m => {
                    const boughtDate = m['Bought Date/Time (GMT)'] ? convertGMTtoLocal(m['Bought Date/Time (GMT)']) : null;
                    if (boughtDate) {
                        const dateKey = boughtDate.toISOString().split('T')[0];
                        if (m._isNewSale) {
                            dailyNewSales[dateKey] = (dailyNewSales[dateKey] || 0) + 1;
                        } else if (m._isRenewal) {
                            dailyRenewals[dateKey] = (dailyRenewals[dateKey] || 0) + 1;
                        }
                    }
                });
                const sortedDailyDates = [...new Set([...Object.keys(dailyNewSales), ...Object.keys(dailyRenewals)])].sort();
                
                const timelineCanvas = document.getElementById('membershipTimelineChart');
                if (timelineCanvas) {
                    destroyChart('membershipTimeline');
                    const ctx = timelineCanvas.getContext('2d');
                    allCharts.membershipTimeline = new Chart(ctx, {
                        type: 'bar',
                        data: {
                            labels: sortedDailyDates,
                            datasets: [
                                {
                                    label: 'New Sales',
                                    data: sortedDailyDates.map(d => dailyNewSales[d] || 0),
                                    backgroundColor: '#28a745',
                                    borderColor: '#218838',
                                    borderWidth: 1
                                },
                                {
                                    label: 'Renewals',
                                    data: sortedDailyDates.map(d => dailyRenewals[d] || 0),
                                    backgroundColor: '#007bff',
                                    borderColor: '#0056b3',
                                    borderWidth: 1
                                }
                            ]
                        },
                        options: {
                            responsive: true,
                            maintainAspectRatio: false,
                            plugins: { 
                                legend: { 
                                    display: true,
                                    position: 'top'
                                } 
                            },
                            scales: {
                                x: { stacked: true },
                                y: {
                                    stacked: true,
                                    beginAtZero: true,
                                    ticks: { stepSize: 1 }
                                }
                            }
                        }
                    });
                }
                
                // Weekly Sales Trend
                const weeklyCanvas = document.getElementById('membershipWeeklyChart');
                if (weeklyCanvas) {
                    destroyChart('membershipWeekly');
                    const ctx = weeklyCanvas.getContext('2d');
                    
                    // Group by week
                    const weeklyData = {};
                    filteredMemberships.forEach(m => {
                        const boughtDate = m['Bought Date/Time (GMT)'] ? convertGMTtoLocal(m['Bought Date/Time (GMT)']) : null;
                        if (boughtDate) {
                            const year = boughtDate.getFullYear();
                            const week = Math.ceil((boughtDate - new Date(year, 0, 1)) / (7 * 24 * 60 * 60 * 1000));
                            const weekKey = `${year}-W${String(week).padStart(2, '0')}`;
                            if (!weeklyData[weekKey]) {
                                weeklyData[weekKey] = { count: 0, revenue: 0 };
                            }
                            weeklyData[weekKey].count++;
                            weeklyData[weekKey].revenue += parseFloat(m['Paid Amount']) || 0;
                        }
                    });
                    
                    const sortedWeeks = Object.keys(weeklyData).sort();
                    
                    allCharts.membershipWeekly = new Chart(ctx, {
                        type: 'line',
                        data: {
                            labels: sortedWeeks,
                            datasets: [
                                {
                                    label: 'Weekly Sales Count',
                                    data: sortedWeeks.map(w => weeklyData[w].count),
                                    borderColor: '#007bff',
                                    backgroundColor: 'rgba(0, 123, 255, 0.1)',
                                    borderWidth: 2,
                                    fill: true,
                                    tension: 0.4,
                                    yAxisID: 'y'
                                },
                                {
                                    label: 'Weekly Revenue',
                                    data: sortedWeeks.map(w => weeklyData[w].revenue),
                                    borderColor: '#28a745',
                                    backgroundColor: 'rgba(40, 167, 69, 0.1)',
                                    borderWidth: 2,
                                    fill: true,
                                    tension: 0.4,
                                    yAxisID: 'y1'
                                }
                            ]
                        },
                        options: {
                            responsive: true,
                            maintainAspectRatio: false,
                            plugins: {
                                legend: {
                                    display: true,
                                    position: 'top'
                                }
                            },
                            scales: {
                                y: {
                                    type: 'linear',
                                    display: true,
                                    position: 'left',
                                    beginAtZero: true,
                                    ticks: { stepSize: 1 }
                                },
                                y1: {
                                    type: 'linear',
                                    display: true,
                                    position: 'right',
                                    beginAtZero: true,
                                    grid: {
                                        drawOnChartArea: false
                                    },
                                    ticks: {
                                        callback: function(value) {
                                            return formatCurrency(value);
                                        }
                                    }
                                }
                            }
                        }
                    });
                }
                
                // Day of Week Chart
                // Render membership sales heatmap after setting innerHTML
                setTimeout(() => {
                    renderMembershipHeatmap();
                }, 100);
                
                // Average Sale Value Over Time
                const avgValueCanvas = document.getElementById('membershipAvgValueChart');
                if (avgValueCanvas) {
                    destroyChart('membershipAvgValue');
                    const ctx = avgValueCanvas.getContext('2d');
                    
                    // Calculate average value per month
                    const monthlyAvg = {};
                    sortedMonths.forEach(month => {
                        const monthMemberships = filteredMemberships.filter(m => {
                            const boughtDate = m['Bought Date/Time (GMT)'] ? convertGMTtoLocal(m['Bought Date/Time (GMT)']) : null;
                            if (boughtDate) {
                                const memberMonth = `${boughtDate.getFullYear()}-${String(boughtDate.getMonth() + 1).padStart(2, '0')}`;
                                return memberMonth === month;
                            }
                            return false;
                        });
                        
                        if (monthMemberships.length > 0) {
                            const totalValue = monthMemberships.reduce((sum, m) => sum + (parseFloat(m['Paid Amount']) || 0), 0);
                            monthlyAvg[month] = totalValue / monthMemberships.length;
                        } else {
                            monthlyAvg[month] = 0;
                        }
                    });
                    
                    allCharts.membershipAvgValue = new Chart(ctx, {
                        type: 'line',
                        data: {
                            labels: sortedMonths.map(m => {
                                const [year, month] = m.split('-');
                                const date = new Date(year, month - 1);
                                return date.toLocaleDateString('en-US', { month: 'short', year: 'numeric' });
                            }),
                            datasets: [{
                                label: 'Average Sale Value',
                                data: sortedMonths.map(m => monthlyAvg[m]),
                                borderColor: '#ff6384',
                                backgroundColor: 'rgba(255, 99, 132, 0.1)',
                                borderWidth: 2,
                                fill: true,
                                tension: 0.4
                            }]
                        },
                        options: {
                            responsive: true,
                            maintainAspectRatio: false,
                            plugins: { legend: { display: false } },
                            scales: {
                                y: {
                                    beginAtZero: true,
                                    ticks: {
                                        callback: function(value) {
                                            return formatCurrency(value);
                                        }
                                    }
                                }
                            }
                        }
                    });
                }
            }, 100);
            
            // Add cancellations data to memberships tab if available
            if (membershipCancellationsData && membershipCancellationsData.length > 0) {
                setTimeout(() => {
                    appendCancellationsToMemberships();
                }, 150);
            }
            
            // Add upcoming renewals to memberships tab if available
            if (membershipRenewalsData && membershipRenewalsData.length > 0) {
                setTimeout(() => {
                    appendUpcomingRenewalsToMemberships();
                }, 200);
            }
        }
        
        // Export functions for membership data
        function exportMembershipTypeData() {
            const data = [];
            Object.entries(membershipTypes).forEach(([type, stats]) => {
                data.push({
                    'Membership Type': type,
                    'Total Count': stats.count,
                    'New Sales': stats.newSales || 0,
                    'Renewals': stats.renewals || 0,
                    'Active': stats.active,
                    'Expired': stats.count - stats.active,
                    'Revenue': stats.revenue.toFixed(2),
                    'Average Value': (stats.revenue / stats.count).toFixed(2)
                });
            });
            exportToCSV(data, 'membership-types-' + new Date().toISOString().split('T')[0] + '.csv');
        }
        
        function exportStaffSalesData() {
            const data = [];
            Object.entries(salesByStaff).forEach(([staff, stats]) => {
                data.push({
                    'Staff Member': staff,
                    'Total Sales': stats.count,
                    'New Sales': stats.newSales || 0,
                    'Renewals': stats.renewals || 0,
                    'Revenue Generated': stats.revenue.toFixed(2),
                    'Average Sale Value': (stats.revenue / stats.count).toFixed(2)
                });
            });
            exportToCSV(data, 'staff-sales-' + new Date().toISOString().split('T')[0] + '.csv');
        }
        
        // Export all members data
        function exportAllMembersData() {
            const data = [];
            filteredMemberships.forEach(m => {
                const purchaseDate = m['Bought Date/Time (GMT)'] ? convertGMTtoLocal(m['Bought Date/Time (GMT)']) : null;
                const expiryDate = m['Remaining/ Expiry/ Renewal'] ? new Date(m['Remaining/ Expiry/ Renewal']) : null;
                const now = new Date();
                const isExpired = m.Expired === 'Yes' || (expiryDate && expiryDate < now);
                const isFrozen = m.Frozen === 'Yes';
                const email = (m['Customer Email'] || '').toLowerCase().trim();
                
                // Check if has booked session for Unused status
                const hasBookedSession = email && appointmentsData.some(appt => {
                    const apptEmail = (appt['Customer Email'] || '').toLowerCase().trim();
                    return apptEmail === email;
                });
                
                // Get the credited VSP (original seller for renewals) - FULL NAME for export
                let creditedVSP = m['Sold by'] || '';
                if (email && window.customerFirstVSP[email]) {
                    creditedVSP = window.customerFirstVSP[email].vsp || creditedVSP;
                }
                if (!creditedVSP) {
                    creditedVSP = 'Direct/Online';
                }
                
                // Convert email to full name using the mapping
                if (creditedVSP.includes('@')) {
                    const emailLower = creditedVSP.toLowerCase().trim();
                    if (window.vspEmailToName && window.vspEmailToName[emailLower]) {
                        creditedVSP = window.vspEmailToName[emailLower];
                    } else {
                        creditedVSP = creditedVSP.split('@')[0];
                    }
                }
                
                // Get full location name (not abbreviated) for export
                let location = window.customerHomeLocation && window.customerHomeLocation[email] 
                    ? window.customerHomeLocation[email] 
                    : (m['Location'] || m['Home location'] || 'N/A');
                
                // Determine full status
                let status;
                if (isFrozen) {
                    status = 'Frozen';
                } else if (isExpired) {
                    status = 'Expired';
                } else {
                    status = 'Active';
                }
                
                data.push({
                    'Customer Name': `${m['First Name']} ${m['Last Name']}`,
                    'Membership Type': m['Membership Name'] || 'Unknown',
                    'Amount Paid': parseFloat(m['Paid Amount']) || 0,
                    'Purchase Date': purchaseDate ? purchaseDate.toLocaleDateString() : 'N/A',
                    'Expiry Date': expiryDate ? expiryDate.toLocaleDateString() : 'N/A',
                    'Status': status,
                    'Type': m._isNewSale ? 'New Sale' : (m._isRenewal ? 'Renewal' : 'Unknown'),
                    'Credited To (VSP)': creditedVSP,
                    'Location': location,
                    'Purchase ID': m['Purchase ID'] || '',
                    'Membership Category': m['Membership Type'] || '',
                    'Notes': 'Renewals credited to original seller'
                });
            });
            exportToCSV(data, 'all-members-' + new Date().toISOString().split('T')[0] + '.csv');
        }
        
        // Sort members table
        let membersSortState = { column: null, ascending: true };
        function sortMembersTable(column) {
            const tbody = document.getElementById('membersTableBody');
            const allRows = Array.from(tbody.querySelectorAll('tr'));
            
            // Toggle sort direction if clicking same column
            if (membersSortState.column === column) {
                membersSortState.ascending = !membersSortState.ascending;
            } else {
                membersSortState.column = column;
                membersSortState.ascending = true;
            }
            
            allRows.sort((a, b) => {
                let aVal, bVal;
                
                switch(column) {
                    case 'name':
                        aVal = a.getAttribute('data-name');
                        bVal = b.getAttribute('data-name');
                        break;
                    case 'membership':
                        aVal = a.getAttribute('data-membership');
                        bVal = b.getAttribute('data-membership');
                        break;
                    case 'amount':
                        aVal = parseFloat(a.cells[2].textContent.replace(/[$,]/g, '')) || 0;
                        bVal = parseFloat(b.cells[2].textContent.replace(/[$,]/g, '')) || 0;
                        break;
                    case 'purchased':
                        aVal = new Date(a.cells[3].textContent);
                        bVal = new Date(b.cells[3].textContent);
                        break;
                    case 'expiry':
                        aVal = new Date(a.cells[4].textContent);
                        bVal = new Date(b.cells[4].textContent);
                        break;
                    case 'status':
                        aVal = a.cells[5].textContent;
                        bVal = b.cells[5].textContent;
                        break;
                    case 'type':
                        aVal = a.cells[6].textContent;
                        bVal = b.cells[6].textContent;
                        break;
                    case 'vsp':
                        aVal = a.cells[7].textContent;
                        bVal = b.cells[7].textContent;
                        break;
                    default:
                        return 0;
                }
                
                if (aVal < bVal) return membersSortState.ascending ? -1 : 1;
                if (aVal > bVal) return membersSortState.ascending ? 1 : -1;
                return 0;
            });
            
            // Clear and re-append sorted rows
            tbody.innerHTML = '';
            allRows.forEach(row => tbody.appendChild(row));
            
            // Re-apply current filters after sorting
            if (typeof applyMembersFilters === 'function') {
                applyMembersFilters();
            }
        }
        
        // LEADS TAB - Analytics for lead generation
        // LEADS TAB - Comprehensive lead analytics with conversion tracking
        function renderLeadsTab() {
            // Check if we have the enhanced leads converted data
            const hasConvertedData = leadsConvertedData && leadsConvertedData.length > 0;
            
            if (!hasConvertedData && (!leadsData || leadsData.length === 0)) {
                document.getElementById('leads').innerHTML = `
                    <div class="alert info">
                        <h4>üìä Leads Analytics</h4>
                        <p>Upload the <strong>Leads Converted Report CSV</strong> file to unlock comprehensive lead analytics including:</p>
                        <ul style="margin: 10px 0 0 20px;">
                            <li>Detailed lead source tracking</li>
                            <li>Conversion funnel analysis</li>
                            <li>Location-based performance</li>
                            <li>Timeline of lead generation and conversions</li>
                            <li>LTV by source and location</li>
                        </ul>
                    </div>
                `;
                return;
            }
            
            // Use enhanced data if available, otherwise fallback to basic leads data
            const leadsToAnalyze = hasConvertedData ? leadsConvertedData : leadsData;
            
            // Filter by date range
            const filtered = leadsToAnalyze.filter(row => {
                let dateField = null;
                if (hasConvertedData) {
                    dateField = parseDate(row['Converted']);
                } else {
                    dateField = parseDate(row['Join date']);
                }
                
                if (!dateField) return false;
                
                const month = document.getElementById('monthFilter').value;
                const startDate = document.getElementById('startDate').value;
                const endDate = document.getElementById('endDate').value;
                
                if (month !== 'all') {
                    const rowMonth = `${dateField.getFullYear()}-${String(dateField.getMonth() + 1).padStart(2, '0')}`;
                    if (rowMonth !== month) return false;
                }
                
                if (startDate && dateField < new Date(startDate)) return false;
                if (endDate && dateField > new Date(endDate + 'T23:59:59')) return false;
                
                return true;
            });
            
            // Analyze data
            const analysis = analyzeLeadsData(filtered, hasConvertedData);
            
            // Render the comprehensive dashboard
            let html = renderLeadsOverview(analysis, hasConvertedData);
            html += renderLeadsSourceAnalysis(analysis, filtered, hasConvertedData);
            html += renderLeadsLocationAnalysis(analysis, filtered, hasConvertedData);
            html += renderLeadsTimeline(filtered, hasConvertedData);
            html += renderLeadsConversionFunnel(analysis, hasConvertedData);
            
            document.getElementById('leads').innerHTML = html;
            
            // Render all charts
            setTimeout(() => {
                renderLeadsCharts(analysis, filtered, hasConvertedData);
            }, 100);
        }
        
        function analyzeLeadsData(leads, hasConvertedData) {
            const analysis = {
                totalLeads: leads.length,
                sources: {},
                locations: {},
                convertedTo: {},
                byDate: {},
                byDayOfWeek: { 'Sunday': 0, 'Monday': 0, 'Tuesday': 0, 'Wednesday': 0, 'Thursday': 0, 'Friday': 0, 'Saturday': 0 },
                byHour: {},
                converted: 0,
                notConverted: 0,
                totalLTV: 0,
                ltvBySource: {},
                ltvByLocation: {},
                conversionsByMonth: {},
                sourcesByLocation: {}
            };
            
            // Initialize hours
            for (let i = 0; i < 24; i++) {
                analysis.byHour[i] = 0;
            }
            
            leads.forEach(lead => {
                let dateField = null;
                let source = 'Unknown';
                let location = 'Unknown';
                let ltv = 0;
                let isConverted = false;
                let convertedTo = 'N/A';
                
                if (hasConvertedData) {
                    dateField = parseDate(lead['Converted']);
                    source = lead['Lead source'] || 'Unknown';
                    // Filter out N/A sources
                    if (source === 'N/A' || source === 'n/a') {
                        source = 'Unknown';
                    }
                    location = lead['Home location'] || 'Unknown';
                    ltv = parseLTV(lead['LTV']);
                    convertedTo = (lead['Converted to'] || '').trim();
                    isConverted = convertedTo && convertedTo !== 'N/A' && convertedTo !== '';
                } else {
                    dateField = parseDate(lead['Join date']);
                    source = lead['Aggregator'] || 'Unknown';
                    // Filter out N/A sources
                    if (source === 'N/A' || source === 'n/a') {
                        source = 'Unknown';
                    }
                    const type = (lead['Type'] || '').toLowerCase();
                    isConverted = type === 'customer';
                    ltv = parseLTV(lead['LTV']);
                }
                
                // Count by source
                if (!analysis.sources[source]) {
                    analysis.sources[source] = { count: 0, converted: 0, ltv: 0 };
                }
                analysis.sources[source].count++;
                analysis.sources[source].ltv += ltv;
                if (isConverted) analysis.sources[source].converted++;
                
                // Count by location
                if (!analysis.locations[location]) {
                    analysis.locations[location] = { count: 0, converted: 0, ltv: 0 };
                }
                analysis.locations[location].count++;
                analysis.locations[location].ltv += ltv;
                if (isConverted) analysis.locations[location].converted++;
                
                // Source by location matrix
                const key = `${source}|${location}`;
                if (!analysis.sourcesByLocation[key]) {
                    analysis.sourcesByLocation[key] = { source, location, count: 0, converted: 0, ltv: 0 };
                }
                analysis.sourcesByLocation[key].count++;
                analysis.sourcesByLocation[key].ltv += ltv;
                if (isConverted) analysis.sourcesByLocation[key].converted++;
                
                // Conversion tracking
                if (isConverted) {
                    analysis.converted++;
                    if (hasConvertedData && convertedTo !== 'N/A') {
                        if (!analysis.convertedTo[convertedTo]) {
                            analysis.convertedTo[convertedTo] = { count: 0, ltv: 0 };
                        }
                        analysis.convertedTo[convertedTo].count++;
                        analysis.convertedTo[convertedTo].ltv += ltv;
                    }
                } else {
                    analysis.notConverted++;
                }
                
                analysis.totalLTV += ltv;
                
                // Time-based analysis
                if (dateField) {
                    // By date
                    const dateKey = dateField.toISOString().split('T')[0];
                    analysis.byDate[dateKey] = (analysis.byDate[dateKey] || 0) + 1;
                    
                    // By day of week
                    const dayNames = ['Sunday', 'Monday', 'Tuesday', 'Wednesday', 'Thursday', 'Friday', 'Saturday'];
                    const dayOfWeek = dayNames[dateField.getDay()];
                    analysis.byDayOfWeek[dayOfWeek]++;
                    
                    // By hour
                    const hour = dateField.getHours();
                    analysis.byHour[hour]++;
                    
                    // Conversions by month
                    if (isConverted) {
                        const monthKey = `${dateField.getFullYear()}-${String(dateField.getMonth() + 1).padStart(2, '0')}`;
                        analysis.conversionsByMonth[monthKey] = (analysis.conversionsByMonth[monthKey] || 0) + 1;
                    }
                }
            });
            
            return analysis;
        }
        
        function renderLeadsOverview(analysis, hasConvertedData) {
            const conversionRate = analysis.totalLeads > 0 ? (analysis.converted / analysis.totalLeads * 100) : 0;
            const avgLTV = analysis.converted > 0 ? (analysis.totalLTV / analysis.converted) : 0;
            
            // Find top source and location
            const sortedSources = Object.entries(analysis.sources).sort((a, b) => b[1].count - a[1].count);
            const topSource = sortedSources[0];
            
            const sortedLocations = Object.entries(analysis.locations).sort((a, b) => b[1].count - a[1].count);
            const topLocation = sortedLocations[0];
            
            // Best performing source (by conversion rate)
            const bestSource = sortedSources
                .filter(([_, data]) => data.count >= 5) // At least 5 leads
                .sort((a, b) => (b[1].converted/b[1].count) - (a[1].converted/a[1].count))[0];
            
            return `
                <div class="section">
                    <h2>üìä Leads & Conversion Overview</h2>
                    
                    <div class="metrics-grid" style="grid-template-columns: repeat(6, 1fr); margin-bottom: 30px;">
                        <div class="metric-card">
                            <div class="metric-label">üéØ Total Leads</div>
                            <div class="metric-value">${formatNumber(analysis.totalLeads)}</div>
                            <div class="metric-subtext">All lead entries</div>
                        </div>
                        
                        <div class="metric-card" style="background: linear-gradient(135deg, rgba(40, 167, 69, 0.1), rgba(30, 130, 50, 0.05));">
                            <div class="metric-label">‚úÖ Converted</div>
                            <div class="metric-value">${formatNumber(analysis.converted)}</div>
                            <div class="metric-subtext">${conversionRate.toFixed(1)}% conversion rate</div>
                        </div>
                        
                        <div class="metric-card">
                            <div class="metric-label">üí∞ Total LTV</div>
                            <div class="metric-value">${formatCurrency(analysis.totalLTV)}</div>
                            <div class="metric-subtext">From converted leads</div>
                        </div>
                        
                        <div class="metric-card">
                            <div class="metric-label">üìà Avg LTV</div>
                            <div class="metric-value">${formatCurrency(avgLTV)}</div>
                            <div class="metric-subtext">Per converted lead</div>
                        </div>
                        
                        <div class="metric-card" style="background: linear-gradient(135deg, rgba(1, 49, 96, 0.1), rgba(1, 49, 96, 0.05));">
                            <div class="metric-label">üèÜ Top Source</div>
                            <div class="metric-value" style="font-size: 1.1em;">${topSource ? topSource[0].substring(0, 12) : 'N/A'}</div>
                            <div class="metric-subtext">${topSource ? formatNumber(topSource[1].count) : 0} leads</div>
                        </div>
                        
                        <div class="metric-card" style="background: linear-gradient(135deg, rgba(113, 190, 210, 0.15), rgba(113, 190, 210, 0.05));">
                            <div class="metric-label">üìç Top Location</div>
                            <div class="metric-value" style="font-size: 1.1em;">${topLocation ? topLocation[0] : 'N/A'}</div>
                            <div class="metric-subtext">${topLocation ? formatNumber(topLocation[1].count) : 0} leads</div>
                        </div>
                    </div>
                    
                    ${bestSource ? `
                    <div class="alert" style="background: linear-gradient(135deg, rgba(251, 181, 20, 0.1), rgba(251, 181, 20, 0.05)); border-left: 4px solid var(--highlight);">
                        <h4>‚≠ê Best Performing Source</h4>
                        <p><strong>${bestSource[0]}</strong> has the highest conversion rate: ${((bestSource[1].converted/bestSource[1].count)*100).toFixed(1)}% 
                        (${formatNumber(bestSource[1].converted)} of ${formatNumber(bestSource[1].count)} leads converted)</p>
                    </div>
                    ` : ''}
                </div>
            `;
        }
        
        function renderLeadsSourceAnalysis(analysis, leads, hasConvertedData) {
            const sortedSources = Object.entries(analysis.sources)
                .sort((a, b) => b[1].count - a[1].count);
            
            return `
                <div class="section">
                    <h2>üéØ Lead Source Performance</h2>
                    <div class="chart-grid">
                        <div class="chart-container">
                            <h3>Lead Volume by Source</h3>
                            <div class="chart-wrapper">
                                <canvas id="leadsSourceVolumeChart"></canvas>
                            </div>
                        </div>
                        
                        <div class="chart-container">
                            <h3>Conversion Rate by Source</h3>
                            <div class="chart-wrapper">
                                <canvas id="leadsSourceConversionChart"></canvas>
                            </div>
                        </div>
                    </div>
                    
                    <div class="table-container" style="margin-top: 20px;">
                        <h3>Detailed Source Breakdown</h3>
                        <table>
                            <thead>
                                <tr>
                                    <th>Rank</th>
                                    <th>Source</th>
                                    <th>Total Leads</th>
                                    <th>Converted</th>
                                    <th>Conversion Rate</th>
                                    <th>Total LTV</th>
                                    <th>Avg LTV</th>
                                </tr>
                            </thead>
                            <tbody>
                                ${sortedSources.map(([source, data], i) => {
                                    const convRate = data.count > 0 ? (data.converted / data.count * 100) : 0;
                                    const avgLTV = data.converted > 0 ? (data.ltv / data.converted) : 0;
                                    return `
                                        <tr>
                                            <td><strong>${i + 1}</strong></td>
                                            <td><strong>${source}</strong></td>
                                            <td>${formatNumber(data.count)}</td>
                                            <td>${formatNumber(data.converted)}</td>
                                            <td><span style="padding: 4px 8px; border-radius: 4px; background: ${convRate >= 50 ? '#d4edda' : convRate >= 30 ? '#fff3cd' : '#f8d7da'}; color: ${convRate >= 50 ? '#155724' : convRate >= 30 ? '#856404' : '#721c24'};">${convRate.toFixed(1)}%</span></td>
                                            <td>${formatCurrency(data.ltv)}</td>
                                            <td>${formatCurrency(avgLTV)}</td>
                                        </tr>
                                    `;
                                }).join('')}
                            </tbody>
                        </table>
                    </div>
                </div>
            `;
        }
        
        function renderLeadsLocationAnalysis(analysis, leads, hasConvertedData) {
            const sortedLocations = Object.entries(analysis.locations)
                .sort((a, b) => b[1].count - a[1].count);
            
            // Source x Location matrix
            const matrix = Object.values(analysis.sourcesByLocation)
                .sort((a, b) => b.count - a.count)
                .slice(0, 15); // Top 15 combinations
            
            return `
                <div class="section">
                    <h2>üìç Location Performance</h2>
                    <div class="chart-grid">
                        <div class="chart-container">
                            <h3>Leads by Location</h3>
                            <div class="chart-wrapper">
                                <canvas id="leadsLocationChart"></canvas>
                            </div>
                        </div>
                        
                        <div class="chart-container">
                            <h3>LTV by Location</h3>
                            <div class="chart-wrapper">
                                <canvas id="leadsLocationLTVChart"></canvas>
                            </div>
                        </div>
                    </div>
                    
                    <div class="table-container" style="margin-top: 20px;">
                        <h3>Top Source √ó Location Combinations</h3>
                        <table>
                            <thead>
                                <tr>
                                    <th>Rank</th>
                                    <th>Source</th>
                                    <th>Location</th>
                                    <th>Leads</th>
                                    <th>Converted</th>
                                    <th>Conv. Rate</th>
                                    <th>Total LTV</th>
                                </tr>
                            </thead>
                            <tbody>
                                ${matrix.map((combo, i) => {
                                    const convRate = combo.count > 0 ? (combo.converted / combo.count * 100) : 0;
                                    return `
                                        <tr>
                                            <td><strong>${i + 1}</strong></td>
                                            <td>${combo.source}</td>
                                            <td>${combo.location}</td>
                                            <td>${formatNumber(combo.count)}</td>
                                            <td>${formatNumber(combo.converted)}</td>
                                            <td>${convRate.toFixed(1)}%</td>
                                            <td>${formatCurrency(combo.ltv)}</td>
                                        </tr>
                                    `;
                                }).join('')}
                            </tbody>
                        </table>
                    </div>
                </div>
            `;
        }
        
        function renderLeadsTimeline(leads, hasConvertedData) {
            let html = `
                <div class="section">
                    <h2>üìÖ Lead Generation Timeline</h2>
                    <div class="chart-container full-width">
                        <h3>Daily Lead Activity</h3>
                        <div class="chart-wrapper">
                            <canvas id="leadsDailyChart"></canvas>
                        </div>
                    </div>
                </div>
                
                <div class="section">
                    <h2>üî• Lead Generation Heatmap (01/10/25)</h2>
                    <p style="color: #666; margin-bottom: 15px;">Click any cell to see detailed lead information for that day and hour</p>
                    <div id="leadsHeatmapContainer" style="overflow-x: auto;">
                        <div id="leadsHeatmap"></div>
                    </div>
                </div>
            `;
            
            // Add location-specific heatmaps for SocialFitness leads
            if (hasConvertedData) {
                const sfLeads = leads.filter(lead => {
                    const source = (lead['Lead source'] || '').trim();
                    return source.startsWith('SF');
                });
                
                if (sfLeads.length > 0) {
                    // Group by location
                    const locationMap = {};
                    sfLeads.forEach(lead => {
                        const location = lead['Home location'] || 'Unknown';
                        if (!locationMap[location]) {
                            locationMap[location] = [];
                        }
                        locationMap[location].push(lead);
                    });
                    
                    // Create heatmaps for each location
                    Object.keys(locationMap).sort().forEach(location => {
                        const locationLeads = locationMap[location];
                        html += `
                            <div class="section" style="margin-bottom: 50px; padding: 20px; background: white; border-radius: 15px; box-shadow: 0 5px 15px rgba(0,0,0,0.1);">
                                <h2>üî• SocialFitness Heatmap - ${location}</h2>
                                <p style="color: #666; margin-bottom: 15px;">
                                    <strong>${locationLeads.length}</strong> leads from SocialFitness at ${location} location
                                </p>
                                <div id="sfHeatmapContainer-${location.replace(/\s+/g, '-')}" style="overflow-x: auto;">
                                    <div id="sfHeatmap-${location.replace(/\s+/g, '-')}"></div>
                                </div>
                            </div>
                        `;
                    });
                }
            }
            
            return html;
        }
        
        function renderLeadsConversionFunnel(analysis, hasConvertedData) {
            if (!hasConvertedData || Object.keys(analysis.convertedTo).length === 0) {
                return '';
            }
            
            const sortedConversions = Object.entries(analysis.convertedTo)
                .sort((a, b) => b[1].count - a[1].count);
            
            return `
                <div class="section">
                    <h2>üéØ Conversion Breakdown</h2>
                    <div class="chart-grid">
                        <div class="chart-container">
                            <h3>What Leads Converted To</h3>
                            <div class="chart-wrapper">
                                <canvas id="leadsConvertedToChart"></canvas>
                            </div>
                        </div>
                        
                        <div class="chart-container">
                            <h3>LTV by Membership Type</h3>
                            <div class="chart-wrapper">
                                <canvas id="leadsConvertedToLTVChart"></canvas>
                            </div>
                        </div>
                    </div>
                    
                    <div class="table-container" style="margin-top: 20px;">
                        <h3>Conversion Type Details</h3>
                        <table>
                            <thead>
                                <tr>
                                    <th>Rank</th>
                                    <th>Membership/Offer</th>
                                    <th>Conversions</th>
                                    <th>% of Total</th>
                                    <th>Total LTV</th>
                                    <th>Avg LTV</th>
                                </tr>
                            </thead>
                            <tbody>
                                ${sortedConversions.map(([type, data], i) => {
                                    const pct = (data.count / analysis.converted * 100);
                                    const avgLTV = data.count > 0 ? (data.ltv / data.count) : 0;
                                    return `
                                        <tr>
                                            <td><strong>${i + 1}</strong></td>
                                            <td>${type}</td>
                                            <td>${formatNumber(data.count)}</td>
                                            <td>${pct.toFixed(1)}%</td>
                                            <td>${formatCurrency(data.ltv)}</td>
                                            <td>${formatCurrency(avgLTV)}</td>
                                        </tr>
                                    `;
                                }).join('')}
                            </tbody>
                        </table>
                    </div>
                </div>
            `;
        }
        
        function renderLeadsCharts(analysis, leads, hasConvertedData) {
            // Source Volume Chart
            const sourceCanvas = document.getElementById('leadsSourceVolumeChart');
            if (sourceCanvas) {
                destroyChart('leadsSourceVolume');
                const ctx = sourceCanvas.getContext('2d');
                const sortedSources = Object.entries(analysis.sources).sort((a, b) => b[1].count - a[1].count).slice(0, 10);
                allCharts.leadsSourceVolume = new Chart(ctx, {
                    type: 'bar',
                    data: {
                        labels: sortedSources.map(s => s[0]),
                        datasets: [{
                            label: 'Total Leads',
                            data: sortedSources.map(s => s[1].count),
                            backgroundColor: '#013160',
                            borderColor: '#013160',
                            borderWidth: 1
                        }]
                    },
                    options: {
                        responsive: true,
                        maintainAspectRatio: false,
                        onClick: (event, elements) => {
                            if (elements.length > 0) {
                                const index = elements[0].index;
                                const source = sortedSources[index][0];
                                const sourceLeads = leads.filter(l => (l['Lead source'] || 'Unknown') === source);
                                showLeadsSourceDetails(source, sourceLeads);
                            }
                        },
                        plugins: { legend: { display: false } },
                        scales: {
                            y: {
                                beginAtZero: true,
                                ticks: { stepSize: 1 }
                            }
                        }
                    }
                });
            }
            
            // Source Conversion Rate Chart
            const sourceConvCanvas = document.getElementById('leadsSourceConversionChart');
            if (sourceConvCanvas) {
                destroyChart('leadsSourceConversion');
                const ctx = sourceConvCanvas.getContext('2d');
                const sortedSources = Object.entries(analysis.sources)
                    .filter(([_, data]) => data.count >= 3) // At least 3 leads
                    .sort((a, b) => b[1].count - a[1].count)
                    .slice(0, 10);
                allCharts.leadsSourceConversion = new Chart(ctx, {
                    type: 'bar',
                    data: {
                        labels: sortedSources.map(s => s[0]),
                        datasets: [{
                            label: 'Conversion Rate (%)',
                            data: sortedSources.map(s => (s[1].converted / s[1].count * 100)),
                            backgroundColor: '#28a745',
                            borderColor: '#28a745',
                            borderWidth: 1
                        }]
                    },
                    options: {
                        responsive: true,
                        maintainAspectRatio: false,
                        onClick: (event, elements) => {
                            if (elements.length > 0) {
                                const index = elements[0].index;
                                const source = sortedSources[index][0];
                                const sourceLeads = leads.filter(l => (l['Lead source'] || 'Unknown') === source);
                                showLeadsSourceDetails(source, sourceLeads);
                            }
                        },
                        plugins: { 
                            legend: { display: false },
                            tooltip: {
                                callbacks: {
                                    label: function(context) {
                                        return `${context.parsed.y.toFixed(1)}% conversion`;
                                    }
                                }
                            }
                        },
                        scales: {
                            y: {
                                beginAtZero: true,
                                max: 100,
                                ticks: {
                                    callback: function(value) {
                                        return value + '%';
                                    }
                                }
                            }
                        }
                    }
                });
            }
            
            // Location Chart
            const locationCanvas = document.getElementById('leadsLocationChart');
            if (locationCanvas) {
                destroyChart('leadsLocation');
                const ctx = locationCanvas.getContext('2d');
                const sortedLocations = Object.entries(analysis.locations).sort((a, b) => b[1].count - a[1].count);
                allCharts.leadsLocation = new Chart(ctx, {
                    type: 'doughnut',
                    data: {
                        labels: sortedLocations.map(l => l[0]),
                        datasets: [{
                            data: sortedLocations.map(l => l[1].count),
                            backgroundColor: ['#013160', '#71BED2', '#FBB514', '#28a745', '#dc3545', '#ffc107', '#9c27b0'],
                            borderWidth: 2,
                            borderColor: '#fff'
                        }]
                    },
                    options: {
                        responsive: true,
                        maintainAspectRatio: false,
                        plugins: {
                            legend: {
                                position: 'right',
                                labels: { padding: 15, font: { size: 12 } }
                            }
                        }
                    }
                });
            }
            
            // Location LTV Chart
            const locationLTVCanvas = document.getElementById('leadsLocationLTVChart');
            if (locationLTVCanvas) {
                destroyChart('leadsLocationLTV');
                const ctx = locationLTVCanvas.getContext('2d');
                const sortedLocations = Object.entries(analysis.locations).sort((a, b) => b[1].ltv - a[1].ltv);
                allCharts.leadsLocationLTV = new Chart(ctx, {
                    type: 'bar',
                    data: {
                        labels: sortedLocations.map(l => l[0]),
                        datasets: [{
                            label: 'Total LTV',
                            data: sortedLocations.map(l => l[1].ltv),
                            backgroundColor: '#71BED2',
                            borderColor: '#71BED2',
                            borderWidth: 1
                        }]
                    },
                    options: {
                        responsive: true,
                        maintainAspectRatio: false,
                        plugins: { legend: { display: false } },
                        scales: {
                            y: {
                                beginAtZero: true,
                                ticks: {
                                    callback: function(value) {
                                        return formatCurrency(value);
                                    }
                                }
                            }
                        }
                    }
                });
            }
            
            // Daily Activity Chart
            const dailyCanvas = document.getElementById('leadsDailyChart');
            if (dailyCanvas) {
                destroyChart('leadsDaily');
                const ctx = dailyCanvas.getContext('2d');
                const sortedDates = Object.keys(analysis.byDate).sort();
                allCharts.leadsDaily = new Chart(ctx, {
                    type: 'line',
                    data: {
                        labels: sortedDates.map(d => new Date(d).toLocaleDateString('en-US', { month: 'short', day: 'numeric' })),
                        datasets: [{
                            label: 'Daily Leads',
                            data: sortedDates.map(d => analysis.byDate[d]),
                            borderColor: '#013160',
                            backgroundColor: 'rgba(1, 49, 96, 0.1)',
                            borderWidth: 2,
                            fill: true,
                            tension: 0.3
                        }]
                    },
                    options: {
                        responsive: true,
                        maintainAspectRatio: false,
                        plugins: { legend: { display: false } },
                        scales: {
                            y: {
                                beginAtZero: true,
                                ticks: { stepSize: 1 }
                            }
                        }
                    }
                });
            }
            
            // Day of Week Chart - REMOVED
            // const dayCanvas = document.getElementById('leadsByDayChart');
            
            // Hour of Day Chart - REMOVED  
            // const hourCanvas = document.getElementById('leadsByHourChart');
            
            // Render the heatmap
            renderLeadsHeatmap(leads);
            
            // Render SF location-specific heatmaps
            if (hasConvertedData) {
                const sfLeads = leads.filter(lead => {
                    const source = (lead['Lead source'] || '').trim();
                    return source.startsWith('SF');
                });
                
                if (sfLeads.length > 0) {
                    // Group by location
                    const locationMap = {};
                    sfLeads.forEach(lead => {
                        const location = lead['Home location'] || 'Unknown';
                        if (!locationMap[location]) {
                            locationMap[location] = [];
                        }
                        locationMap[location].push(lead);
                    });
                    
                    // Render heatmap for each location
                    Object.keys(locationMap).sort().forEach(location => {
                        const containerId = `sfHeatmap-${location.replace(/\s+/g, '-')}`;
                        const container = document.getElementById(containerId);
                        if (container) {
                            renderLocationHeatmap(locationMap[location], containerId, location);
                        }
                    });
                }
            }
            
            // Monthly Conversions Chart
            const monthlyConvCanvas = document.getElementById('leadsMonthlyConversionsChart');
            if (monthlyConvCanvas) {
                destroyChart('leadsMonthlyConversions');
                const ctx = monthlyConvCanvas.getContext('2d');
                const sortedMonths = Object.keys(analysis.conversionsByMonth).sort();
                allCharts.leadsMonthlyConversions = new Chart(ctx, {
                    type: 'bar',
                    data: {
                        labels: sortedMonths.map(m => {
                            const [year, month] = m.split('-');
                            return new Date(year, month - 1).toLocaleDateString('en-US', { month: 'short', year: '2-digit' });
                        }),
                        datasets: [{
                            label: 'Conversions',
                            data: sortedMonths.map(m => analysis.conversionsByMonth[m]),
                            backgroundColor: '#28a745',
                            borderColor: '#28a745',
                            borderWidth: 1
                        }]
                    },
                    options: {
                        responsive: true,
                        maintainAspectRatio: false,
                        plugins: { legend: { display: false } },
                        scales: {
                            y: {
                                beginAtZero: true,
                                ticks: { stepSize: 1 }
                            }
                        }
                    }
                });
            }
            
            // Converted To Chart
            if (hasConvertedData && Object.keys(analysis.convertedTo).length > 0) {
                const convertedToCanvas = document.getElementById('leadsConvertedToChart');
                if (convertedToCanvas) {
                    destroyChart('leadsConvertedTo');
                    const ctx = convertedToCanvas.getContext('2d');
                    const sortedTypes = Object.entries(analysis.convertedTo).sort((a, b) => b[1].count - a[1].count);
                    allCharts.leadsConvertedTo = new Chart(ctx, {
                        type: 'doughnut',
                        data: {
                            labels: sortedTypes.map(t => t[0]),
                            datasets: [{
                                data: sortedTypes.map(t => t[1].count),
                                backgroundColor: ['#013160', '#71BED2', '#FBB514', '#28a745', '#dc3545', '#ffc107', '#9c27b0', '#ff5722'],
                                borderWidth: 2,
                                borderColor: '#fff'
                            }]
                        },
                        options: {
                            responsive: true,
                            maintainAspectRatio: false,
                            plugins: {
                                legend: {
                                    position: 'right',
                                    labels: { padding: 10, font: { size: 11 } }
                                }
                            }
                        }
                    });
                }
                
                // Converted To LTV Chart
                const convertedToLTVCanvas = document.getElementById('leadsConvertedToLTVChart');
                if (convertedToLTVCanvas) {
                    destroyChart('leadsConvertedToLTV');
                    const ctx = convertedToLTVCanvas.getContext('2d');
                    const sortedTypes = Object.entries(analysis.convertedTo).sort((a, b) => b[1].ltv - a[1].ltv);
                    allCharts.leadsConvertedToLTV = new Chart(ctx, {
                        type: 'bar',
                        data: {
                            labels: sortedTypes.map(t => t[0]),
                            datasets: [{
                                label: 'Total LTV',
                                data: sortedTypes.map(t => t[1].ltv),
                                backgroundColor: '#28a745',
                                borderColor: '#28a745',
                                borderWidth: 1
                            }]
                        },
                        options: {
                            responsive: true,
                            maintainAspectRatio: false,
                            plugins: { legend: { display: false } },
                            scales: {
                                y: {
                                    beginAtZero: true,
                                    ticks: {
                                        callback: function(value) {
                                            return formatCurrency(value);
                                        }
                                    }
                                }
                            }
                        }
                    });
                }
            }
        }
        
        function formatTime(hour) {
            const h = parseInt(hour);
            if (h === 0) return '12 AM';
            if (h < 12) return `${h} AM`;
            if (h === 12) return '12 PM';
            return `${h - 12} PM`;
        }
        
        function renderLeadsHeatmap(leads) {
            const heatmapContainer = document.getElementById('leadsHeatmap');
            if (!heatmapContainer) return;
            
            // Build data structure: day -> hour -> leads array
            const heatmapData = {};
            const dayOrder = ['Monday', 'Tuesday', 'Wednesday', 'Thursday', 'Friday', 'Saturday'];
            dayOrder.forEach(day => {
                heatmapData[day] = {};
                for (let hour = 0; hour < 24; hour++) {
                    heatmapData[day][hour] = [];
                }
            });
            
            // Populate the heatmap data
            leads.forEach(lead => {
                let dateField = null;
                const hasConvertedData = lead['Lead source'] !== undefined;
                
                if (hasConvertedData) {
                    dateField = parseDate(lead['Converted']);
                } else {
                    dateField = parseDate(lead['Join date']);
                }
                
                if (!dateField) return;
                
                const dayNames = ['Sunday', 'Monday', 'Tuesday', 'Wednesday', 'Thursday', 'Friday', 'Saturday'];
                const dayOfWeek = dayNames[dateField.getDay()];
                const hour = dateField.getHours();
                
                // Only include Monday-Saturday
                if (dayOrder.includes(dayOfWeek)) {
                    heatmapData[dayOfWeek][hour].push(lead);
                }
            });
            
            // Find max count for color scaling
            let maxCount = 0;
            dayOrder.forEach(day => {
                for (let hour = 0; hour < 24; hour++) {
                    const count = heatmapData[day][hour].length;
                    if (count > maxCount) maxCount = count;
                }
            });
            
            // Generate heatmap HTML
            let html = '<table style="border-collapse: collapse; margin: 0 auto; background: white; box-shadow: 0 2px 4px rgba(0,0,0,0.1);">';
            
            // Header row with hours
            html += '<tr><th style="padding: 10px; border: 1px solid #ddd; background: #013160; color: white; font-weight: bold;">Day \\ Hour</th>';
            for (let hour = 0; hour < 24; hour++) {
                html += `<th style="padding: 8px; border: 1px solid #ddd; background: #013160; color: white; font-size: 11px; min-width: 35px;">${formatTime(hour)}</th>`;
            }
            html += '</tr>';
            
            // Data rows
            dayOrder.forEach(day => {
                html += '<tr>';
                html += `<td style="padding: 10px; border: 1px solid #ddd; background: #f5f5f5; font-weight: bold; color: #013160;">${day}</td>`;
                
                for (let hour = 0; hour < 24; hour++) {
                    const count = heatmapData[day][hour].length;
                    const intensity = maxCount > 0 ? count / maxCount : 0;
                    
                    // Color scale from white to dark blue
                    let bgColor;
                    if (count === 0) {
                        bgColor = '#ffffff';
                    } else {
                        const r = Math.floor(255 - (intensity * 242)); // 255 -> 13
                        const g = Math.floor(255 - (intensity * 206)); // 255 -> 49
                        const b = Math.floor(255 - (intensity * 159)); // 255 -> 96
                        bgColor = `rgb(${r}, ${g}, ${b})`;
                    }
                    
                    const textColor = intensity > 0.5 ? 'white' : '#333';
                    const cursor = count > 0 ? 'pointer' : 'default';
                    const dataAttr = count > 0 ? `data-day="${day}" data-hour="${hour}"` : '';
                    
                    html += `<td ${dataAttr} style="padding: 12px; border: 1px solid #ddd; background: ${bgColor}; color: ${textColor}; text-align: center; font-weight: ${count > 0 ? 'bold' : 'normal'}; cursor: ${cursor}; transition: all 0.2s;" 
                            onmouseover="this.style.transform='scale(1.1)'; this.style.boxShadow='0 4px 8px rgba(0,0,0,0.2)'; this.style.zIndex='10';" 
                            onmouseout="this.style.transform='scale(1)'; this.style.boxShadow='none'; this.style.zIndex='1';"
                            ${count > 0 ? `onclick="showHeatmapDetails('${day}', ${hour})"` : ''}>
                        ${count > 0 ? count : ''}
                    </td>`;
                }
                
                html += '</tr>';
            });
            
            html += '</table>';
            heatmapContainer.innerHTML = html;
            
            // Store heatmap data globally for click handlers
            window.leadsHeatmapData = heatmapData;
        }
        
        // Render location-specific heatmap for SF leads
        function renderLocationHeatmap(leads, containerId, locationName) {
            const heatmapContainer = document.getElementById(containerId);
            if (!heatmapContainer) return;
            
            // Build data structure: day -> hour -> leads array
            const heatmapData = {};
            const dayOrder = ['Monday', 'Tuesday', 'Wednesday', 'Thursday', 'Friday', 'Saturday'];
            dayOrder.forEach(day => {
                heatmapData[day] = {};
                for (let hour = 0; hour < 24; hour++) {
                    heatmapData[day][hour] = [];
                }
            });
            
            // Populate the heatmap data
            leads.forEach(lead => {
                const dateField = parseDate(lead['Converted']);
                if (!dateField) return;
                
                const dayNames = ['Sunday', 'Monday', 'Tuesday', 'Wednesday', 'Thursday', 'Friday', 'Saturday'];
                const dayOfWeek = dayNames[dateField.getDay()];
                const hour = dateField.getHours();
                
                // Only include Monday-Saturday
                if (dayOrder.includes(dayOfWeek)) {
                    heatmapData[dayOfWeek][hour].push(lead);
                }
            });
            
            // Find max count for color scaling
            let maxCount = 0;
            dayOrder.forEach(day => {
                for (let hour = 0; hour < 24; hour++) {
                    const count = heatmapData[day][hour].length;
                    if (count > maxCount) maxCount = count;
                }
            });
            
            // Generate heatmap HTML
            let html = '<table style="border-collapse: collapse; margin: 0 auto; background: white; box-shadow: 0 2px 4px rgba(0,0,0,0.1);">';
            
            // Header row with hours
            html += '<tr><th style="padding: 10px; border: 1px solid #ddd; background: #013160; color: white; font-weight: bold;">Day \\ Hour</th>';
            for (let hour = 0; hour < 24; hour++) {
                html += `<th style="padding: 8px; border: 1px solid #ddd; background: #013160; color: white; font-size: 11px; min-width: 35px;">${formatTime(hour)}</th>`;
            }
            html += '</tr>';
            
            // Data rows
            dayOrder.forEach(day => {
                html += '<tr>';
                html += `<td style="padding: 10px; border: 1px solid #ddd; background: #f5f5f5; font-weight: bold; color: #013160;">${day}</td>`;
                
                for (let hour = 0; hour < 24; hour++) {
                    const count = heatmapData[day][hour].length;
                    const intensity = maxCount > 0 ? count / maxCount : 0;
                    
                    // Color scale from white to orange (SocialFitness branding)
                    let bgColor;
                    if (count === 0) {
                        bgColor = '#ffffff';
                    } else {
                        const r = Math.floor(255 - (intensity * 4)); // 255 -> 251
                        const g = Math.floor(255 - (intensity * 74)); // 255 -> 181
                        const b = Math.floor(255 - (intensity * 235)); // 255 -> 20
                        bgColor = `rgb(${r}, ${g}, ${b})`;
                    }
                    
                    const textColor = intensity > 0.5 ? 'white' : '#333';
                    const cursor = count > 0 ? 'pointer' : 'default';
                    const dataAttr = count > 0 ? `data-day="${day}" data-hour="${hour}" data-location="${locationName}"` : '';
                    
                    html += `<td ${dataAttr} style="padding: 12px; border: 1px solid #ddd; background: ${bgColor}; color: ${textColor}; text-align: center; font-weight: ${count > 0 ? 'bold' : 'normal'}; cursor: ${cursor}; transition: all 0.2s;" 
                            onmouseover="this.style.transform='scale(1.1)'; this.style.boxShadow='0 4px 8px rgba(0,0,0,0.2)'; this.style.zIndex='10';" 
                            onmouseout="this.style.transform='scale(1)'; this.style.boxShadow='none'; this.style.zIndex='1';"
                            ${count > 0 ? `onclick="showLocationHeatmapDetails('${locationName}', '${day}', ${hour})"` : ''}>
                        ${count > 0 ? count : ''}
                    </td>`;
                }
                
                html += '</tr>';
            });
            
            html += '</table>';
            heatmapContainer.innerHTML = html;
            
            // Store heatmap data globally for click handlers
            if (!window.sfHeatmapData) window.sfHeatmapData = {};
            window.sfHeatmapData[locationName] = heatmapData;
        }
        
        function showLocationHeatmapDetails(location, day, hour) {
            if (!window.sfHeatmapData || !window.sfHeatmapData[location] || 
                !window.sfHeatmapData[location][day] || !window.sfHeatmapData[location][day][hour]) return;
            
            const leadsInCell = window.sfHeatmapData[location][day][hour];
            if (leadsInCell.length === 0) return;
            
            let html = `<h3>${location} - ${day} at ${formatTime(hour)}</h3>`;
            html += `<p style="margin: 10px 0; color: #666;"><strong>${formatNumber(leadsInCell.length)}</strong> SocialFitness lead(s) generated during this time</p>`;
            
            // Count converted vs not converted
            const converted = leadsInCell.filter(l => {
                const convertedTo = (l['Converted to'] || '').trim();
                return convertedTo && convertedTo !== 'N/A' && convertedTo !== '';
            }).length;
            
            html += `<p style="margin: 10px 0;"><strong>Converted:</strong> ${converted} of ${leadsInCell.length} (${((converted/leadsInCell.length)*100).toFixed(1)}%)</p>`;
            
            html += '<div class="table-container" style="max-height: 400px; overflow-y: auto;">';
            html += '<table><thead><tr>';
            html += '<th>Name</th><th>Date</th><th>Source</th><th>Converted To</th><th>LTV</th>';
            html += '</tr></thead><tbody>';
            
            leadsInCell.forEach(lead => {
                const convertedTo = lead['Converted to'] || 'N/A';
                const isConverted = convertedTo !== 'N/A';
                const ltv = parseLTV(lead['LTV']);
                const dateField = parseDate(lead['Converted']);
                const dateStr = dateField ? `${String(dateField.getMonth() + 1).padStart(2, '0')}/${String(dateField.getDate()).padStart(2, '0')}/${String(dateField.getFullYear()).slice(-2)}` : 'N/A';
                
                html += '<tr>';
                html += `<td>${lead['First Name']} ${lead['Last Name']}</td>`;
                html += `<td>${dateStr}</td>`;
                html += `<td>${lead['Lead source'] || 'Unknown'}</td>`;
                html += `<td><span style="padding: 4px 8px; border-radius: 4px; background: ${isConverted ? '#d4edda' : '#f8d7da'}; color: ${isConverted ? '#155724' : '#721c24'};">${convertedTo}</span></td>`;
                html += `<td>${formatCurrency(ltv)}</td>`;
                html += '</tr>';
            });
            
            html += '</tbody></table></div>';
            
            // Add summary stats
            const totalLTV = leadsInCell.reduce((sum, l) => sum + (parseLTV(l['LTV'])), 0);
            const avgLTV = converted > 0 ? totalLTV / converted : 0;
            
            html += `<div style="margin-top: 20px; padding: 15px; background: #f8f9fa; border-radius: 8px;">`;
            html += `<strong>Summary:</strong> Total LTV: ${formatCurrency(totalLTV)} | Avg LTV: ${formatCurrency(avgLTV)}`;
            html += `</div>`;
            
            showModal(`SocialFitness Leads: ${location} - ${day} at ${formatTime(hour)}`, html);
        }
        
        // Render appointment heatmap for a specific location
        function renderAppointmentHeatmap(appointments, containerId, locationName) {
            const heatmapContainer = document.getElementById(containerId);
            if (!heatmapContainer) return;
            
            // Build data structure: day -> hour -> appointments array
            const heatmapData = {};
            const dayOrder = ['Monday', 'Tuesday', 'Wednesday', 'Thursday', 'Friday', 'Saturday'];
            dayOrder.forEach(day => {
                heatmapData[day] = {};
                for (let hour = 0; hour < 24; hour++) {
                    heatmapData[day][hour] = [];
                }
            });
            
            // Populate the heatmap data
            appointments.forEach(appt => {
                const dateField = parseDate(appt['Appointment Date']);
                if (!dateField) return;
                
                const dayNames = ['Sunday', 'Monday', 'Tuesday', 'Wednesday', 'Thursday', 'Friday', 'Saturday'];
                const dayOfWeek = dayNames[dateField.getDay()];
                const hour = dateField.getHours();
                
                // Only include Monday-Saturday
                if (dayOrder.includes(dayOfWeek)) {
                    heatmapData[dayOfWeek][hour].push(appt);
                }
            });
            
            // Find max count for color scaling
            let maxCount = 0;
            dayOrder.forEach(day => {
                for (let hour = 0; hour < 24; hour++) {
                    const count = heatmapData[day][hour].length;
                    if (count > maxCount) maxCount = count;
                }
            });
            
            // Generate heatmap HTML
            let html = '<table style="border-collapse: collapse; margin: 0 auto; background: white; box-shadow: 0 2px 4px rgba(0,0,0,0.1);">';
            
            // Header row with hours
            html += '<tr><th style="padding: 10px; border: 1px solid #ddd; background: #013160; color: white; font-weight: bold;">Day \\ Hour</th>';
            for (let hour = 0; hour < 24; hour++) {
                html += `<th style="padding: 8px; border: 1px solid #ddd; background: #013160; color: white; font-size: 11px; min-width: 35px;">${formatTime(hour)}</th>`;
            }
            html += '</tr>';
            
            // Data rows
            dayOrder.forEach(day => {
                html += '<tr>';
                html += `<td style="padding: 10px; border: 1px solid #ddd; background: #f5f5f5; font-weight: bold; color: #013160;">${day}</td>`;
                
                for (let hour = 0; hour < 24; hour++) {
                    const count = heatmapData[day][hour].length;
                    const intensity = maxCount > 0 ? count / maxCount : 0;
                    
                    // Color scale from white to accent blue
                    let bgColor;
                    if (count === 0) {
                        bgColor = '#ffffff';
                    } else {
                        const r = Math.floor(255 - (intensity * 142)); // 255 -> 113
                        const g = Math.floor(255 - (intensity * 65));  // 255 -> 190
                        const b = Math.floor(255 - (intensity * 45));  // 255 -> 210
                        bgColor = `rgb(${r}, ${g}, ${b})`;
                    }
                    
                    const textColor = intensity > 0.5 ? 'white' : '#333';
                    const cursor = count > 0 ? 'pointer' : 'default';
                    const dataAttr = count > 0 ? `data-day="${day}" data-hour="${hour}" data-location="${locationName}"` : '';
                    
                    html += `<td ${dataAttr} style="padding: 12px; border: 1px solid #ddd; background: ${bgColor}; color: ${textColor}; text-align: center; font-weight: ${count > 0 ? 'bold' : 'normal'}; cursor: ${cursor}; transition: all 0.2s;" 
                            onmouseover="this.style.transform='scale(1.1)'; this.style.boxShadow='0 4px 8px rgba(0,0,0,0.2)'; this.style.zIndex='10';" 
                            onmouseout="this.style.transform='scale(1)'; this.style.boxShadow='none'; this.style.zIndex='1';"
                            ${count > 0 ? `onclick="showApptHeatmapDetails('${locationName}', '${day}', ${hour})"` : ''}>
                        ${count > 0 ? count : ''}
                    </td>`;
                }
                
                html += '</tr>';
            });
            
            html += '</table>';
            heatmapContainer.innerHTML = html;
            
            // Store heatmap data globally for click handlers
            if (!window.apptHeatmapData) window.apptHeatmapData = {};
            window.apptHeatmapData[locationName] = heatmapData;
        }
        
        function showApptHeatmapDetails(location, day, hour) {
            if (!window.apptHeatmapData || !window.apptHeatmapData[location] || 
                !window.apptHeatmapData[location][day] || !window.apptHeatmapData[location][day][hour]) return;
            
            const apptsInCell = window.apptHeatmapData[location][day][hour];
            if (apptsInCell.length === 0) return;
            
            const activeMemberEmails = getActiveMemberEmails();
            
            let html = `<h3>${location} - ${day} at ${formatTime(hour)}</h3>`;
            html += `<p style="margin: 10px 0; color: #666;"><strong>${formatNumber(apptsInCell.length)}</strong> appointment(s) during this time</p>`;
            
            // Calculate stats
            const totalRevenue = apptsInCell.reduce((sum, a) => {
                const email = (a['Customer Email'] || '').toLowerCase().trim();
                const revenue = parseFloat(a.Revenue || 0);
                return sum + (activeMemberEmails.has(email) ? 0 : revenue);
            }, 0);
            const totalPayout = apptsInCell.reduce((sum, a) => sum + parseFloat(a['Total Payout'] || 0), 0);
            const profit = totalRevenue - totalPayout;
            
            html += `<p style="margin: 10px 0;">
                <strong>Revenue:</strong> ${formatCurrency(totalRevenue)} | 
                <strong>Payout:</strong> ${formatCurrency(totalPayout)} | 
                <strong>Profit:</strong> ${formatCurrency(profit)}
            </p>`;
            
            html += '<div class="table-container" style="max-height: 400px; overflow-y: auto;">';
            html += '<table><thead><tr>';
            html += '<th>Time</th><th>Customer</th><th>Service</th><th>VSP</th><th>Revenue</th>';
            html += '</tr></thead><tbody>';
            
            apptsInCell.forEach(appt => {
                const dateField = parseDate(appt['Appointment Date']);
                const time = dateField ? dateField.toLocaleTimeString('en-US', { hour: 'numeric', minute: '2-digit' }) : 'N/A';
                const email = (appt['Customer Email'] || '').toLowerCase().trim();
                const customerName = `${appt['Customer First Name']} ${appt['Customer Last Name']}`;
                const momenceLink = getMomenceCustomerLink(appt['Customer Email'], customerName);
                const revenue = parseFloat(appt.Revenue || 0);
                const displayRevenue = activeMemberEmails.has(email) ? 0 : revenue;
                
                html += '<tr>';
                html += `<td>${time}</td>`;
                html += `<td>${customerName}${momenceLink}</td>`;
                html += `<td>${appt.Appointment}</td>`;
                html += `<td>${appt['Practitioner First Name']} ${appt['Practitioner Last Name']}</td>`;
                html += `<td>${formatCurrency(displayRevenue)}</td>`;
                html += '</tr>';
            });
            
            html += '</tbody></table></div>';
            
            showModal(`Appointments: ${location} - ${day} at ${formatTime(hour)}`, html);
        }
        
        function showHeatmapDetails(day, hour) {
            if (!window.leadsHeatmapData || !window.leadsHeatmapData[day] || !window.leadsHeatmapData[day][hour]) return;
            
            const leadsInCell = window.leadsHeatmapData[day][hour];
            if (leadsInCell.length === 0) return;
            
            const hasConvertedData = leadsInCell[0]['Lead source'] !== undefined;
            
            let html = `<h3>${day} at ${formatTime(hour)}</h3>`;
            html += `<p style="margin: 10px 0; color: #666;"><strong>${formatNumber(leadsInCell.length)}</strong> lead(s) generated during this time</p>`;
            
            // Count converted vs not converted
            let converted = 0;
            leadsInCell.forEach(lead => {
                if (hasConvertedData) {
                    const convertedTo = (lead['Converted to'] || '').trim();
                    if (convertedTo && convertedTo !== 'N/A' && convertedTo !== '') {
                        converted++;
                    }
                } else {
                    const type = (lead['Type'] || '').toLowerCase();
                    if (type === 'customer') converted++;
                }
            });
            
            html += `<p style="margin: 10px 0;"><strong>Converted:</strong> ${converted} of ${leadsInCell.length} (${((converted/leadsInCell.length)*100).toFixed(1)}%)</p>`;
            
            html += '<div class="table-container" style="max-height: 400px; overflow-y: auto;">';
            html += '<table><thead><tr>';
            html += '<th>Name</th><th>Date/Time</th><th>Source</th>';
            if (hasConvertedData) {
                html += '<th>Converted To</th><th>LTV</th>';
            } else {
                html += '<th>Type</th>';
            }
            html += '</tr></thead><tbody>';
            
            leadsInCell.forEach(lead => {
                html += '<tr>';
                html += `<td>${lead['First Name'] || ''} ${lead['Last Name'] || ''}</td>`;
                
                let dateField = null;
                if (hasConvertedData) {
                    dateField = parseDate(lead['Converted']);
                } else {
                    dateField = parseDate(lead['Join date']);
                }
                
                const formattedDate = dateField ? `${String(dateField.getMonth() + 1).padStart(2, '0')}/${String(dateField.getDate()).padStart(2, '0')}/${String(dateField.getFullYear()).slice(-2)}` : 'N/A';
                html += `<td>${formattedDate}</td>`;
                
                if (hasConvertedData) {
                    html += `<td>${lead['Lead source'] || 'Unknown'}</td>`;
                    const convertedTo = lead['Converted to'] || 'N/A';
                    const isConverted = convertedTo !== 'N/A';
                    html += `<td><span style="padding: 4px 8px; border-radius: 4px; background: ${isConverted ? '#d4edda' : '#f8d7da'}; color: ${isConverted ? '#155724' : '#721c24'};">${convertedTo}</span></td>`;
                    html += `<td>${formatCurrency(parseLTV(lead['LTV']))}</td>`;
                } else {
                    html += `<td>${lead['Aggregator'] || 'Unknown'}</td>`;
                    html += `<td>${lead['Type'] || 'N/A'}</td>`;
                }
                
                html += '</tr>';
            });
            
            html += '</tbody></table></div>';
            showModal(`Lead Details: ${day} at ${formatTime(hour)}`, html);
        }
        
        // MEMBERSHIP CANCELLATIONS - Appended to Memberships Tab
        function appendCancellationsToMemberships() {



            if (!membershipCancellationsData || membershipCancellationsData.length === 0) {

                return;
            }
            
            // Remove existing cancellations section if present
            let membershipsTab = document.getElementById('memberships');
            if (membershipsTab) {
                const existingCancellationsSection = membershipsTab.querySelector('#cancellationsSection');
                if (existingCancellationsSection) {
                    existingCancellationsSection.remove();
                }
            }
            
            // Parse cancellation data
            const cancellationsByType = {};
            const cancellationsByMonth = {};
            const cancellationReasons = {};
            const cancellationsByLocation = {};
            const dailyCancellations = {};
            const cancellationsByDayOfWeek = {
                'Sunday': 0, 'Monday': 0, 'Tuesday': 0, 'Wednesday': 0,
                'Thursday': 0, 'Friday': 0, 'Saturday': 0
            };
            const cancellationsByHour = {};
            const cancellationRateByMonth = {};
            
            let totalCancellations = filteredCancellations.length;
            let withReasons = 0;
            let withImprovements = 0;
            let mostRecentCancellation = null;
            let oldestCancellation = null;
            let totalCancellationValue = 0;
            
            // For financial calculations
            const typeChurnRates = {};
            const locationChurnRates = {};
            
            filteredCancellations.forEach(cancellation => {
                // Count cancellations with reasons
                const reason = (cancellation['Reason'] || '').trim();
                const improvements = (cancellation['Possible improvements'] || '').trim();
                
                // Track cancellation value by matching Customer Email to membership sales data
                const customerEmail = (cancellation['Email'] || cancellation['E-mail'] || cancellation['Customer Email'] || '').toLowerCase().trim();
                if (customerEmail && membershipsData) {
                    // Find the most recent membership for this customer
                    const matchingMemberships = membershipsData.filter(m => 
                        (m['Customer Email'] || '').toLowerCase().trim() === customerEmail
                    );
                    if (matchingMemberships.length > 0) {
                        // Sort by date and get most recent
                        const sortedMemberships = matchingMemberships.sort((a, b) => {
                            const dateA = a['Bought Date/Time (GMT)'] ? new Date(a['Bought Date/Time (GMT)']) : new Date(0);
                            const dateB = b['Bought Date/Time (GMT)'] ? new Date(b['Bought Date/Time (GMT)']) : new Date(0);
                            return dateB - dateA;
                        });
                        // Use Paid Amount as monthly value (these are monthly subscriptions)
                        totalCancellationValue += parseFloat(sortedMemberships[0]['Paid Amount']) || 0;
                    }
                }
                
                if (reason) {
                    withReasons++;
                    // Categorize reasons
                    const reasonKey = reason.split('>')[0].trim() || reason;
                    if (!cancellationReasons[reasonKey]) {
                        cancellationReasons[reasonKey] = 0;
                    }
                    cancellationReasons[reasonKey]++;
                }
                
                if (improvements) withImprovements++;
                
                // Parse cancellation date
                const cancelledAt = cancellation['Cancelled at'];
                let cancelDate = null;
                
                if (cancelledAt) {
                    // Try parsing the date (format: "2025-10-28, 1:53 PM")
                    const dateParts = cancelledAt.split(',')[0];
                    const timePart = cancelledAt.split(',')[1];
                    cancelDate = new Date(dateParts);
                    
                    if (!isNaN(cancelDate.getTime())) {
                        // Track most recent and oldest
                        if (!mostRecentCancellation || cancelDate > mostRecentCancellation) {
                            mostRecentCancellation = cancelDate;
                        }
                        if (!oldestCancellation || cancelDate < oldestCancellation) {
                            oldestCancellation = cancelDate;
                        }
                        
                        // Track by day of week
                        const dayNames = ['Sunday', 'Monday', 'Tuesday', 'Wednesday', 'Thursday', 'Friday', 'Saturday'];
                        const dayOfWeek = dayNames[cancelDate.getDay()];
                        cancellationsByDayOfWeek[dayOfWeek]++;
                        
                        // Track by hour (if time available)
                        if (timePart) {
                            const timeStr = timePart.trim();
                            const hourMatch = timeStr.match(/(\d+):/);
                            if (hourMatch) {
                                let hour = parseInt(hourMatch[1]);
                                // Convert to 24-hour if PM
                                if (timeStr.includes('PM') && hour !== 12) hour += 12;
                                if (timeStr.includes('AM') && hour === 12) hour = 0;
                                
                                if (!cancellationsByHour[hour]) {
                                    cancellationsByHour[hour] = 0;
                                }
                                cancellationsByHour[hour]++;
                            }
                        }
                        
                        // Track by month
                        const monthKey = `${cancelDate.getFullYear()}-${String(cancelDate.getMonth() + 1).padStart(2, '0')}`;
                        if (!cancellationsByMonth[monthKey]) {
                            cancellationsByMonth[monthKey] = 0;
                        }
                        cancellationsByMonth[monthKey]++;
                        
                        // Track by day
                        const dateKey = cancelDate.toISOString().split('T')[0];
                        if (!dailyCancellations[dateKey]) {
                            dailyCancellations[dateKey] = 0;
                        }
                        dailyCancellations[dateKey]++;
                    }
                }
                
                // Track by membership type
                const type = cancellation['Membership'] || 'Unknown';
                if (!cancellationsByType[type]) {
                    cancellationsByType[type] = 0;
                }
                cancellationsByType[type]++;
                
                // Track by location
                const location = cancellation['Home location'] || 'Unknown';
                if (!cancellationsByLocation[location]) {
                    cancellationsByLocation[location] = 0;
                }
                cancellationsByLocation[location]++;
            });
            
            // Calculate churn rates by type and location if we have sales data
            if (membershipsData && membershipsData.length > 0) {
                // Build customer location mapping from cancellations data
                const customerLocationMap = {};
                filteredCancellations.forEach(c => {
                    const email = c['Email'] || c['E-mail'] || c['Customer Email'];
                    const location = c['Home location'];
                    if (email && location) {
                        customerLocationMap[email.toLowerCase()] = location;
                    }
                });
                
                // Count sales by type
                const salesByType = {};
                membershipsData.forEach(m => {
                    const type = m['Membership Name'] || 'Unknown';
                    if (!salesByType[type]) salesByType[type] = 0;
                    salesByType[type]++;
                });
                
                // Calculate churn rate for each type
                Object.keys(cancellationsByType).forEach(type => {
                    if (salesByType[type]) {
                        typeChurnRates[type] = ((cancellationsByType[type] / salesByType[type]) * 100).toFixed(1);
                    }
                });
                
                // Count sales by location using customer location mapping
                const salesByLocation = {};
                membershipsData.forEach(m => {
                    const email = m['Customer Email'];
                    if (email) {
                        const loc = customerLocationMap[email.toLowerCase()] || m['Customer Home Location'] || 'Unknown';
                        if (!salesByLocation[loc]) salesByLocation[loc] = 0;
                        salesByLocation[loc]++;
                    } else {
                        const loc = m['Customer Home Location'] || 'Unknown';
                        if (!salesByLocation[loc]) salesByLocation[loc] = 0;
                        salesByLocation[loc]++;
                    }
                });
                
                // Calculate churn rate for each location
                Object.keys(cancellationsByLocation).forEach(loc => {
                    if (salesByLocation[loc] && salesByLocation[loc] > 0) {
                        locationChurnRates[loc] = ((cancellationsByLocation[loc] / salesByLocation[loc]) * 100).toFixed(1);
                    }
                });
                
                // Calculate cancellation rate by month
                const salesByMonth = {};
                membershipsData.forEach(m => {
                    const dateStr = m['Bought Date/Time (GMT)'];
                    if (dateStr) {
                        const date = new Date(dateStr);
                        if (!isNaN(date.getTime())) {
                            const monthKey = `${date.getFullYear()}-${String(date.getMonth() + 1).padStart(2, '0')}`;
                            if (!salesByMonth[monthKey]) salesByMonth[monthKey] = 0;
                            salesByMonth[monthKey]++;
                        }
                    }
                });
                
                Object.keys(cancellationsByMonth).forEach(month => {
                    if (salesByMonth[month]) {
                        cancellationRateByMonth[month] = ((cancellationsByMonth[month] / salesByMonth[month]) * 100).toFixed(1);
                    }
                });
            }
            
            // Sort data for charts
            const sortedTypes = Object.entries(cancellationsByType)
                .sort((a, b) => b[1] - a[1])
                .slice(0, 10);
            
            const sortedReasons = Object.entries(cancellationReasons)
                .sort((a, b) => b[1] - a[1])
                .slice(0, 10);
            
            const sortedLocations = Object.entries(cancellationsByLocation)
                .sort((a, b) => b[1] - a[1])
                .slice(0, 10);
            
            const sortedMonths = Object.keys(cancellationsByMonth).sort();
            
            // Filter out future months (months beyond current month)
            const today = new Date();
            const currentMonthKey = `${today.getFullYear()}-${String(today.getMonth() + 1).padStart(2, '0')}`;
            const filteredMonths = sortedMonths.filter(monthKey => monthKey <= currentMonthKey);
            
            const sortedDates = Object.keys(dailyCancellations).sort();
            
            // Find most common day of week
            const mostCommonDay = Object.entries(cancellationsByDayOfWeek)
                .sort((a, b) => b[1] - a[1])[0];
            
            // Find peak cancellation month
            const peakMonth = filteredMonths.length > 0 ? 
                Object.entries(cancellationsByMonth)
                    .sort((a, b) => b[1] - a[1])[0] : null;
            
            // Most at-risk type (highest churn rate)
            const atRiskType = Object.entries(typeChurnRates)
                .sort((a, b) => parseFloat(b[1]) - parseFloat(a[1]))[0];
            
            // Calculate churn rate
            let churnRateText = 'N/A';
            let churnRateValue = 0;
            if (membershipsData && membershipsData.length > 0) {
                churnRateValue = (totalCancellations / membershipsData.length) * 100;
                churnRateText = `${churnRateValue.toFixed(1)}%`;
            }
            
            // Calculate time span
            let timeSpanDays = 0;
            if (mostRecentCancellation && oldestCancellation) {
                timeSpanDays = Math.floor((mostRecentCancellation - oldestCancellation) / (1000 * 60 * 60 * 24));
            }







            let html = `
                <!-- Cancellations Section Divider -->
                <div style="margin: 60px 0 40px 0; border-top: 3px solid var(--accent); padding-top: 40px;">
                    <div style="text-align: center; margin-bottom: 30px;">
                        <h1 style="font-size: 2.2em; color: var(--primary); margin-bottom: 10px;">üìä Membership Cancellations</h1>
                        <p style="font-size: 1.1em; color: #666;">Comprehensive cancellation analytics, churn reasons, and retention insights</p>
                    </div>
                </div>
                
                <div id="cancellationsSection" class="section">
                    <h2>Membership Cancellations Overview</h2>
                    
                    <!-- Primary Metrics Grid -->
                    <div class="metrics-grid" style="grid-template-columns: repeat(7, 1fr); margin-bottom: 30px;">
                        <div class="metric-card compact" style="background: linear-gradient(135deg, rgba(244, 67, 54, 0.1), rgba(211, 47, 47, 0.05)); border-left: 4px solid #f44336;">
                            <div class="metric-label">üö´ Total Cancellations</div>
                            <div class="metric-value">${formatNumber(totalCancellations)}</div>
                            <div class="metric-subtext">Total memberships<br>cancelled</div>
                        </div>
                        
                        <div class="metric-card compact" style="background: linear-gradient(135deg, rgba(220, 53, 69, 0.1), rgba(200, 35, 51, 0.05)); border-left: 4px solid #dc3545;">
                            <div class="metric-label">üí∞ Lost Value</div>
                            <div class="metric-value">${formatCurrency(totalCancellationValue)}</div>
                            <div class="metric-subtext">Total revenue<br>from cancelled</div>
                        </div>
                        
                        <div class="metric-card compact" style="background: linear-gradient(135deg, rgba(255, 152, 0, 0.1), rgba(230, 81, 0, 0.05)); border-left: 4px solid #ff9800;">
                            <div class="metric-label">üìä Churn Rate</div>
                            <div class="metric-value">${churnRateText}</div>
                            <div class="metric-subtext">Cancellations vs<br>total sales</div>
                        </div>
                        
                        <div class="metric-card compact" style="background: linear-gradient(135deg, rgba(156, 39, 176, 0.1), rgba(123, 31, 162, 0.05)); border-left: 4px solid #9c27b0;">
                            <div class="metric-label">üí¨ With Reasons</div>
                            <div class="metric-value">${formatNumber(withReasons)}</div>
                            <div class="metric-subtext">${((withReasons / totalCancellations) * 100).toFixed(1)}% provided<br>cancellation reason</div>
                        </div>
                        
                        <div class="metric-card compact" style="background: linear-gradient(135deg, rgba(33, 150, 243, 0.1), rgba(13, 71, 161, 0.05)); border-left: 4px solid #2196f3;">
                            <div class="metric-label">üí° Feedback</div>
                            <div class="metric-value">${formatNumber(withImprovements)}</div>
                            <div class="metric-subtext">${((withImprovements / totalCancellations) * 100).toFixed(1)}% provided<br>improvement ideas</div>
                        </div>
                        
                        <div class="metric-card compact" style="background: linear-gradient(135deg, rgba(76, 175, 80, 0.1), rgba(56, 142, 60, 0.05)); border-left: 4px solid #4caf50;">
                            <div class="metric-label">üìà Avg/Month</div>
                            <div class="metric-value">${(totalCancellations / Math.max(filteredMonths.length, 1)).toFixed(1)}</div>
                            <div class="metric-subtext">Average cancellations<br>per month</div>
                        </div>
                        
                        <div class="metric-card compact" style="background: linear-gradient(135deg, rgba(103, 58, 183, 0.1), rgba(81, 45, 168, 0.05)); border-left: 4px solid #673ab7;">
                            <div class="metric-label">üìÖ Time Span</div>
                            <div class="metric-value">${timeSpanDays}</div>
                            <div class="metric-subtext">Days between<br>first & last</div>
                        </div>
                    </div>
                    
                    <!-- Key Insights Cards -->
                    <div class="metrics-grid" style="grid-template-columns: repeat(4, 1fr); margin-bottom: 40px;">
                        <div class="metric-card" style="background: linear-gradient(135deg, rgba(255, 87, 34, 0.1), rgba(244, 67, 54, 0.05)); border-left: 4px solid #ff5722;">
                            <div class="metric-label">üìÜ Most Common Day</div>
                            <div class="metric-value" style="font-size: 1.3em;">${mostCommonDay ? mostCommonDay[0] : 'N/A'}</div>
                            <div class="metric-subtext">${mostCommonDay ? formatNumber(mostCommonDay[1]) : 0} cancellations<br>on ${mostCommonDay ? mostCommonDay[0] + 's' : 'N/A'}</div>
                        </div>
                        
                        <div class="metric-card" style="background: linear-gradient(135deg, rgba(233, 30, 99, 0.1), rgba(194, 24, 91, 0.05)); border-left: 4px solid #e91e63;">
                            <div class="metric-label">üìä Peak Month</div>
                            <div class="metric-value" style="font-size: 1.1em;">${peakMonth ? new Date(peakMonth[0]).toLocaleDateString('en-US', { month: 'short', year: '2-digit' }) : 'N/A'}</div>
                            <div class="metric-subtext">${peakMonth ? formatNumber(peakMonth[1]) : 0} cancellations<br>in peak month</div>
                        </div>
                        
                        <div class="metric-card" style="background: linear-gradient(135deg, rgba(255, 193, 7, 0.1), rgba(255, 160, 0, 0.05)); border-left: 4px solid #ffc107;">
                            <div class="metric-label">‚ö†Ô∏è At-Risk Type</div>
                            <div class="metric-value" style="font-size: 1.1em;">${atRiskType ? atRiskType[0].substring(0, 15) + (atRiskType[0].length > 15 ? '...' : '') : 'N/A'}</div>
                            <div class="metric-subtext">${atRiskType ? atRiskType[1] + '% churn' : 'N/A'}<br>highest churn rate</div>
                        </div>
                        
                        <div class="metric-card" style="background: linear-gradient(135deg, rgba(0, 150, 136, 0.1), rgba(0, 121, 107, 0.05)); border-left: 4px solid #009688;">
                            <div class="metric-label">üìã Top Reason</div>
                            <div class="metric-value" style="font-size: 1.1em;">${sortedReasons.length > 0 ? sortedReasons[0][0].substring(0, 12) + '...' : 'N/A'}</div>
                            <div class="metric-subtext">${sortedReasons.length > 0 ? formatNumber(sortedReasons[0][1]) : 0} mentions<br>most common</div>
                        </div>
                    </div>
                </div>
                
                <!-- Cancellation Trends -->
                <div class="section">
                    <h2>Cancellation Trends Over Time</h2>
                    <div class="chart-grid" style="grid-template-columns: repeat(3, 1fr);">
                        <div class="chart-container">
                            <h3>Monthly Cancellations</h3>
                            <div class="chart-wrapper">
                                <canvas id="cancellationsMonthlyChart"></canvas>
                            </div>
                        </div>
                        
                        <div class="chart-container">
                            <h3>Cumulative Cancellations</h3>
                            <div class="chart-wrapper">
                                <canvas id="cancellationsCumulativeChart"></canvas>
                            </div>
                        </div>
                        
                        <div class="chart-container">
                            <h3>Cancellation Rate by Month</h3>
                            <div class="chart-wrapper">
                                <canvas id="cancellationRateChart"></canvas>
                            </div>
                        </div>
                    </div>
                </div>
                
                <!-- Day & Time Patterns -->
                <div class="section">
                    <h2>Cancellation Patterns by Day &amp; Time</h2>
                    <div class="chart-grid">
                        <div class="chart-container">
                            <h3>Cancellations by Day of Week</h3>
                            <div class="chart-wrapper">
                                <canvas id="cancellationsByDayChart"></canvas>
                            </div>
                        </div>
                        
                        <div class="chart-container">
                            <h3>Daily Cancellation Activity</h3>
                            <div class="chart-wrapper">
                                <canvas id="cancellationsDailyLineChart"></canvas>
                            </div>
                        </div>
                    </div>
                </div>
                
                <!-- Cancellation Reasons Analysis -->
                <div class="section">
                    <h2>Why Customers Cancel</h2>
                    <div class="charts-grid">
                        <div class="chart-container">
                            <h3>Top 10 Cancellation Reasons</h3>
                            <div id="cancellationReasonsList" style="padding: 10px;"></div>
                        </div>
                        
                        <div class="chart-container">
                            <h3>Feedback Response Rate</h3>
                            <div class="chart-wrapper">
                                <canvas id="feedbackRateChart"></canvas>
                            </div>
                        </div>
                    </div>
                </div>
                
                <!-- Membership Type Deep Dive -->
                <div class="section">
                    <h2>Cancellations by Membership Type</h2>
                    <div class="charts-grid">
                        <div class="chart-container">
                            <h3>Cancellations Count by Type</h3>
                            <div class="chart-wrapper">
                                <canvas id="cancellationsByTypeChart"></canvas>
                            </div>
                        </div>
                        
                        <div class="chart-container">
                            <h3>Churn Rate by Type</h3>
                            <div class="chart-wrapper">
                                <canvas id="churnRateByTypeChart"></canvas>
                            </div>
                        </div>
                    </div>
                </div>
                
                <!-- Location Analysis -->
                <div class="section">
                    <h2>Geographic Cancellation Analysis</h2>
                    <div class="chart-grid" style="grid-template-columns: repeat(3, 1fr);">
                        <div class="chart-container">
                            <h3>Cancellations by Location</h3>
                            <div class="chart-wrapper">
                                <canvas id="cancellationsByLocationChart"></canvas>
                            </div>
                        </div>
                        
                        <div class="chart-container">
                            <h3>Location Distribution</h3>
                            <div class="chart-wrapper">
                                <canvas id="cancellationsByLocationPieChart"></canvas>
                            </div>
                        </div>
                        
                        <div class="chart-container">
                            <h3>Churn Rate by Location</h3>
                            <div class="chart-wrapper">
                                <canvas id="churnRateByLocationChart"></canvas>
                            </div>
                        </div>
                    </div>
                </div>
                
                <!-- Comparison: Sales vs Cancellations -->
                <div class="section">
                    <h2>Sales vs Cancellations Comparison</h2>
                    <div class="chart-grid">
                        <div class="chart-container">
                            <h3>Monthly Sales vs Cancellations</h3>
                            <div class="chart-wrapper">
                                <canvas id="salesVsCancellationsChart"></canvas>
                            </div>
                        </div>
                        
                        <div class="chart-container">
                            <h3>Net Membership Growth</h3>
                            <div class="chart-wrapper">
                                <canvas id="netGrowthChart"></canvas>
                            </div>
                        </div>
                    </div>
                </div>
                
                <!-- Risk Analysis -->
                <div class="section">
                    <h2>Risk Analysis &amp; Insights</h2>
                    <div class="metrics-grid" style="grid-template-columns: repeat(3, 1fr); margin-bottom: 30px;">
                        <div class="metric-card" style="background: linear-gradient(135deg, rgba(244, 67, 54, 0.15), rgba(211, 47, 47, 0.08)); border: 2px solid #f44336;">
                            <div class="metric-label" style="font-size: 16px; font-weight: 700; color: #f44336;">üî¥ HIGH RISK</div>
                            <div class="metric-value" style="font-size: 1.5em; color: #f44336;">
                                ${Object.entries(typeChurnRates).filter(([t, r]) => parseFloat(r) > 20).length}
                            </div>
                            <div class="metric-subtext">Membership types with<br>churn rate > 20%</div>
                        </div>
                        
                        <div class="metric-card" style="background: linear-gradient(135deg, rgba(255, 152, 0, 0.15), rgba(230, 81, 0, 0.08)); border: 2px solid #ff9800;">
                            <div class="metric-label" style="font-size: 16px; font-weight: 700; color: #ff9800;">üü° MEDIUM RISK</div>
                            <div class="metric-value" style="font-size: 1.5em; color: #ff9800;">
                                ${Object.entries(typeChurnRates).filter(([t, r]) => parseFloat(r) >= 10 && parseFloat(r) <= 20).length}
                            </div>
                            <div class="metric-subtext">Membership types with<br>10-20% churn rate</div>
                        </div>
                        
                        <div class="metric-card" style="background: linear-gradient(135deg, rgba(76, 175, 80, 0.15), rgba(56, 142, 60, 0.08)); border: 2px solid #4caf50;">
                            <div class="metric-label" style="font-size: 16px; font-weight: 700; color: #4caf50;">üü¢ LOW RISK</div>
                            <div class="metric-value" style="font-size: 1.5em; color: #4caf50;">
                                ${Object.entries(typeChurnRates).filter(([t, r]) => parseFloat(r) < 10).length}
                            </div>
                            <div class="metric-subtext">Membership types with<br>churn rate < 10%</div>
                        </div>
                    </div>
                    
                    <div class="chart-grid">
                        <div class="chart-container">
                            <h3>Risk Matrix: Type Performance</h3>
                            <div class="chart-wrapper">
                                <canvas id="riskMatrixChart"></canvas>
                            </div>
                        </div>
                        
                        <div class="chart-container">
                            <h3>Cancellation Velocity (Trend)</h3>
                            <div class="chart-wrapper">
                                <canvas id="cancellationVelocityChart"></canvas>
                            </div>
                        </div>
                    </div>
                </div>
            `;
            
            // Append cancellations content to memberships tab WITHOUT destroying existing DOM
            // IMPORTANT: Using insertAdjacentHTML instead of innerHTML += to preserve chart canvas elements
            const membershipsDiv = document.getElementById('memberships');
            membershipsDiv.insertAdjacentHTML('beforeend', html);
            
            // Render Monthly Cancellations Chart
            const monthlyCanvas = document.getElementById('cancellationsMonthlyChart');
            if (monthlyCanvas) {
                destroyChart('cancellationsMonthly');
                const ctx = monthlyCanvas.getContext('2d');
                allCharts.cancellationsMonthly = new Chart(ctx, {
                    type: 'bar',
                    data: {
                        labels: sortedMonths.map(m => {
                            const [year, month] = m.split('-');
                            const date = new Date(year, parseInt(month) - 1);
                            return date.toLocaleDateString('en-US', { month: 'short', year: 'numeric' });
                        }),
                        datasets: [{
                            label: 'Cancellations',
                            data: sortedMonths.map(m => cancellationsByMonth[m]),
                            backgroundColor: 'rgba(244, 67, 54, 0.7)',
                            borderColor: 'rgba(244, 67, 54, 1)',
                            borderWidth: 2
                        }]
                    },
                    options: {
                        responsive: true,
                        maintainAspectRatio: false,
                        onClick: (event, elements) => {
                            if (elements.length > 0) {
                                const index = elements[0].index;
                                const month = sortedMonths[index];
                                const count = cancellationsByMonth[month];
                                showCancellationMonthDetails(month, count);
                            }
                        },
                        plugins: {
                            legend: { display: false }
                        },
                        scales: {
                            y: {
                                beginAtZero: true,
                                ticks: { precision: 0 }
                            }
                        }
                    }
                });
            }
            
            // Render Cumulative Cancellations Chart
            const cumulativeCanvas = document.getElementById('cancellationsCumulativeChart');
            if (cumulativeCanvas) {
                destroyChart('cancellationsCumulative');
                const ctx = cumulativeCanvas.getContext('2d');
                
                let cumulative = 0;
                const cumulativeData = sortedDates.map(date => {
                    cumulative += dailyCancellations[date];
                    return cumulative;
                });
                
                allCharts.cancellationsCumulative = new Chart(ctx, {
                    type: 'line',
                    data: {
                        labels: sortedDates,
                        datasets: [{
                            label: 'Cumulative Cancellations',
                            data: cumulativeData,
                            borderColor: 'rgba(244, 67, 54, 1)',
                            backgroundColor: 'rgba(244, 67, 54, 0.1)',
                            fill: true,
                            tension: 0.4,
                            borderWidth: 3
                        }]
                    },
                    options: {
                        responsive: true,
                        maintainAspectRatio: false,
                        plugins: {
                            legend: { display: false }
                        },
                        scales: {
                            y: {
                                beginAtZero: true,
                                ticks: { precision: 0 }
                            }
                        }
                    }
                });
            }
            
            
            // Render Cancellation Reasons List with Sentiment
            const reasonsList = document.getElementById('cancellationReasonsList');
            if (reasonsList && sortedReasons.length > 0) {
                const top10 = sortedReasons.slice(0, 10);
                let html = '<div style="max-height: 500px; overflow-y: auto;">';
                
                top10.forEach((reason, index) => {
                    const [reasonText, count] = reason;
                    const sentiment = analyzeSentiment(reasonText);
                    const percentage = totalCancellations > 0 ? ((count / totalCancellations) * 100).toFixed(1) : 0;
                    
                    html += `
                        <div style="padding: 12px; margin-bottom: 10px; background: ${index % 2 === 0 ? '#f8f9fa' : 'white'}; border-radius: 8px; border-left: 4px solid ${sentiment.color}; cursor: pointer;" 
                             onclick="showCancellationReasonDetails('${reasonText.replace(/'/g, "\\'")}', ${count})">
                            <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 5px;">
                                <div style="flex: 1;">
                                    <span style="font-weight: bold; color: #013160;">#${index + 1}</span>
                                    <span style="font-size: 14px; color: #333; margin-left: 10px;">${reasonText.length > 50 ? reasonText.substring(0, 47) + '...' : reasonText}</span>
                                </div>
                                <div style="display: flex; align-items: center; gap: 15px;">
                                    <span style="font-size: 20px;" title="${sentiment.sentiment}">${sentiment.emoji}</span>
                                    <div style="text-align: right;">
                                        <div style="font-size: 18px; font-weight: bold; color: ${sentiment.color};">${count}</div>
                                        <div style="font-size: 11px; color: #666;">${percentage}%</div>
                                    </div>
                                </div>
                            </div>
                            <div style="margin-top: 5px;">
                                <div style="background: #e0e0e0; height: 6px; border-radius: 3px; overflow: hidden;">
                                    <div style="background: ${sentiment.color}; height: 100%; width: ${percentage}%; transition: width 0.3s ease;"></div>
                                </div>
                            </div>
                        </div>
                    `;
                });
                
                html += '</div>';
                html += '<p style="margin-top: 15px; font-size: 12px; color: #666; font-style: italic;">üí° Click on any reason to see detailed customer information and feedback</p>';
                reasonsList.innerHTML = html;
            }
            
            // Render Cancellation Reasons Pie Chart
            const reasonsPieCanvas = document.getElementById('cancellationReasonsPieChart');
            if (reasonsPieCanvas && sortedReasons.length > 0) {
                destroyChart('cancellationReasonsPie');
                const ctx = reasonsPieCanvas.getContext('2d');
                
                const colors = [
                    'rgba(244, 67, 54, 0.8)',
                    'rgba(233, 30, 99, 0.8)',
                    'rgba(156, 39, 176, 0.8)',
                    'rgba(103, 58, 183, 0.8)',
                    'rgba(63, 81, 181, 0.8)',
                    'rgba(33, 150, 243, 0.8)',
                    'rgba(3, 169, 244, 0.8)',
                    'rgba(0, 188, 212, 0.8)',
                    'rgba(0, 150, 136, 0.8)',
                    'rgba(76, 175, 80, 0.8)'
                ];
                
                allCharts.cancellationReasonsPie = new Chart(ctx, {
                    type: 'doughnut',
                    data: {
                        labels: sortedReasons.map(r => {
                            const label = r[0];
                            return label.length > 30 ? label.substring(0, 27) + '...' : label;
                        }),
                        datasets: [{
                            data: sortedReasons.map(r => r[1]),
                            backgroundColor: colors.slice(0, sortedReasons.length),
                            borderWidth: 2,
                            borderColor: '#fff'
                        }]
                    },
                    options: {
                        responsive: true,
                        maintainAspectRatio: false,
                        plugins: {
                            legend: {
                                position: 'right',
                                labels: { boxWidth: 15, padding: 10 }
                            }
                        }
                    }
                });
            }
            
            // Render Cancellations by Type Bar Chart
            const typeCanvas = document.getElementById('cancellationsByTypeChart');
            if (typeCanvas) {
                destroyChart('cancellationsByType');
                const ctx = typeCanvas.getContext('2d');
                allCharts.cancellationsByType = new Chart(ctx, {
                    type: 'bar',
                    data: {
                        labels: sortedTypes.map(t => t[0]),
                        datasets: [{
                            label: 'Cancellations',
                            data: sortedTypes.map(t => t[1]),
                            backgroundColor: 'rgba(255, 152, 0, 0.7)',
                            borderColor: 'rgba(255, 152, 0, 1)',
                            borderWidth: 2
                        }]
                    },
                    options: {
                        responsive: true,
                        maintainAspectRatio: false,
                        onClick: (event, elements) => {
                            if (elements.length > 0) {
                                const index = elements[0].index;
                                const type = sortedTypes[index][0];
                                const count = sortedTypes[index][1];
                                showCancellationTypeDetails(type, count);
                            }
                        },
                        plugins: {
                            legend: { display: false }
                        },
                        scales: {
                            y: {
                                beginAtZero: true,
                                ticks: { precision: 0 }
                            }
                        }
                    }
                });
            }
            
            // Render Cancellations by Type Pie Chart
            const typePieCanvas = document.getElementById('cancellationsByTypePieChart');
            if (typePieCanvas) {
                destroyChart('cancellationsByTypePie');
                const ctx = typePieCanvas.getContext('2d');
                
                const colors = [
                    'rgba(255, 152, 0, 0.8)',
                    'rgba(255, 193, 7, 0.8)',
                    'rgba(255, 235, 59, 0.8)',
                    'rgba(205, 220, 57, 0.8)',
                    'rgba(139, 195, 74, 0.8)',
                    'rgba(76, 175, 80, 0.8)',
                    'rgba(0, 150, 136, 0.8)',
                    'rgba(0, 188, 212, 0.8)',
                    'rgba(3, 169, 244, 0.8)',
                    'rgba(33, 150, 243, 0.8)'
                ];
                
                allCharts.cancellationsByTypePie = new Chart(ctx, {
                    type: 'pie',
                    data: {
                        labels: sortedTypes.map(t => t[0]),
                        datasets: [{
                            data: sortedTypes.map(t => t[1]),
                            backgroundColor: colors.slice(0, sortedTypes.length),
                            borderWidth: 2,
                            borderColor: '#fff'
                        }]
                    },
                    options: {
                        responsive: true,
                        maintainAspectRatio: false,
                        plugins: {
                            legend: {
                                position: 'right',
                                labels: { boxWidth: 15, padding: 10 }
                            }
                        }
                    }
                });
            }
            
            // Render Cancellations by Location Bar Chart
            const locationCanvas = document.getElementById('cancellationsByLocationChart');
            if (locationCanvas) {
                destroyChart('cancellationsByLocation');
                const ctx = locationCanvas.getContext('2d');
                allCharts.cancellationsByLocation = new Chart(ctx, {
                    type: 'bar',
                    data: {
                        labels: sortedLocations.map(l => l[0]),
                        datasets: [{
                            label: 'Cancellations',
                            data: sortedLocations.map(l => l[1]),
                            backgroundColor: 'rgba(33, 150, 243, 0.7)',
                            borderColor: 'rgba(33, 150, 243, 1)',
                            borderWidth: 2
                        }]
                    },
                    options: {
                        responsive: true,
                        maintainAspectRatio: false,
                        onClick: (event, elements) => {
                            if (elements.length > 0) {
                                const index = elements[0].index;
                                const location = sortedLocations[index][0];
                                const count = sortedLocations[index][1];
                                showCancellationLocationDetails(location, count);
                            }
                        },
                        plugins: {
                            legend: { display: false }
                        },
                        scales: {
                            y: {
                                beginAtZero: true,
                                ticks: { precision: 0 }
                            }
                        }
                    }
                });
            }
            
            // Render Cancellations by Location Pie Chart
            const locationPieCanvas = document.getElementById('cancellationsByLocationPieChart');
            if (locationPieCanvas) {
                destroyChart('cancellationsByLocationPie');
                const ctx = locationPieCanvas.getContext('2d');
                
                const colors = [
                    'rgba(33, 150, 243, 0.8)',
                    'rgba(63, 81, 181, 0.8)',
                    'rgba(103, 58, 183, 0.8)',
                    'rgba(156, 39, 176, 0.8)',
                    'rgba(233, 30, 99, 0.8)',
                    'rgba(244, 67, 54, 0.8)',
                    'rgba(255, 87, 34, 0.8)',
                    'rgba(255, 152, 0, 0.8)',
                    'rgba(255, 193, 7, 0.8)',
                    'rgba(205, 220, 57, 0.8)'
                ];
                
                allCharts.cancellationsByLocationPie = new Chart(ctx, {
                    type: 'doughnut',
                    data: {
                        labels: sortedLocations.map(l => l[0]),
                        datasets: [{
                            data: sortedLocations.map(l => l[1]),
                            backgroundColor: colors.slice(0, sortedLocations.length),
                            borderWidth: 2,
                            borderColor: '#fff'
                        }]
                    },
                    options: {
                        responsive: true,
                        maintainAspectRatio: false,
                        plugins: {
                            legend: {
                                position: 'right',
                                labels: { boxWidth: 15, padding: 10 }
                            }
                        }
                    }
                });
            }
            
            // Render Cancellation Rate by Month Chart
            const rateCanvas = document.getElementById('cancellationRateChart');
            if (rateCanvas && Object.keys(cancellationRateByMonth).length > 0) {
                destroyChart('cancellationRate');
                const ctx = rateCanvas.getContext('2d');
                const sortedRateMonths = Object.keys(cancellationRateByMonth).sort();
                allCharts.cancellationRate = new Chart(ctx, {
                    type: 'line',
                    data: {
                        labels: sortedRateMonths.map(m => {
                            const [year, month] = m.split('-');
                            const date = new Date(year, parseInt(month) - 1);
                            return date.toLocaleDateString('en-US', { month: 'short', year: 'numeric' });
                        }),
                        datasets: [{
                            label: 'Churn Rate %',
                            data: sortedRateMonths.map(m => parseFloat(cancellationRateByMonth[m])),
                            borderColor: 'rgba(255, 152, 0, 1)',
                            backgroundColor: 'rgba(255, 152, 0, 0.1)',
                            fill: true,
                            tension: 0.4,
                            borderWidth: 3
                        }]
                    },
                    options: {
                        responsive: true,
                        maintainAspectRatio: false,
                        plugins: {
                            legend: { display: false }
                        },
                        scales: {
                            y: {
                                beginAtZero: true,
                                ticks: { callback: value => value + '%' }
                            }
                        }
                    }
                });
            }
            
            // Render Cancellations by Day of Week Chart
            const dayCanvas = document.getElementById('cancellationsByDayChart');
            if (dayCanvas) {
                destroyChart('cancellationsByDay');
                const ctx = dayCanvas.getContext('2d');
                const dayOrder = ['Monday', 'Tuesday', 'Wednesday', 'Thursday', 'Friday', 'Saturday', 'Sunday'];
                allCharts.cancellationsByDay = new Chart(ctx, {
                    type: 'bar',
                    data: {
                        labels: dayOrder,
                        datasets: [{
                            label: 'Cancellations',
                            data: dayOrder.map(day => cancellationsByDayOfWeek[day]),
                            backgroundColor: 'rgba(156, 39, 176, 0.7)',
                            borderColor: 'rgba(156, 39, 176, 1)',
                            borderWidth: 2
                        }]
                    },
                    options: {
                        responsive: true,
                        maintainAspectRatio: false,
                        plugins: {
                            legend: { display: false }
                        },
                        scales: {
                            y: {
                                beginAtZero: true,
                                ticks: { precision: 0 }
                            }
                        }
                    }
                });
            }
            
            // Render Daily Activity Line Chart
            const dailyLineCanvas = document.getElementById('cancellationsDailyLineChart');
            if (dailyLineCanvas) {
                destroyChart('cancellationsDailyLine');
                const ctx = dailyLineCanvas.getContext('2d');
                allCharts.cancellationsDailyLine = new Chart(ctx, {
                    type: 'line',
                    data: {
                        labels: sortedDates.map(d => new Date(d).toLocaleDateString('en-US', { month: 'short', day: 'numeric' })),
                        datasets: [{
                            label: 'Daily Cancellations',
                            data: sortedDates.map(d => dailyCancellations[d]),
                            borderColor: 'rgba(33, 150, 243, 1)',
                            backgroundColor: 'rgba(33, 150, 243, 0.1)',
                            fill: true,
                            tension: 0.3,
                            borderWidth: 2
                        }]
                    },
                    options: {
                        responsive: true,
                        maintainAspectRatio: false,
                        plugins: {
                            legend: { display: false }
                        },
                        scales: {
                            y: {
                                beginAtZero: true,
                                ticks: { precision: 0 }
                            }
                        }
                    }
                });
            }
            
            // Render Feedback Rate Chart
            const feedbackCanvas = document.getElementById('feedbackRateChart');
            if (feedbackCanvas) {
                destroyChart('feedbackRate');
                const ctx = feedbackCanvas.getContext('2d');
                allCharts.feedbackRate = new Chart(ctx, {
                    type: 'doughnut',
                    data: {
                        labels: ['With Reason', 'No Reason', 'With Improvements', 'No Improvements'],
                        datasets: [{
                            data: [withReasons, totalCancellations - withReasons, withImprovements, totalCancellations - withImprovements],
                            backgroundColor: [
                                'rgba(76, 175, 80, 0.8)',
                                'rgba(244, 67, 54, 0.8)',
                                'rgba(33, 150, 243, 0.8)',
                                'rgba(255, 152, 0, 0.8)'
                            ],
                            borderWidth: 2,
                            borderColor: '#fff'
                        }]
                    },
                    options: {
                        responsive: true,
                        maintainAspectRatio: false,
                        plugins: {
                            legend: {
                                position: 'bottom',
                                labels: { boxWidth: 15, padding: 10 }
                            }
                        }
                    }
                });
            }
            
            // Render Churn Rate by Type Chart
            const churnTypeCanvas = document.getElementById('churnRateByTypeChart');
            if (churnTypeCanvas && Object.keys(typeChurnRates).length > 0) {
                destroyChart('churnRateByType');
                const ctx = churnTypeCanvas.getContext('2d');
                const sortedChurnTypes = Object.entries(typeChurnRates)
                    .sort((a, b) => parseFloat(b[1]) - parseFloat(a[1]))
                    .slice(0, 10);
                allCharts.churnRateByType = new Chart(ctx, {
                    type: 'bar',
                    data: {
                        labels: sortedChurnTypes.map(t => t[0]),
                        datasets: [{
                            label: 'Churn Rate %',
                            data: sortedChurnTypes.map(t => parseFloat(t[1])),
                            backgroundColor: sortedChurnTypes.map(t => {
                                const rate = parseFloat(t[1]);
                                if (rate > 20) return 'rgba(244, 67, 54, 0.7)';
                                if (rate >= 10) return 'rgba(255, 152, 0, 0.7)';
                                return 'rgba(76, 175, 80, 0.7)';
                            }),
                            borderColor: sortedChurnTypes.map(t => {
                                const rate = parseFloat(t[1]);
                                if (rate > 20) return 'rgba(244, 67, 54, 1)';
                                if (rate >= 10) return 'rgba(255, 152, 0, 1)';
                                return 'rgba(76, 175, 80, 1)';
                            }),
                            borderWidth: 2
                        }]
                    },
                    options: {
                        responsive: true,
                        maintainAspectRatio: false,
                        indexAxis: 'y',
                        plugins: {
                            legend: { display: false }
                        },
                        scales: {
                            x: {
                                beginAtZero: true,
                                ticks: { callback: value => value + '%' }
                            }
                        }
                    }
                });
            }
            
            // Render Churn Rate by Location Chart
            const churnLocCanvas = document.getElementById('churnRateByLocationChart');
            if (churnLocCanvas && Object.keys(locationChurnRates).length > 0) {
                destroyChart('churnRateByLocation');
                const ctx = churnLocCanvas.getContext('2d');
                const sortedChurnLocs = Object.entries(locationChurnRates)
                    .sort((a, b) => parseFloat(b[1]) - parseFloat(a[1]))
                    .slice(0, 10);
                allCharts.churnRateByLocation = new Chart(ctx, {
                    type: 'bar',
                    data: {
                        labels: sortedChurnLocs.map(l => l[0]),
                        datasets: [{
                            label: 'Churn Rate %',
                            data: sortedChurnLocs.map(l => parseFloat(l[1])),
                            backgroundColor: 'rgba(63, 81, 181, 0.7)',
                            borderColor: 'rgba(63, 81, 181, 1)',
                            borderWidth: 2
                        }]
                    },
                    options: {
                        responsive: true,
                        maintainAspectRatio: false,
                        plugins: {
                            legend: { display: false }
                        },
                        scales: {
                            y: {
                                beginAtZero: true,
                                ticks: { callback: value => value + '%' }
                            }
                        }
                    }
                });
            }
            
            // Render Sales vs Cancellations Chart (if sales data available)
            const salesVsCanvas = document.getElementById('salesVsCancellationsChart');
            if (salesVsCanvas && membershipsData && membershipsData.length > 0) {
                destroyChart('salesVsCancellations');
                const ctx = salesVsCanvas.getContext('2d');
                
                // Calculate sales by month
                const salesByMonth = {};
                membershipsData.forEach(m => {
                    const dateStr = m['Bought Date/Time (GMT)'];
                    if (dateStr) {
                        const date = new Date(dateStr);
                        if (!isNaN(date.getTime())) {
                            const monthKey = `${date.getFullYear()}-${String(date.getMonth() + 1).padStart(2, '0')}`;
                            if (!salesByMonth[monthKey]) salesByMonth[monthKey] = 0;
                            salesByMonth[monthKey]++;
                        }
                    }
                });
                
                const allMonths = [...new Set([...Object.keys(salesByMonth), ...sortedMonths])].sort();
                
                allCharts.salesVsCancellations = new Chart(ctx, {
                    type: 'line',
                    data: {
                        labels: allMonths.map(m => {
                            const [year, month] = m.split('-');
                            const date = new Date(year, parseInt(month) - 1);
                            return date.toLocaleDateString('en-US', { month: 'short', year: 'numeric' });
                        }),
                        datasets: [
                            {
                                label: 'New Sales',
                                data: allMonths.map(m => salesByMonth[m] || 0),
                                borderColor: 'rgba(76, 175, 80, 1)',
                                backgroundColor: 'rgba(76, 175, 80, 0.1)',
                                fill: false,
                                tension: 0.4,
                                borderWidth: 3
                            },
                            {
                                label: 'Cancellations',
                                data: allMonths.map(m => cancellationsByMonth[m] || 0),
                                borderColor: 'rgba(244, 67, 54, 1)',
                                backgroundColor: 'rgba(244, 67, 54, 0.1)',
                                fill: false,
                                tension: 0.4,
                                borderWidth: 3
                            }
                        ]
                    },
                    options: {
                        responsive: true,
                        maintainAspectRatio: false,
                        plugins: {
                            legend: { display: true, position: 'top' }
                        },
                        scales: {
                            y: {
                                beginAtZero: true,
                                ticks: { precision: 0 }
                            }
                        }
                    }
                });
            }
            
            // Render Net Growth Chart
            const netGrowthCanvas = document.getElementById('netGrowthChart');
            if (netGrowthCanvas && membershipsData && membershipsData.length > 0) {
                destroyChart('netGrowth');
                const ctx = netGrowthCanvas.getContext('2d');
                
                // Calculate sales by month
                const salesByMonth = {};
                membershipsData.forEach(m => {
                    const dateStr = m['Bought Date/Time (GMT)'];
                    if (dateStr) {
                        const date = new Date(dateStr);
                        if (!isNaN(date.getTime())) {
                            const monthKey = `${date.getFullYear()}-${String(date.getMonth() + 1).padStart(2, '0')}`;
                            if (!salesByMonth[monthKey]) salesByMonth[monthKey] = 0;
                            salesByMonth[monthKey]++;
                        }
                    }
                });
                
                const allMonths = [...new Set([...Object.keys(salesByMonth), ...sortedMonths])].sort();
                const netGrowth = allMonths.map(m => (salesByMonth[m] || 0) - (cancellationsByMonth[m] || 0));
                
                allCharts.netGrowth = new Chart(ctx, {
                    type: 'bar',
                    data: {
                        labels: allMonths.map(m => {
                            const [year, month] = m.split('-');
                            const date = new Date(year, parseInt(month) - 1);
                            return date.toLocaleDateString('en-US', { month: 'short', year: 'numeric' });
                        }),
                        datasets: [{
                            label: 'Net Membership Growth',
                            data: netGrowth,
                            backgroundColor: netGrowth.map(n => n >= 0 ? 'rgba(76, 175, 80, 0.7)' : 'rgba(244, 67, 54, 0.7)'),
                            borderColor: netGrowth.map(n => n >= 0 ? 'rgba(76, 175, 80, 1)' : 'rgba(244, 67, 54, 1)'),
                            borderWidth: 2
                        }]
                    },
                    options: {
                        responsive: true,
                        maintainAspectRatio: false,
                        plugins: {
                            legend: { display: false }
                        },
                        scales: {
                            y: {
                                ticks: { precision: 0 }
                            }
                        }
                    }
                });
            }
            
            // Render Risk Matrix Chart
            const riskCanvas = document.getElementById('riskMatrixChart');
            if (riskCanvas && Object.keys(typeChurnRates).length > 0) {
                destroyChart('riskMatrix');
                const ctx = riskCanvas.getContext('2d');
                
                const bubbleData = Object.entries(typeChurnRates).map(([type, rate]) => ({
                    x: cancellationsByType[type] || 0,
                    y: parseFloat(rate),
                    r: Math.sqrt((cancellationsByType[type] || 0) * 2),
                    label: type
                }));
                
                allCharts.riskMatrix = new Chart(ctx, {
                    type: 'bubble',
                    data: {
                        datasets: [{
                            label: 'Membership Types',
                            data: bubbleData,
                            backgroundColor: bubbleData.map(d => {
                                if (d.y > 20) return 'rgba(244, 67, 54, 0.6)';
                                if (d.y >= 10) return 'rgba(255, 152, 0, 0.6)';
                                return 'rgba(76, 175, 80, 0.6)';
                            }),
                            borderColor: bubbleData.map(d => {
                                if (d.y > 20) return 'rgba(244, 67, 54, 1)';
                                if (d.y >= 10) return 'rgba(255, 152, 0, 1)';
                                return 'rgba(76, 175, 80, 1)';
                            }),
                            borderWidth: 2
                        }]
                    },
                    options: {
                        responsive: true,
                        maintainAspectRatio: false,
                        plugins: {
                            legend: { display: false },
                            tooltip: {
                                callbacks: {
                                    label: (context) => {
                                        const point = bubbleData[context.dataIndex];
                                        return `${point.label}: ${point.x} cancellations (${point.y}% churn)`;
                                    }
                                }
                            }
                        },
                        scales: {
                            x: {
                                title: { display: true, text: 'Number of Cancellations' },
                                beginAtZero: true
                            },
                            y: {
                                title: { display: true, text: 'Churn Rate %' },
                                beginAtZero: true,
                                ticks: { callback: value => value + '%' }
                            }
                        }
                    }
                });
            }
            
            // Render Cancellation Velocity Chart
            const velocityCanvas = document.getElementById('cancellationVelocityChart');
            if (velocityCanvas && filteredMonths.length > 0) {
                destroyChart('cancellationVelocity');
                const ctx = velocityCanvas.getContext('2d');
                
                // Calculate 3-month moving average (or use actual data if less than 3 months)
                const movingAvg = sortedMonths.map((month, idx) => {
                    if (filteredMonths.length < 3 || idx < 2) {
                        // If we don't have enough data for moving average, just use the actual value
                        return cancellationsByMonth[month];
                    }
                    const sum = cancellationsByMonth[sortedMonths[idx]] + 
                               cancellationsByMonth[sortedMonths[idx-1]] + 
                               cancellationsByMonth[sortedMonths[idx-2]];
                    return sum / 3;
                });
                
                allCharts.cancellationVelocity = new Chart(ctx, {
                    type: 'line',
                    data: {
                        labels: sortedMonths.map(m => {
                            const [year, month] = m.split('-');
                            const date = new Date(year, parseInt(month) - 1);
                            return date.toLocaleDateString('en-US', { month: 'short', year: 'numeric' });
                        }),
                        datasets: [
                            {
                                label: 'Actual Cancellations',
                                data: sortedMonths.map(m => cancellationsByMonth[m]),
                                borderColor: 'rgba(244, 67, 54, 0.8)',
                                backgroundColor: 'rgba(244, 67, 54, 0.1)',
                                fill: false,
                                tension: 0.1,
                                borderWidth: 2,
                                pointRadius: 4,
                                pointHoverRadius: 6
                            },
                            ...(filteredMonths.length >= 3 ? [{
                                label: '3-Month Moving Avg',
                                data: movingAvg,
                                borderColor: 'rgba(33, 150, 243, 1)',
                                backgroundColor: 'rgba(33, 150, 243, 0.1)',
                                fill: false,
                                tension: 0.4,
                                borderWidth: 3,
                                pointRadius: 0
                            }] : [])
                        ]
                    },
                    options: {
                        responsive: true,
                        maintainAspectRatio: false,
                        plugins: {
                            legend: { 
                                display: true, 
                                position: 'top'
                            },
                            tooltip: {
                                callbacks: {
                                    label: function(context) {
                                        return context.dataset.label + ': ' + context.parsed.y.toFixed(1);
                                    }
                                }
                            }
                        },
                        scales: {
                            y: {
                                beginAtZero: true,
                                ticks: { precision: 0 }
                            }
                        }
                    }
                });
            }

        }
        
        // Show Cancellation Reason Details Modal
        function showCancellationReasonDetails(reason, count) {
            const cancellationsWithReason = filteredCancellations.filter(c => {
                const cancelReason = (c['Reason'] || '').trim();
                const reasonKey = cancelReason.split('>')[0].trim() || cancelReason;
                return reasonKey === reason;
            });
            
            // Get detailed info with membership data
            const detailedCancellations = cancellationsWithReason.map(c => {
                const membershipId = c['Membership ID'];
                let membershipValue = 0;
                let membershipType = c['Membership'] || 'Unknown';
                
                // Try to find matching membership by ID first
                if (membershipId && membershipsData) {
                    const matchingMembership = membershipsData.find(m => m['Membership ID'] === membershipId);
                    if (matchingMembership) {
                        membershipValue = parseFloat(matchingMembership['Paid Amount']) || 0;
                        membershipType = matchingMembership['Membership Name'] || membershipType;
                    }
                }
                
                // If no value found, try to match by email and get most recent membership
                if (membershipValue === 0 && membershipsData) {
                    const email = (c['Email'] || c['E-mail'] || c['Customer Email'] || '').toLowerCase().trim();
                    if (email) {
                        const customerMemberships = membershipsData
                            .filter(m => (m['Customer Email'] || '').toLowerCase().trim() === email)
                            .sort((a, b) => {
                                const dateA = a['Bought Date/Time (GMT)'] ? new Date(a['Bought Date/Time (GMT)']) : new Date(0);
                                const dateB = b['Bought Date/Time (GMT)'] ? new Date(b['Bought Date/Time (GMT)']) : new Date(0);
                                return dateB - dateA;
                            });
                        
                        if (customerMemberships.length > 0) {
                            membershipValue = parseFloat(customerMemberships[0]['Paid Amount']) || 0;
                            membershipType = customerMemberships[0]['Membership Name'] || membershipType;
                        }
                    }
                }
                
                // Try different possible field names for customer name
                const firstName = c['First name'] || c['First Name'] || c['Customer First Name'] || '';
                const lastName = c['Last name'] || c['Last Name'] || c['Customer Last Name'] || '';
                const fullName = c['Customer Name'] || c['Name'] || '';
                const customerName = fullName || `${firstName} ${lastName}`.trim();
                
                return {
                    customerName: customerName || 'Unknown',
                    email: c['Email'] || c['E-mail'] || c['Customer Email'] || 'N/A',
                    membership: membershipType,
                    value: membershipValue,
                    cancelledAt: c['Cancelled at'] || 'N/A',
                    location: c['Home location'] || 'Unknown',
                    fullReason: c['Reason'] || reason,
                    improvements: c['Possible improvements'] || 'None provided'
                };
            });
            
            // Sort by value descending
            detailedCancellations.sort((a, b) => b.value - a.value);
            
            const totalValue = detailedCancellations.reduce((sum, c) => sum + c.value, 0);
            const avgValue = totalValue / count;
            
            const sentiment = analyzeSentiment(reason);
            
            let content = `
                <div class="modal-highlight" style="border-left: 4px solid ${sentiment.color};">
                    <div style="display: flex; justify-content: space-between; align-items: start; margin-bottom: 10px;">
                        <div style="flex: 1;">
                            <strong>Reason:</strong> ${reason}<br>
                            <strong>Sentiment:</strong> ${sentiment.emoji} ${sentiment.sentiment}
                        </div>
                        <div style="text-align: right;">
                            <div style="font-size: 24px; font-weight: bold; color: ${sentiment.color};">${count}</div>
                            <div style="font-size: 12px; color: #666;">cancellations</div>
                        </div>
                    </div>
                    <strong>Total Lost Revenue:</strong> ${formatCurrency(totalValue)}<br>
                    <strong>Average Per Cancellation:</strong> ${formatCurrency(avgValue)}
                </div>
                
                <div class="modal-section">
                    <h4>Cancelled Customers (${count})</h4>
                    <table class="modal-table">
                        <thead>
                            <tr>
                                <th>Customer</th>
                                <th>Membership</th>
                                <th>Value</th>
                                <th>Location</th>
                                <th>Cancelled</th>
                                <th>Feedback</th>
                            </tr>
                        </thead>
                        <tbody>
                            ${detailedCancellations.map(c => {
                                const momenceLink = getMomenceCustomerLink(c.email, c.customerName);
                                return `
                                <tr>
                                    <td>
                                        <strong>${c.customerName || 'Unknown'}</strong>${momenceLink}<br>
                                        <span style="font-size: 11px; color: #666;">${c.email}</span>
                                    </td>
                                    <td>${c.membership}</td>
                                    <td><strong>${formatCurrency(c.value)}</strong></td>
                                    <td>${c.location}</td>
                                    <td style="font-size: 12px;">${c.cancelledAt}</td>
                                    <td style="font-size: 12px; max-width: 200px;">${c.improvements.substring(0, 100)}${c.improvements.length > 100 ? '...' : ''}</td>
                                </tr>
                            `;
                            }).join('')}
                        </tbody>
                    </table>
                </div>
            `;
            
            showModal('Cancellation Reason Details', content);
        }
        
        // Show Cancellation Type Details Modal
        function showCancellationTypeDetails(type, count) {
            const cancellationsOfType = filteredCancellations.filter(c => {
                const membershipType = c['Membership'] || 'Unknown';
                return membershipType === type;
            });
            
            const detailedCancellations = cancellationsOfType.map(c => {
                let membershipValue = 0;
                
                // Match by Customer Email instead of Membership ID
                const customerEmail = (c['Email'] || c['E-mail'] || c['Customer Email'] || '').toLowerCase().trim();
                if (customerEmail && membershipsData) {
                    const matchingMemberships = membershipsData.filter(m => 
                        (m['Customer Email'] || '').toLowerCase().trim() === customerEmail
                    );
                    if (matchingMemberships.length > 0) {
                        // Sort by date and get most recent
                        const sortedMemberships = matchingMemberships.sort((a, b) => {
                            const dateA = a['Bought Date/Time (GMT)'] ? new Date(a['Bought Date/Time (GMT)']) : new Date(0);
                            const dateB = b['Bought Date/Time (GMT)'] ? new Date(b['Bought Date/Time (GMT)']) : new Date(0);
                            return dateB - dateA;
                        });
                        // Use Paid Amount as monthly value
                        membershipValue = parseFloat(sortedMemberships[0]['Paid Amount']) || 0;
                    }
                }
                
                // Try different possible field names for customer name
                const firstName = c['First name'] || c['First Name'] || c['Customer First Name'] || '';
                const lastName = c['Last name'] || c['Last Name'] || c['Customer Last Name'] || '';
                const fullName = c['Customer Name'] || c['Name'] || '';
                const customerName = fullName || `${firstName} ${lastName}`.trim();
                
                return {
                    customerName: customerName || 'Unknown',
                    email: c['Email'] || c['E-mail'] || c['Customer Email'] || 'N/A',
                    value: membershipValue,
                    cancelledAt: c['Cancelled at'] || 'N/A',
                    location: c['Home location'] || 'Unknown',
                    reason: (c['Reason'] || '').split('>')[0].trim() || 'Not provided'
                };
            });
            
            detailedCancellations.sort((a, b) => b.value - a.value);
            
            const totalValue = detailedCancellations.reduce((sum, c) => sum + c.value, 0);
            
            let content = `
                <div class="modal-highlight">
                    <strong>Membership Type:</strong> ${type}<br>
                    <strong>Total Cancellations:</strong> ${count}<br>
                    <strong>Total Lost Revenue:</strong> ${formatCurrency(totalValue)}
                </div>
                
                <div class="modal-section">
                    <h4>Cancelled Members (${count})</h4>
                    <table class="modal-table">
                        <thead>
                            <tr>
                                <th>Customer</th>
                                <th>Value</th>
                                <th>Location</th>
                                <th>Cancelled</th>
                                <th>Reason</th>
                            </tr>
                        </thead>
                        <tbody>
                            ${detailedCancellations.map(c => {
                                const momenceLink = getMomenceCustomerLink(c.email, c.customerName);
                                return `
                                <tr>
                                    <td>
                                        <strong>${c.customerName || 'Unknown'}</strong>${momenceLink}<br>
                                        <span style="font-size: 11px; color: #666;">${c.email}</span>
                                    </td>
                                    <td><strong>${formatCurrency(c.value)}</strong></td>
                                    <td>${c.location}</td>
                                    <td style="font-size: 12px;">${c.cancelledAt}</td>
                                    <td style="font-size: 12px;">${c.reason}</td>
                                </tr>
                            `;
                            }).join('')}
                        </tbody>
                    </table>
                </div>
            `;
            
            showModal(`Cancellations: ${type}`, content);
        }
        
        // Show Cancellation Location Details Modal
        function showCancellationLocationDetails(location, count) {
            const cancellationsAtLocation = filteredCancellations.filter(c => {
                const loc = c['Home location'] || 'Unknown';
                return loc === location;
            });
            
            const detailedCancellations = cancellationsAtLocation.map(c => {
                let membershipValue = 0;
                
                // Match by Customer Email instead of Membership ID
                const customerEmail = (c['Email'] || c['E-mail'] || c['Customer Email'] || '').toLowerCase().trim();
                if (customerEmail && membershipsData) {
                    const matchingMemberships = membershipsData.filter(m => 
                        (m['Customer Email'] || '').toLowerCase().trim() === customerEmail
                    );
                    if (matchingMemberships.length > 0) {
                        // Sort by date and get most recent
                        const sortedMemberships = matchingMemberships.sort((a, b) => {
                            const dateA = a['Bought Date/Time (GMT)'] ? new Date(a['Bought Date/Time (GMT)']) : new Date(0);
                            const dateB = b['Bought Date/Time (GMT)'] ? new Date(b['Bought Date/Time (GMT)']) : new Date(0);
                            return dateB - dateA;
                        });
                        // Use Paid Amount as monthly value
                        membershipValue = parseFloat(sortedMemberships[0]['Paid Amount']) || 0;
                    }
                }
                
                // Try different possible field names for customer name
                const firstName = c['First name'] || c['First Name'] || c['Customer First Name'] || '';
                const lastName = c['Last name'] || c['Last Name'] || c['Customer Last Name'] || '';
                const fullName = c['Customer Name'] || c['Name'] || '';
                const customerName = fullName || `${firstName} ${lastName}`.trim();
                
                return {
                    customerName: customerName || 'Unknown',
                    email: c['Email'] || c['E-mail'] || c['Customer Email'] || 'N/A',
                    membership: c['Membership'] || 'Unknown',
                    value: membershipValue,
                    cancelledAt: c['Cancelled at'] || 'N/A',
                    reason: (c['Reason'] || '').split('>')[0].trim() || 'Not provided'
                };
            });
            
            detailedCancellations.sort((a, b) => b.value - a.value);
            
            const totalValue = detailedCancellations.reduce((sum, c) => sum + c.value, 0);
            
            let content = `
                <div class="modal-highlight">
                    <strong>Location:</strong> ${location}<br>
                    <strong>Total Cancellations:</strong> ${count}<br>
                    <strong>Total Lost Revenue:</strong> ${formatCurrency(totalValue)}
                </div>
                
                <div class="modal-section">
                    <h4>Cancelled Members at ${location} (${count})</h4>
                    <table class="modal-table">
                        <thead>
                            <tr>
                                <th>Customer</th>
                                <th>Membership</th>
                                <th>Value</th>
                                <th>Cancelled</th>
                                <th>Reason</th>
                            </tr>
                        </thead>
                        <tbody>
                            ${detailedCancellations.map(c => {
                                const momenceLink = getMomenceCustomerLink(c.email, c.customerName);
                                return `
                                <tr>
                                    <td>
                                        <strong>${c.customerName || 'Unknown'}</strong>${momenceLink}<br>
                                        <span style="font-size: 11px; color: #666;">${c.email}</span>
                                    </td>
                                    <td>${c.membership}</td>
                                    <td><strong>${formatCurrency(c.value)}</strong></td>
                                    <td style="font-size: 12px;">${c.cancelledAt}</td>
                                    <td style="font-size: 12px;">${c.reason.substring(0, 40)}${c.reason.length > 40 ? '...' : ''}</td>
                                </tr>
                            `;
                            }).join('')}
                        </tbody>
                    </table>
                </div>
            `;
            
            showModal(`Cancellations: ${location}`, content);
        }
        
        // Show Cancellation Month Details Modal
        function showCancellationMonthDetails(monthKey, count) {
            const [year, month] = monthKey.split('-');
            const monthName = new Date(year, parseInt(month) - 1).toLocaleDateString('en-US', { month: 'long', year: 'numeric' });
            
            const cancellationsInMonth = filteredCancellations.filter(c => {
                const cancelledAt = c['Cancelled at'];
                if (cancelledAt) {
                    const dateParts = cancelledAt.split(',')[0];
                    const cancelDate = new Date(dateParts);
                    if (!isNaN(cancelDate.getTime())) {
                        const cancelMonthKey = `${cancelDate.getFullYear()}-${String(cancelDate.getMonth() + 1).padStart(2, '0')}`;
                        return cancelMonthKey === monthKey;
                    }
                }
                return false;
            });
            
            const detailedCancellations = cancellationsInMonth.map(c => {
                let membershipValue = 0;
                
                // Match by Customer Email instead of Membership ID
                const customerEmail = (c['Email'] || c['E-mail'] || c['Customer Email'] || '').toLowerCase().trim();
                if (customerEmail && membershipsData) {
                    const matchingMemberships = membershipsData.filter(m => 
                        (m['Customer Email'] || '').toLowerCase().trim() === customerEmail
                    );
                    if (matchingMemberships.length > 0) {
                        // Sort by date and get most recent
                        const sortedMemberships = matchingMemberships.sort((a, b) => {
                            const dateA = a['Bought Date/Time (GMT)'] ? new Date(a['Bought Date/Time (GMT)']) : new Date(0);
                            const dateB = b['Bought Date/Time (GMT)'] ? new Date(b['Bought Date/Time (GMT)']) : new Date(0);
                            return dateB - dateA;
                        });
                        // Use Paid Amount as monthly value
                        membershipValue = parseFloat(sortedMemberships[0]['Paid Amount']) || 0;
                    }
                }
                
                // Try different possible field names for customer name
                const firstName = c['First name'] || c['First Name'] || c['Customer First Name'] || '';
                const lastName = c['Last name'] || c['Last Name'] || c['Customer Last Name'] || '';
                const fullName = c['Customer Name'] || c['Name'] || '';
                const customerName = fullName || `${firstName} ${lastName}`.trim();
                
                return {
                    customerName: customerName || 'Unknown',
                    email: c['Email'] || c['E-mail'] || c['Customer Email'] || 'N/A',
                    membership: c['Membership'] || 'Unknown',
                    value: membershipValue,
                    cancelledAt: c['Cancelled at'] || 'N/A',
                    location: c['Home location'] || 'Unknown',
                    reason: (c['Reason'] || '').split('>')[0].trim() || 'Not provided'
                };
            });
            
            detailedCancellations.sort((a, b) => b.value - a.value);
            
            const totalValue = detailedCancellations.reduce((sum, c) => sum + c.value, 0);
            
            let content = `
                <div class="modal-highlight">
                    <strong>Month:</strong> ${monthName}<br>
                    <strong>Total Cancellations:</strong> ${count}<br>
                    <strong>Total Lost Revenue:</strong> ${formatCurrency(totalValue)}
                </div>
                
                <div class="modal-section">
                    <h4>Cancellations in ${monthName} (${count})</h4>
                    <table class="modal-table">
                        <thead>
                            <tr>
                                <th>Customer</th>
                                <th>Membership</th>
                                <th>Value</th>
                                <th>Location</th>
                                <th>Cancelled</th>
                                <th>Reason</th>
                            </tr>
                        </thead>
                        <tbody>
                            ${detailedCancellations.map(c => {
                                const momenceLink = getMomenceCustomerLink(c.email, c.customerName);
                                return `
                                <tr>
                                    <td>
                                        <strong>${c.customerName || 'Unknown'}</strong>${momenceLink}<br>
                                        <span style="font-size: 11px; color: #666;">${c.email}</span>
                                    </td>
                                    <td>${c.membership}</td>
                                    <td><strong>${formatCurrency(c.value)}</strong></td>
                                    <td>${c.location}</td>
                                    <td style="font-size: 12px;">${c.cancelledAt}</td>
                                    <td style="font-size: 12px;">${c.reason.substring(0, 30)}${c.reason.length > 30 ? '...' : ''}</td>
                                </tr>
                            `;
                            }).join('')}
                        </tbody>
                    </table>
                </div>
            `;
            
            showModal(`Cancellations: ${monthName}`, content);
        }
        
        // UPCOMING RENEWALS SECTION
        function appendUpcomingRenewalsToMemberships() {
            if (!membershipRenewalsData || membershipRenewalsData.length === 0) {
                return;
            }
            
            // Remove existing renewals section if present
            let membershipsTab = document.getElementById('memberships');
            if (membershipsTab) {
                const existingRenewalsSection = membershipsTab.querySelector('#renewalsSection');
                if (existingRenewalsSection) {
                    existingRenewalsSection.remove();
                }
            }
            
            // Build VSP lookup from membership sales data
            const customerFirstVSP = {};
            if (membershipsData && membershipsData.length > 0) {
                const sortedMemberships = [...membershipsData].sort((a, b) => {
                    const dateA = a['Bought Date/Time (GMT)'] ? new Date(a['Bought Date/Time (GMT)']) : new Date(0);
                    const dateB = b['Bought Date/Time (GMT)'] ? new Date(b['Bought Date/Time (GMT)']) : new Date(0);
                    return dateA - dateB;
                });
                
                sortedMemberships.forEach(m => {
                    const email = (m['Customer Email'] || '').toLowerCase().trim();
                    if (email && !customerFirstVSP[email]) {
                        customerFirstVSP[email] = m['Sold by'] || 'Direct/Online';
                    }
                });
            }
            
            // Parse renewal dates and sort
            const now = new Date();
            const renewalsWithDates = membershipRenewalsData.map(renewal => {
                const dateStr = renewal['Date'];
                let renewalDate = null;
                
                if (dateStr) {
                    // Parse date format like "2025-12-19, 4:00 PM"
                    const dateParts = dateStr.split(',')[0];
                    renewalDate = new Date(dateParts);
                }
                
                // Get VSP from first membership purchase
                const email = (renewal['Customer email'] || '').toLowerCase().trim();
                const vsp = customerFirstVSP[email] || 'Direct/Online';
                const vspFormatted = formatStaffName(vsp);
                
                return {
                    ...renewal,
                    renewalDate: renewalDate,
                    daysUntil: renewalDate ? Math.ceil((renewalDate - now) / (1000 * 60 * 60 * 24)) : 999999,
                    vsp: vsp,
                    vspFormatted: vspFormatted
                };
            }).filter(r => r.renewalDate && r.renewalDate >= now); // Only include future renewals
            
            // Sort by renewal date (soonest first)
            renewalsWithDates.sort((a, b) => a.renewalDate - b.renewalDate);
            
            // Group by time period
            const next7Days = renewalsWithDates.filter(r => r.daysUntil <= 7);
            const next14Days = renewalsWithDates.filter(r => r.daysUntil <= 14);
            const next30Days = renewalsWithDates.filter(r => r.daysUntil <= 30);
            
            // Calculate total renewal value
            const totalRenewalValue = renewalsWithDates.reduce((sum, r) => sum + (parseFloat(r['Amount']) || 0), 0);
            const next7DaysValue = next7Days.reduce((sum, r) => sum + (parseFloat(r['Amount']) || 0), 0);
            const next14DaysValue = next14Days.reduce((sum, r) => sum + (parseFloat(r['Amount']) || 0), 0);
            const next30DaysValue = next30Days.reduce((sum, r) => sum + (parseFloat(r['Amount']) || 0), 0);
            
            // Group by location
            const renewalsByLocation = {};
            renewalsWithDates.forEach(r => {
                const loc = r['Home location'] || 'Unknown';
                if (!renewalsByLocation[loc]) {
                    renewalsByLocation[loc] = { count: 0, value: 0 };
                }
                renewalsByLocation[loc].count++;
                renewalsByLocation[loc].value += parseFloat(r['Amount']) || 0;
            });
            
            // Group by membership type
            const renewalsByType = {};
            renewalsWithDates.forEach(r => {
                const type = r['Membership'] || 'Unknown';
                if (!renewalsByType[type]) {
                    renewalsByType[type] = { count: 0, value: 0 };
                }
                renewalsByType[type].count++;
                renewalsByType[type].value += parseFloat(r['Amount']) || 0;
            });
            
            const sortedLocations = Object.entries(renewalsByLocation)
                .sort((a, b) => b[1].count - a[1].count);
            
            const sortedTypes = Object.entries(renewalsByType)
                .sort((a, b) => b[1].count - a[1].count);
            
            // Build HTML
            const renewalsHTML = `
                <div id="renewalsSection" class="section" style="margin-top: 40px; border-top: 3px solid var(--accent); padding-top: 30px;">
                    <h2 style="margin-bottom: 20px;">üìÖ Upcoming Renewals</h2>
                    
                    <!-- Summary Metrics -->
                    <div class="metrics-grid" style="grid-template-columns: repeat(4, 1fr); margin-bottom: 30px;">
                        <div class="metric-card compact" style="background: linear-gradient(135deg, rgba(40, 167, 69, 0.1), rgba(32, 201, 151, 0.05)); border-left: 4px solid #28a745;">
                            <div class="metric-label">üîú Next 7 Days</div>
                            <div class="metric-value">${formatNumber(next7Days.length)}</div>
                            <div class="metric-subtext">${formatCurrency(next7DaysValue)} value<br>${((next7Days.length / renewalsWithDates.length) * 100).toFixed(1)}% of total</div>
                        </div>
                        
                        <div class="metric-card compact" style="background: linear-gradient(135deg, rgba(0, 123, 255, 0.1), rgba(0, 86, 179, 0.05)); border-left: 4px solid #007bff;">
                            <div class="metric-label">üìÜ Next 14 Days</div>
                            <div class="metric-value">${formatNumber(next14Days.length)}</div>
                            <div class="metric-subtext">${formatCurrency(next14DaysValue)} value<br>${((next14Days.length / renewalsWithDates.length) * 100).toFixed(1)}% of total</div>
                        </div>
                        
                        <div class="metric-card compact" style="background: linear-gradient(135deg, rgba(156, 39, 176, 0.1), rgba(123, 31, 162, 0.05)); border-left: 4px solid #9c27b0;">
                            <div class="metric-label">üóìÔ∏è Next 30 Days</div>
                            <div class="metric-value">${formatNumber(next30Days.length)}</div>
                            <div class="metric-subtext">${formatCurrency(next30DaysValue)} value<br>${((next30Days.length / renewalsWithDates.length) * 100).toFixed(1)}% of total</div>
                        </div>
                        
                        <div class="metric-card compact" style="background: linear-gradient(135deg, rgba(255, 152, 0, 0.1), rgba(245, 124, 0, 0.05)); border-left: 4px solid #ff9800;">
                            <div class="metric-label">üí∞ Total Pending</div>
                            <div class="metric-value">${formatCurrency(totalRenewalValue)}</div>
                            <div class="metric-subtext">${formatNumber(renewalsWithDates.length)} renewals<br>Avg: ${formatCurrency(totalRenewalValue / renewalsWithDates.length)}</div>
                        </div>
                    </div>
                    
                    <!-- Renewals by Location and Type -->
                    <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 20px; margin-bottom: 30px;">
                        <div class="card">
                            <h3 style="margin-bottom: 15px;">Renewals by Location</h3>
                            <table style="width: 100%; font-size: 13px;">
                                <thead style="background: var(--gray-light);">
                                    <tr>
                                        <th style="padding: 8px; text-align: left;">Location</th>
                                        <th style="padding: 8px; text-align: center;">Count</th>
                                        <th style="padding: 8px; text-align: right;">Value</th>
                                    </tr>
                                </thead>
                                <tbody>
                                    ${sortedLocations.map(([loc, data]) => `
                                        <tr style="border-bottom: 1px solid var(--gray);">
                                            <td style="padding: 8px;">${loc}</td>
                                            <td style="padding: 8px; text-align: center; font-weight: 600;">${formatNumber(data.count)}</td>
                                            <td style="padding: 8px; text-align: right; font-weight: 600; color: var(--primary);">${formatCurrency(data.value)}</td>
                                        </tr>
                                    `).join('')}
                                </tbody>
                            </table>
                        </div>
                        
                        <div class="card">
                            <h3 style="margin-bottom: 15px;">Renewals by Type</h3>
                            <table style="width: 100%; font-size: 13px;">
                                <thead style="background: var(--gray-light);">
                                    <tr>
                                        <th style="padding: 8px; text-align: left;">Membership Type</th>
                                        <th style="padding: 8px; text-align: center;">Count</th>
                                        <th style="padding: 8px; text-align: right;">Value</th>
                                    </tr>
                                </thead>
                                <tbody>
                                    ${sortedTypes.map(([type, data]) => `
                                        <tr style="border-bottom: 1px solid var(--gray);">
                                            <td style="padding: 8px;">${type}</td>
                                            <td style="padding: 8px; text-align: center; font-weight: 600;">${formatNumber(data.count)}</td>
                                            <td style="padding: 8px; text-align: right; font-weight: 600; color: var(--primary);">${formatCurrency(data.value)}</td>
                                        </tr>
                                    `).join('')}
                                </tbody>
                            </table>
                        </div>
                    </div>
                    
                    <!-- Upcoming Renewals Table -->
                    <div class="card">
                        <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 15px; flex-wrap: wrap; gap: 10px;">
                            <div style="display: flex; align-items: center; gap: 10px;">
                                <h3 style="margin: 0;">All Upcoming Renewals</h3>
                                <span id="renewalPaginationInfo" style="font-size: 13px; color: #666;"></span>
                            </div>
                            <div style="display: flex; gap: 10px; align-items: center; flex-wrap: wrap;">
                                <select id="renewalPageSize" onchange="updateRenewalsPagination()" 
                                        style="padding: 8px 12px; border: 2px solid var(--accent); border-radius: 5px; font-size: 13px; font-weight: 600;">
                                    <option value="25">25 per page</option>
                                    <option value="50">50 per page</option>
                                    <option value="100">100 per page</option>
                                    <option value="250">250 per page</option>
                                    <option value="all">All</option>
                                </select>
                                <input type="text" id="renewalSearchInput" placeholder="üîç Search renewals..." 
                                       style="padding: 8px 12px; border: 2px solid var(--accent); border-radius: 5px; font-size: 13px; width: 200px;">
                                <select id="renewalTimeFilter" onchange="filterRenewalsByTime()" 
                                        style="padding: 8px 12px; border: 2px solid var(--accent); border-radius: 5px; font-size: 13px; font-weight: 600;">
                                    <option value="all">All Renewals</option>
                                    <option value="7">Next 7 Days</option>
                                    <option value="14">Next 14 Days</option>
                                    <option value="30">Next 30 Days</option>
                                </select>
                                <button onclick="exportRenewalsData()" style="padding: 8px 15px; background: var(--accent); color: white; border: none; border-radius: 5px; cursor: pointer; font-weight: 600; font-size: 13px;">
                                    üì• Export CSV
                                </button>
                            </div>
                        </div>
                        
                        <!-- Pagination Controls -->
                        <div id="renewalPaginationControls" style="display: flex; justify-content: center; align-items: center; gap: 10px; margin-bottom: 15px; padding: 10px; background: var(--gray-light); border-radius: 5px;">
                            <button onclick="changeRenewalsPage('first')" style="padding: 5px 10px; border: 1px solid #ddd; border-radius: 5px; background: white; cursor: pointer;">‚èÆÔ∏è</button>
                            <button onclick="changeRenewalsPage('prev')" style="padding: 5px 10px; border: 1px solid #ddd; border-radius: 5px; background: white; cursor: pointer;">‚óÄÔ∏è</button>
                            <span id="renewalPageIndicator" style="padding: 5px 15px; font-size: 13px; color: #666;"></span>
                            <button onclick="changeRenewalsPage('next')" style="padding: 5px 10px; border: 1px solid #ddd; border-radius: 5px; background: white; cursor: pointer;">‚ñ∂Ô∏è</button>
                            <button onclick="changeRenewalsPage('last')" style="padding: 5px 10px; border: 1px solid #ddd; border-radius: 5px; background: white; cursor: pointer;">‚è≠Ô∏è</button>
                        </div>
                        
                        <div style="overflow-x: auto;">
                            <table id="renewalsTable" style="width: 100%; font-size: 13px;">
                                <thead style="background: var(--primary); color: white; position: sticky; top: 0;">
                                    <tr>
                                        <th style="padding: 10px; text-align: left; cursor: pointer;" onclick="sortRenewalsTable('name')">Customer Name ‚Üï</th>
                                        <th style="padding: 10px; text-align: left; cursor: pointer;" onclick="sortRenewalsTable('email')">Email ‚Üï</th>
                                        <th style="padding: 10px; text-align: left; cursor: pointer;" onclick="sortRenewalsTable('membership')">Membership ‚Üï</th>
                                        <th style="padding: 10px; text-align: right; cursor: pointer;" onclick="sortRenewalsTable('amount')">Amount ‚Üï</th>
                                        <th style="padding: 10px; text-align: left; cursor: pointer;" onclick="sortRenewalsTable('date')">Renewal Date ‚Üï</th>
                                        <th style="padding: 10px; text-align: center; cursor: pointer;" onclick="sortRenewalsTable('days')">Days Until ‚Üï</th>
                                        <th style="padding: 10px; text-align: left; cursor: pointer;" onclick="sortRenewalsTable('vsp')">Sold By ‚Üï</th>
                                        <th style="padding: 10px; text-align: left; cursor: pointer;" onclick="sortRenewalsTable('location')">Location ‚Üï</th>
                                    </tr>
                                </thead>
                                <tbody id="renewalsTableBody">
                                    ${renewalsWithDates.map(renewal => {
                                        const daysUntil = renewal.daysUntil;
                                        let urgencyColor = '#28a745'; // green
                                        let urgencyBg = 'rgba(40, 167, 69, 0.1)';
                                        
                                        if (daysUntil <= 7) {
                                            urgencyColor = '#dc3545'; // red
                                            urgencyBg = 'rgba(220, 53, 69, 0.1)';
                                        } else if (daysUntil <= 30) {
                                            urgencyColor = '#ff9800'; // orange
                                            urgencyBg = 'rgba(255, 152, 0, 0.1)';
                                        }
                                        
                                        return `
                                            <tr style="border-bottom: 1px solid var(--gray); background: ${urgencyBg};"
                                                data-name="${(renewal['Customer Name'] || '').toLowerCase()}"
                                                data-email="${(renewal['Customer email'] || '').toLowerCase()}"
                                                data-membership="${(renewal['Membership'] || '').toLowerCase()}"
                                                data-location="${(renewal['Home location'] || '').toLowerCase()}"
                                                data-vsp="${(renewal.vspFormatted || '').toLowerCase()}"
                                                data-days="${daysUntil}"
                                                data-amount="${parseFloat(renewal['Amount']) || 0}"
                                                data-date="${renewal.renewalDate ? renewal.renewalDate.toISOString() : ''}">
                                                <td style="padding: 10px; font-weight: 600;">${renewal['Customer Name'] || 'Unknown'}${getMomenceCustomerLink(renewal['Customer email'], renewal['Customer Name'] || 'customer')}</td>
                                                <td style="padding: 10px; color: #666; font-size: 12px;">${renewal['Customer email'] || 'N/A'}</td>
                                                <td style="padding: 10px;">${renewal['Membership'] || 'Unknown'}</td>
                                                <td style="padding: 10px; text-align: right; font-weight: 600; color: var(--primary);">${formatCurrency(parseFloat(renewal['Amount']) || 0)}</td>
                                                <td style="padding: 10px;">${renewal.renewalDate ? renewal.renewalDate.toLocaleDateString('en-US', { month: 'short', day: 'numeric', year: 'numeric' }) : 'N/A'}</td>
                                                <td style="padding: 10px; text-align: center;">
                                                    <span style="padding: 4px 8px; background: ${urgencyColor}; color: white; border-radius: 4px; font-weight: 600; font-size: 11px;">
                                                        ${daysUntil} ${daysUntil === 1 ? 'day' : 'days'}
                                                    </span>
                                                </td>
                                                <td style="padding: 10px;">${renewal.vspFormatted || 'Direct/Online'}</td>
                                                <td style="padding: 10px;">${renewal['Home location'] || 'Unknown'}</td>
                                            </tr>
                                        `;
                                    }).join('')}
                                </tbody>
                            </table>
                        </div>
                        
                        <div style="margin-top: 15px; padding: 10px; background: var(--gray-light); border-radius: 5px; text-align: center; font-size: 13px; color: #666;">
                            Showing <strong id="renewalsCount">${renewalsWithDates.length}</strong> upcoming renewals
                        </div>
                    </div>
                </div>
            `;
            
            // Append to memberships tab (reuse existing membershipsTab variable)
            if (membershipsTab) {
                membershipsTab.insertAdjacentHTML('beforeend', renewalsHTML);
                
                // Initialize search and filtering
                initializeRenewalsTable();
            }
        }
        
        // Initialize renewals table with search and sort functionality
        // Renewals pagination variables
        let renewalsCurrentPage = 1;
        let renewalsPageSize = 25;
        let renewalsFilteredRows = [];
        
        function initializeRenewalsTable() {
            // Search functionality
            const searchInput = document.getElementById('renewalSearchInput');
            if (searchInput) {
                searchInput.addEventListener('input', function(e) {
                    applyRenewalsFilters();
                });
            }
            
            // Initialize filtered rows
            const allRows = document.querySelectorAll('#renewalsTableBody tr');
            renewalsFilteredRows = Array.from(allRows);
            renewalsCurrentPage = 1;
            displayRenewalsPage();
        }
        
        // Filter renewals by time period
        window.filterRenewalsByTime = function() {
            applyRenewalsFilters();
        }
        
        // Apply all filters and update pagination
        function applyRenewalsFilters() {
            const searchTerm = document.getElementById('renewalSearchInput').value.toLowerCase();
            const timeFilter = parseInt(document.getElementById('renewalTimeFilter').value);
            const allRows = document.querySelectorAll('#renewalsTableBody tr');
            
            renewalsFilteredRows = [];
            allRows.forEach(row => {
                const name = row.getAttribute('data-name');
                const email = row.getAttribute('data-email');
                const membership = row.getAttribute('data-membership');
                const location = row.getAttribute('data-location');
                const vsp = row.getAttribute('data-vsp');
                const daysUntil = parseInt(row.getAttribute('data-days'));
                
                // Check search filter
                const matchesSearch = !searchTerm || 
                                     name.includes(searchTerm) || 
                                     email.includes(searchTerm) ||
                                     membership.includes(searchTerm) ||
                                     location.includes(searchTerm) ||
                                     vsp.includes(searchTerm);
                
                // Check time filter
                const matchesTime = isNaN(timeFilter) || daysUntil <= timeFilter;
                
                if (matchesSearch && matchesTime) {
                    renewalsFilteredRows.push(row);
                }
            });
            
            renewalsCurrentPage = 1; // Reset to first page on filter change
            displayRenewalsPage();
        }
        
        // Update pagination settings
        window.updateRenewalsPagination = function() {
            const pageSize = document.getElementById('renewalPageSize').value;
            renewalsPageSize = pageSize === 'all' ? renewalsFilteredRows.length : parseInt(pageSize);
            renewalsCurrentPage = 1; // Reset to first page when changing page size
            displayRenewalsPage();
        }
        
        // Display current page
        function displayRenewalsPage() {
            const totalRows = renewalsFilteredRows.length;
            const totalPages = Math.ceil(totalRows / renewalsPageSize);
            
            // Hide ALL rows first
            const allRows = document.querySelectorAll('#renewalsTableBody tr');
            allRows.forEach(row => row.style.display = 'none');
            
            // Calculate range for current page
            const startIdx = (renewalsCurrentPage - 1) * renewalsPageSize;
            const endIdx = Math.min(startIdx + renewalsPageSize, totalRows);
            
            // Show only the filtered rows for current page
            for (let i = startIdx; i < endIdx; i++) {
                renewalsFilteredRows[i].style.display = '';
            }
            
            // Update pagination info
            if (renewalsPageSize >= totalRows) {
                document.getElementById('renewalPaginationInfo').textContent = '';
                document.getElementById('renewalPageIndicator').textContent = '';
                document.getElementById('renewalPaginationControls').style.display = 'none';
            } else {
                document.getElementById('renewalPaginationInfo').textContent = ` (showing ${startIdx + 1}-${endIdx})`;
                document.getElementById('renewalPageIndicator').textContent = `Page ${renewalsCurrentPage} of ${totalPages}`;
                document.getElementById('renewalPaginationControls').style.display = 'flex';
            }
            
            // Update visible count
            document.getElementById('renewalsCount').textContent = formatNumber(totalRows);
        }
        
        // Change page
        window.changeRenewalsPage = function(direction) {
            const totalPages = Math.ceil(renewalsFilteredRows.length / renewalsPageSize);
            
            switch(direction) {
                case 'first':
                    renewalsCurrentPage = 1;
                    break;
                case 'prev':
                    renewalsCurrentPage = Math.max(1, renewalsCurrentPage - 1);
                    break;
                case 'next':
                    renewalsCurrentPage = Math.min(totalPages, renewalsCurrentPage + 1);
                    break;
                case 'last':
                    renewalsCurrentPage = totalPages;
                    break;
            }
            
            displayRenewalsPage();
        }
        
        // Sort renewals table
        let renewalsSortColumn = 'days';
        let renewalsSortDirection = 'asc';
        
        window.sortRenewalsTable = function(column) {
            if (renewalsSortColumn === column) {
                renewalsSortDirection = renewalsSortDirection === 'asc' ? 'desc' : 'asc';
            } else {
                renewalsSortColumn = column;
                renewalsSortDirection = 'asc';
            }
            
            const tbody = document.getElementById('renewalsTableBody');
            const rows = Array.from(tbody.querySelectorAll('tr'));
            
            rows.sort((a, b) => {
                let aVal, bVal;
                
                switch(column) {
                    case 'name':
                        aVal = a.getAttribute('data-name');
                        bVal = b.getAttribute('data-name');
                        break;
                    case 'email':
                        aVal = a.getAttribute('data-email');
                        bVal = b.getAttribute('data-email');
                        break;
                    case 'membership':
                        aVal = a.getAttribute('data-membership');
                        bVal = b.getAttribute('data-membership');
                        break;
                    case 'location':
                        aVal = a.getAttribute('data-location');
                        bVal = b.getAttribute('data-location');
                        break;
                    case 'vsp':
                        aVal = a.getAttribute('data-vsp');
                        bVal = b.getAttribute('data-vsp');
                        break;
                    case 'amount':
                        aVal = parseFloat(a.getAttribute('data-amount'));
                        bVal = parseFloat(b.getAttribute('data-amount'));
                        break;
                    case 'days':
                        aVal = parseInt(a.getAttribute('data-days'));
                        bVal = parseInt(b.getAttribute('data-days'));
                        break;
                    case 'date':
                        aVal = new Date(a.getAttribute('data-date'));
                        bVal = new Date(b.getAttribute('data-date'));
                        break;
                    default:
                        return 0;
                }
                
                if (typeof aVal === 'string') {
                    return renewalsSortDirection === 'asc' ? 
                        aVal.localeCompare(bVal) : bVal.localeCompare(aVal);
                } else {
                    return renewalsSortDirection === 'asc' ? aVal - bVal : bVal - aVal;
                }
            });
            
            // Re-append sorted rows
            rows.forEach(row => tbody.appendChild(row));
        }
        
        // Export renewals data to CSV
        window.exportRenewalsData = function() {
            if (!membershipRenewalsData || membershipRenewalsData.length === 0) {
                alert('No renewals data to export');
                return;
            }
            
            const rows = Array.from(document.querySelectorAll('#renewalsTableBody tr'))
                .filter(row => row.style.display !== 'none');
            
            const csvData = [];
            csvData.push(['Customer Name', 'Email', 'Membership', 'Amount', 'Renewal Date', 'Days Until', 'Location']);
            
            rows.forEach(row => {
                const cells = row.querySelectorAll('td');
                csvData.push([
                    cells[0].textContent.trim(),
                    cells[1].textContent.trim(),
                    cells[2].textContent.trim(),
                    cells[3].textContent.trim(),
                    cells[4].textContent.trim(),
                    cells[5].textContent.trim(),
                    cells[6].textContent.trim()
                ]);
            });
            
            const csv = csvData.map(row => row.map(cell => `"${cell}"`).join(',')).join('\n');
            const blob = new Blob([csv], { type: 'text/csv' });
            const url = window.URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = `upcoming-renewals-${new Date().toISOString().split('T')[0]}.csv`;
            a.click();
            window.URL.revokeObjectURL(url);
        }
        
        // CLIENT JOURNEY VISUALIZATION TAB
        function renderJourneyTab() {
            // Check if leads data is available
            if (!leadsData || leadsData.length === 0) {
                document.getElementById('journey').innerHTML = `
                    <div class="alert info">
                        <h4>üöÄ Client Journey Visualization</h4>
                        <p>Upload the <strong>Leads & Customers CSV</strong> file to unlock the journey visualization showing how clients progress from leads to loyal customers.</p>
                    </div>
                `;
                return;
            }
            
            const data = filteredAppointments;
            // Use global filteredLeads
            
            // Calculate journey stages (using same logic as Funnel tab)
            const totalPeople = filteredLeads.length;
            const customers = filteredLeads.filter(row => row.Type === 'Customer').length;
            const leads = totalPeople - customers;
            
            // Intro offers (same logic as Funnel tab)
            const hadIntroOffer = filteredLeads.filter(row => {
                const firstPurchase = row['First purchase'] || '';
                return firstPurchase && firstPurchase !== 'N/A' && isIntroOffer(firstPurchase);
            }).length;
            
            // Made first paid purchase
            const madePurchase = filteredLeads.filter(row => {
                const firstPurchase = row['First purchase'] || '';
                return firstPurchase && firstPurchase !== 'N/A' && !isIntroOffer(firstPurchase);
            }).length;
            
            // Repeat customers (2+ visits)
            const clientVisits = {};
            data.forEach(row => {
                const email = (row['Customer Email'] || '').toLowerCase().trim();
                if (email) {
                    clientVisits[email] = (clientVisits[email] || 0) + 1;
                }
            });
            const repeatCustomers = Object.values(clientVisits).filter(count => count >= 2).length;
            
            // Loyal customers (5+ visits)
            const loyalCustomers = Object.values(clientVisits).filter(count => count >= 5).length;
            
            // Calculate conversion rates (with safety checks for division by zero)
            const leadToCustomer = totalPeople > 0 ? (customers / totalPeople * 100) : 0;
            const customerToIntro = customers > 0 ? (hadIntroOffer / customers * 100) : 0;
            const introToPurchase = hadIntroOffer > 0 ? (madePurchase / hadIntroOffer * 100) : 0;
            const purchaseToRepeat = madePurchase > 0 ? (repeatCustomers / madePurchase * 100) : 0;
            const repeatToLoyal = repeatCustomers > 0 ? (loyalCustomers / repeatCustomers * 100) : 0;
            
            // Calculate drop-offs (with safety checks)
            const dropLeadToCustomer = totalPeople > 0 ? ((totalPeople - customers) / totalPeople * 100).toFixed(0) : '0';
            const dropCustomerToIntro = customers > 0 ? ((customers - hadIntroOffer) / customers * 100).toFixed(0) : '0';
            const dropIntroToPurchase = hadIntroOffer > 0 ? ((hadIntroOffer - madePurchase) / hadIntroOffer * 100).toFixed(0) : '0';
            const dropPurchaseToRepeat = madePurchase > 0 ? ((madePurchase - repeatCustomers) / madePurchase * 100).toFixed(0) : '0';
            const dropRepeatToLoyal = repeatCustomers > 0 ? ((repeatCustomers - loyalCustomers) / repeatCustomers * 100).toFixed(0) : '0';
            
            let html = `
                <div class="alert info">
                    <h3>üöÄ Client Journey Visualization</h3>
                    <p>Track how clients progress through your sales funnel, from first contact to loyal customer. Click any stage for details.</p>
                </div>
                
                <div class="journey-flow">
                    <div class="journey-stage" onclick="showJourneyDetails('leads', ${totalPeople})">
                        <div class="journey-stage-icon">üë•</div>
                        <div class="journey-stage-title">TOTAL CONTACTS</div>
                        <div class="journey-stage-count">${formatNumber(totalPeople)}<br><span class="journey-stage-percent">100%</span></div>
                    </div>
                    
                    <div class="journey-arrow">‚Üí</div>
                    
                    <div class="journey-stage" onclick="showJourneyDetails('customers', ${customers})" style="position: relative;">
                        ${dropLeadToCustomer > 0 ? `<div class="journey-dropoff">-${dropLeadToCustomer}% drop</div>` : ''}
                        <div class="journey-stage-icon">‚úÖ</div>
                        <div class="journey-stage-title">CUSTOMERS</div>
                        <div class="journey-stage-count">${formatNumber(customers)}<br><span class="journey-stage-percent">${isFinite(leadToCustomer) ? leadToCustomer.toFixed(0) : '0'}%</span></div>
                    </div>
                    
                    <div class="journey-arrow">‚Üí</div>
                    
                    <div class="journey-stage" onclick="showJourneyDetails('intro', ${hadIntroOffer})" style="position: relative;">
                        ${dropCustomerToIntro > 0 ? `<div class="journey-dropoff">-${dropCustomerToIntro}% drop</div>` : ''}
                        <div class="journey-stage-icon">üé´</div>
                        <div class="journey-stage-title">TRIED INTRO</div>
                        <div class="journey-stage-count">${formatNumber(hadIntroOffer)}<br><span class="journey-stage-percent">${isFinite(customerToIntro) ? customerToIntro.toFixed(0) : '0'}%</span></div>
                    </div>
                    
                    <div class="journey-arrow">‚Üí</div>
                    
                    <div class="journey-stage" onclick="showJourneyDetails('purchase', ${madePurchase})" style="position: relative;">
                        ${dropIntroToPurchase > 0 ? `<div class="journey-dropoff">-${dropIntroToPurchase}% drop</div>` : ''}
                        <div class="journey-stage-icon">üí≥</div>
                        <div class="journey-stage-title">FIRST PURCHASE</div>
                        <div class="journey-stage-count">${formatNumber(madePurchase)}<br><span class="journey-stage-percent">${isFinite(introToPurchase) ? introToPurchase.toFixed(0) : '0'}%</span></div>
                    </div>
                    
                    <div class="journey-arrow">‚Üí</div>
                    
                    <div class="journey-stage" onclick="showJourneyDetails('repeat', ${repeatCustomers})" style="position: relative;">
                        ${dropPurchaseToRepeat > 0 ? `<div class="journey-dropoff">-${dropPurchaseToRepeat}% drop</div>` : ''}
                        <div class="journey-stage-icon">üîÑ</div>
                        <div class="journey-stage-title">REPEAT (2+)</div>
                        <div class="journey-stage-count">${formatNumber(repeatCustomers)}<br><span class="journey-stage-percent">${isFinite(purchaseToRepeat) ? purchaseToRepeat.toFixed(0) : '0'}%</span></div>
                    </div>
                    
                    <div class="journey-arrow">‚Üí</div>
                    
                    <div class="journey-stage" onclick="showJourneyDetails('loyal', ${loyalCustomers})" style="position: relative;">
                        ${dropRepeatToLoyal > 0 ? `<div class="journey-dropoff">-${dropRepeatToLoyal}% drop</div>` : ''}
                        <div class="journey-stage-icon">üëë</div>
                        <div class="journey-stage-title">LOYAL (5+)</div>
                        <div class="journey-stage-count">${formatNumber(loyalCustomers)}<br><span class="journey-stage-percent">${isFinite(repeatToLoyal) ? repeatToLoyal.toFixed(0) : '0'}%</span></div>
                    </div>
                </div>
                
                <div class="table-container">
                    <h2>Journey Conversion Analysis</h2>
                    <table>
                        <thead>
                            <tr>
                                <th>Stage Transition</th>
                                <th>Count</th>
                                <th>Conversion Rate</th>
                                <th>Drop-off</th>
                                <th>Status</th>
                            </tr>
                        </thead>
                        <tbody>
                            <tr>
                                <td>Contacts ‚Üí Customers</td>
                                <td>${formatNumber(customers)} / ${formatNumber(totalPeople)}</td>
                                <td><strong>${totalPeople > 0 ? leadToCustomer.toFixed(1) : '0.0'}%</strong></td>
                                <td>${dropLeadToCustomer}%</td>
                                <td>${leadToCustomer >= 40 ? '‚úÖ Good' : leadToCustomer > 0 ? '‚ö†Ô∏è Needs Work' : '‚ûñ N/A'}</td>
                            </tr>
                            <tr>
                                <td>Customers ‚Üí Intro Offer</td>
                                <td>${formatNumber(hadIntroOffer)} / ${formatNumber(customers)}</td>
                                <td><strong>${customers > 0 ? customerToIntro.toFixed(1) : '0.0'}%</strong></td>
                                <td>${dropCustomerToIntro}%</td>
                                <td>${customerToIntro >= 50 ? '‚úÖ Good' : customerToIntro > 0 ? '‚ö†Ô∏è Needs Work' : '‚ûñ N/A'}</td>
                            </tr>
                            <tr>
                                <td>Intro ‚Üí First Purchase</td>
                                <td>${formatNumber(madePurchase)} / ${formatNumber(hadIntroOffer)}</td>
                                <td><strong>${hadIntroOffer > 0 ? introToPurchase.toFixed(1) : '0.0'}%</strong></td>
                                <td>${dropIntroToPurchase}%</td>
                                <td>${introToPurchase >= 30 ? '‚úÖ Good' : introToPurchase > 0 ? '‚ö†Ô∏è Needs Work' : '‚ûñ N/A'}</td>
                            </tr>
                            <tr>
                                <td>Purchase ‚Üí Repeat</td>
                                <td>${formatNumber(repeatCustomers)} / ${formatNumber(madePurchase)}</td>
                                <td><strong>${madePurchase > 0 ? purchaseToRepeat.toFixed(1) : '0.0'}%</strong></td>
                                <td>${dropPurchaseToRepeat}%</td>
                                <td>${purchaseToRepeat >= 40 ? '‚úÖ Good' : purchaseToRepeat > 0 ? '‚ö†Ô∏è Needs Work' : '‚ûñ N/A'}</td>
                            </tr>
                            <tr>
                                <td>Repeat ‚Üí Loyal</td>
                                <td>${formatNumber(loyalCustomers)} / ${formatNumber(repeatCustomers)}</td>
                                <td><strong>${repeatCustomers > 0 ? repeatToLoyal.toFixed(1) : '0.0'}%</strong></td>
                                <td>${dropRepeatToLoyal}%</td>
                                <td>${repeatToLoyal >= 30 ? '‚úÖ Good' : repeatToLoyal > 0 ? '‚ö†Ô∏è Needs Work' : '‚ûñ N/A'}</td>
                            </tr>
                        </tbody>
                    </table>
                </div>
                
                <div class="alert ${introToPurchase >= 30 ? 'success' : 'warning'}">
                    <h4>üí° Journey Optimization Recommendations</h4>
                    <ul style="margin: 10px 0 0 20px; line-height: 1.8;">
                        ${leadToCustomer < 40 ? '<li><strong>Lead Conversion:</strong> Focus on improving your lead nurturing process. Consider adding more touchpoints and personalized follow-ups.</li>' : ''}
                        ${customerToIntro < 50 ? '<li><strong>Intro Offer Adoption:</strong> Make your intro offer more visible and compelling. Consider a time-limited promotion to create urgency.</li>' : ''}
                        ${introToPurchase < 30 ? '<li><strong>Intro-to-Purchase:</strong> Your intro offer conversion needs improvement. Follow up within 24 hours of intro sessions and highlight package benefits.</li>' : ''}
                        ${purchaseToRepeat < 40 ? '<li><strong>First-to-Second Visit:</strong> This is critical! Implement immediate rebooking at checkout and send reminders within 48 hours.</li>' : ''}
                        ${repeatToLoyal < 30 ? '<li><strong>Building Loyalty:</strong> Create a loyalty program or membership for clients with 3-4 visits to incentivize reaching 5+.</li>' : ''}
                        <li><strong>Biggest Opportunity:</strong> ${Math.max(dropLeadToCustomer, dropCustomerToIntro, dropIntroToPurchase, dropPurchaseToRepeat, dropRepeatToLoyal) == dropLeadToCustomer ? 'Convert more leads to customers' : Math.max(dropCustomerToIntro, dropIntroToPurchase, dropPurchaseToRepeat, dropRepeatToLoyal) == dropCustomerToIntro ? 'Get more customers to try intro offers' : Math.max(dropIntroToPurchase, dropPurchaseToRepeat, dropRepeatToLoyal) == dropIntroToPurchase ? 'Convert intro offers to purchases' : Math.max(dropPurchaseToRepeat, dropRepeatToLoyal) == dropPurchaseToRepeat ? 'Get first-time buyers to return' : 'Build loyalty with repeat customers'}</li>
                    </ul>
                </div>
                
                <div class="metrics-grid" style="grid-template-columns: repeat(4, 1fr);">
                    <div class="metric-card">
                        <div class="metric-label">Conversion Rate</div>
                        <div class="metric-value">${(customers / totalPeople * 100).toFixed(1)}%</div>
                        <div class="metric-subtext">Lead ‚Üí Customer</div>
                    </div>
                    <div class="metric-card">
                        <div class="metric-label">Intro Offer Rate</div>
                        <div class="metric-value">${(hadIntroOffer / totalPeople * 100).toFixed(1)}%</div>
                        <div class="metric-subtext">Tried introductory offer</div>
                    </div>
                    <div class="metric-card">
                        <div class="metric-label">Purchase Rate</div>
                        <div class="metric-value">${(madePurchase / totalPeople * 100).toFixed(1)}%</div>
                        <div class="metric-subtext">Made actual purchase</div>
                    </div>
                    <div class="metric-card">
                        <div class="metric-label">Revenue Rate</div>
                        <div class="metric-value">${(() => {
                            const ltvs = leadsData.map(row => parseLTV(row.LTV));
                            const hasRevenue = ltvs.filter(ltv => ltv > 0).length;
                            return (hasRevenue / totalPeople * 100).toFixed(1);
                        })()}%</div>
                        <div class="metric-subtext">Generating LTV</div>
                    </div>
                </div>
            `;
            
            document.getElementById('journey').innerHTML = html;
        }
        
        
        // AI RECOMMENDATIONS ENGINE
        function generateSmartRecommendations() {
            const data = filteredAppointments;
            // Use global leadsData directly
            const recommendations = [];
            
            // Calculate key metrics
            const totalRevenue = data.reduce((sum, row) => sum + parseFloat(row.Revenue || 0), 0);
            const totalPayout = data.reduce((sum, row) => sum + parseFloat(row['Total Payout'] || 0), 0);
            const profit = totalRevenue - totalPayout;
            const profitMargin = totalRevenue > 0 ? (profit / totalRevenue * 100) : 0;
            
            const clientVisits = {};
            data.forEach(row => {
                const email = (row['Customer Email'] || '').toLowerCase().trim();
                if (email) {
                    clientVisits[email] = (clientVisits[email] || 0) + 1;
                }
            });
            
            const uniqueClients = Object.keys(clientVisits).length;
            const returningClients = Object.values(clientVisits).filter(count => count > 1).length;
            const retentionRate = uniqueClients > 0 ? (returningClients / uniqueClients * 100) : 0;
            const avgRevPerClient = uniqueClients > 0 ? totalRevenue / uniqueClients : 0;
            
            // RECOMMENDATION 1: Low Retention Rate
            if (retentionRate < 40) {
                recommendations.push({
                    priority: 'high',
                    title: 'Critical: Improve Client Retention',
                    description: `Your retention rate is ${retentionRate.toFixed(0)}%, which is below the industry target of 50%+. You're losing ${100 - retentionRate.toFixed(0)}% of clients after their first visit.`,
                    action: 'Implement an automated follow-up sequence: 24 hours (thank you), 7 days (check-in), 14 days (special offer). Set up rebooking incentives at checkout.',
                    impact: `Increasing retention to 50% could add ${formatCurrency(avgRevPerClient * uniqueClients * 0.5)} in revenue`,
                    impactValue: avgRevPerClient * uniqueClients * 0.5
                });
            }
            
            // RECOMMENDATION 2: Low Profit Margin
            if (profitMargin < 25) {
                recommendations.push({
                    priority: 'high',
                    title: 'Optimize Profit Margins',
                    description: `Your profit margin of ${profitMargin.toFixed(1)}% is below optimal (30%+). This limits growth and reinvestment capacity.`,
                    action: 'Review practitioner payout structure, optimize scheduling to reduce idle time, and consider 5-10% price increase for premium services.',
                    impact: `Improving margin to 30% would add ${formatCurrency(totalRevenue * 0.3 - profit)} to profit`,
                    impactValue: totalRevenue * 0.3 - profit
                });
            }
            
            // RECOMMENDATION 3: At-Risk Clients
            const today = new Date();
            const avgDaysBetween = 30; // Simplified
            const atRiskCount = Object.entries(clientVisits).filter(([email, visits]) => {
                if (visits <= 1) return false;
                const lastVisit = data.filter(r => r['Customer Email']?.toLowerCase().trim() === email)
                    .map(r => parseDate(r['Appointment Date']))
                    .sort((a, b) => b - a)[0];
                if (!lastVisit) return false;
                const daysSince = (today - lastVisit) / (1000 * 60 * 60 * 24);
                return daysSince > avgDaysBetween * 1.5;
            }).length;
            
            if (atRiskCount > 0) {
                const atRiskRevenue = atRiskCount * avgRevPerClient;
                recommendations.push({
                    priority: 'high',
                    title: `Re-engage ${atRiskCount} At-Risk Clients`,
                    description: `${atRiskCount} returning clients haven't visited recently. They represent ${formatCurrency(atRiskRevenue)} in historical revenue.`,
                    action: `Launch a "We miss you" campaign with a special 20% comeback offer. Personalize messages referencing their last service.`,
                    impact: `Recovering 30% could bring back ${formatCurrency(atRiskRevenue * 0.3)}`,
                    impactValue: atRiskRevenue * 0.3
                });
            }
            
            // RECOMMENDATION 4: Package Opportunities
            const avgVisitsPerClient = uniqueClients > 0 ? data.length / uniqueClients : 0;
            if (avgVisitsPerClient < 3) {
                recommendations.push({
                    priority: 'medium',
                    title: 'Create Package Deals to Increase Visit Frequency',
                    description: `Average client visits only ${avgVisitsPerClient.toFixed(1)} times. Package deals encourage commitment and increase CLV.`,
                    action: 'Create 3-pack (10% off), 5-pack (15% off), and 10-pack (20% off) bundles. Promote as "best value" at checkout.',
                    impact: `Increasing avg visits to 4 could add ${formatCurrency((4 - avgVisitsPerClient) * uniqueClients * (totalRevenue / data.length))}`,
                    impactValue: (4 - avgVisitsPerClient) * uniqueClients * (totalRevenue / data.length)
                });
            }
            
            // RECOMMENDATION 5: Intro Offer Conversion
            if (leadsData && leadsData.length > 0) {
                const hadIntro = leadsData.filter(row => isIntroOffer(row['First purchase'] || '')).length;
                const madePurchase = leadsData.filter(row => {
                    const fp = row['First purchase'] || '';
                    return fp && fp !== 'N/A' && !isIntroOffer(fp);
                }).length;
                const introConversion = hadIntro > 0 ? (madePurchase / hadIntro * 100) : 0;
                
                if (introConversion < 30 && hadIntro > 0) {
                    recommendations.push({
                        priority: 'high',
                        title: 'Boost Intro Offer to Purchase Conversion',
                        description: `Only ${introConversion.toFixed(0)}% of intro offers convert to paid purchases. Industry best practice is 35-40%.`,
                        action: 'Follow up within 24 hours of intro sessions. Offer limited-time package deal. Train staff on conversion techniques.',
                        impact: `Improving to 35% would add ${formatNumber(hadIntro * 0.35 - madePurchase)} new paying clients`,
                        impactValue: (hadIntro * 0.35 - madePurchase) * avgRevPerClient
                    });
                }
            }
            
            // RECOMMENDATION 6: Revenue per Client
            if (avgRevPerClient < 200) {
                recommendations.push({
                    priority: 'medium',
                    title: 'Increase Average Client Value',
                    description: `Your average revenue per client is ${formatCurrency(avgRevPerClient)}. Strategic upselling could significantly boost this.`,
                    action: 'Train team on consultative selling. Recommend add-ons (extended sessions, complementary services). Create premium service tier.',
                    impact: `Increasing to ${formatCurrency(avgRevPerClient * 1.25)} would add ${formatCurrency((avgRevPerClient * 1.25 - avgRevPerClient) * uniqueClients)}`,
                    impactValue: (avgRevPerClient * 1.25 - avgRevPerClient) * uniqueClients
                });
            }
            
            // RECOMMENDATION 7: Referral Program
            const newClientsNeeded = Math.max(0, uniqueClients * 0.2); // 20% growth target
            if (newClientsNeeded > 0) {
                recommendations.push({
                    priority: 'medium',
                    title: 'Launch Referral Program for Growth',
                    description: `To achieve 20% client growth, you need ${Math.ceil(newClientsNeeded)} new clients. Referrals are the most cost-effective acquisition channel.`,
                    action: 'Offer referring client $20 credit + new client 20% off first visit. Promote via email, in-office signage, and social media.',
                    impact: `${Math.ceil(newClientsNeeded)} new clients could add ${formatCurrency(newClientsNeeded * avgRevPerClient)}`,
                    impactValue: newClientsNeeded * avgRevPerClient
                });
            }
            
            // RECOMMENDATION 8: Frozen Memberships
            if (membershipsData && membershipsData.length > 0) {
                const frozenCount = membershipsData.filter(m => m.Frozen === 'Yes').length;
                const frozenRate = (frozenCount / membershipsData.length) * 100;
                
                if (frozenRate > 10) {
                    recommendations.push({
                        priority: 'high',
                        title: 'Address High Frozen Membership Rate',
                        description: `${frozenRate.toFixed(1)}% of memberships are frozen. This indicates potential dissatisfaction or life changes that might lead to cancellations.`,
                        action: 'Reach out personally to frozen members. Offer flexible restart options, pause benefits, or alternative services. Create a "comeback" special offer.',
                        impact: `Reactivating 50% of frozen members could recover ${formatCurrency((frozenCount * 0.5) * avgRevPerClient)}`,
                        impactValue: (frozenCount * 0.5) * avgRevPerClient
                    });
                } else if (frozenCount > 0) {
                    recommendations.push({
                        priority: 'medium',
                        title: 'Monitor Frozen Memberships',
                        description: `You have ${frozenCount} frozen membership${frozenCount > 1 ? 's' : ''}. Proactive outreach can prevent cancellations.`,
                        action: 'Schedule check-ins with frozen members. Understand their concerns and offer solutions to help them resume their wellness journey.',
                        impact: `Preventing cancellations protects ${formatCurrency(frozenCount * avgRevPerClient)} in potential revenue`,
                        impactValue: frozenCount * avgRevPerClient
                    });
                }
            }
            
            // RECOMMENDATION 9: Refunded Memberships
            if (membershipsData && membershipsData.length > 0) {
                const refundedCount = membershipsData.filter(m => parseFloat(m.Refunded) > 0).length;
                const totalRefunded = membershipsData.reduce((sum, m) => sum + (parseFloat(m.Refunded) || 0), 0);
                const refundRate = (refundedCount / membershipsData.length) * 100;
                
                if (refundRate > 5) {
                    recommendations.push({
                        priority: 'high',
                        title: 'Reduce Membership Refund Rate',
                        description: `${refundRate.toFixed(1)}% of memberships have been refunded (${formatCurrency(totalRefunded)} total). This suggests issues with value delivery or expectations.`,
                        action: 'Analyze refund reasons. Improve onboarding process. Set clear expectations. Consider satisfaction check-ins after first 2-3 sessions.',
                        impact: `Reducing refunds by 50% would save ${formatCurrency(totalRefunded * 0.5)}`,
                        impactValue: totalRefunded * 0.5
                    });
                } else if (refundedCount > 0) {
                    recommendations.push({
                        priority: 'low',
                        title: 'Low Refund Rate - Maintain Quality',
                        description: `Your refund rate is ${refundRate.toFixed(1)}%, which is excellent. This indicates strong value delivery and customer satisfaction.`,
                        action: 'Continue current quality standards. Document what\'s working and train all team members on best practices.',
                        impact: 'Maintaining low refund rates protects revenue and reputation',
                        impactValue: 0
                    });
                }
            }
            
            // Sort by impact value
            recommendations.sort((a, b) => b.impactValue - a.impactValue);
            
            return recommendations;
        }
        
        // Show journey stage details
        function showJourneyDetails(stage, count) {
            let title, content;
            
            switch(stage) {
                case 'leads':
                    title = 'Total Contacts';
                    content = `<p>You have <strong>${formatNumber(count)}</strong> total people in your database.</p>
                               <p>These include both leads (prospects) and customers (people who have made at least one purchase).</p>`;
                    break;
                case 'customers':
                    title = 'Converted Customers';
                    content = `<p><strong>${formatNumber(count)}</strong> people have become customers.</p>
                               <p>These are contacts who have made at least one appointment or purchase.</p>`;
                    break;
                case 'intro':
                    title = 'Tried Intro Offer';
                    content = `<p><strong>${formatNumber(count)}</strong> customers tried an introductory offer.</p>
                               <p>Intro offers are a great way to let new clients experience your services at a lower barrier to entry.</p>`;
                    break;
                case 'purchase':
                    title = 'Made First Purchase';
                    content = `<p><strong>${formatNumber(count)}</strong> customers made a paid purchase (non-intro).</p>
                               <p>This is a critical conversion point - they've decided to pay full price for your services.</p>`;
                    break;
                case 'repeat':
                    title = 'Repeat Customers (2+ visits)';
                    content = `<p><strong>${formatNumber(count)}</strong> customers have visited multiple times.</p>
                               <p>Repeat customers are your foundation - they've experienced your value and come back for more.</p>`;
                    break;
                case 'loyal':
                    title = 'Loyal Customers (5+ visits)';
                    content = `<p><strong>${formatNumber(count)}</strong> customers are loyal regulars with 5+ visits.</p>
                               <p>These are your MVPs! They trust you, love your services, and likely refer others.</p>`;
                    break;
            }
            
            showModal(title, content);
        }
        
        // CHART RENDERING FUNCTIONS
        // Helper function to calculate trendline using linear regression
        function calculateTrendline(data) {
            const n = data.length;
            if (n === 0) return [];
            
            let sumX = 0, sumY = 0, sumXY = 0, sumX2 = 0;
            
            data.forEach((y, x) => {
                sumX += x;
                sumY += y;
                sumXY += x * y;
                sumX2 += x * x;
            });
            
            const slope = (n * sumXY - sumX * sumY) / (n * sumX2 - sumX * sumX);
            const intercept = (sumY - slope * sumX) / n;
            
            return data.map((_, x) => slope * x + intercept);
        }
        
        function destroyChart(chartId) {
            if (allCharts[chartId]) {
                allCharts[chartId].destroy();
                delete allCharts[chartId];
            }
        }
        
        // Chart helper function to reduce duplicate code
        function createChart(canvasId, chartId, config) {
            const canvas = document.getElementById(canvasId);
            if (!canvas) return null;
            destroyChart(chartId);
            const ctx = canvas.getContext('2d');
            allCharts[chartId] = new Chart(ctx, config);
            return allCharts[chartId];
        }
        
        // Common chart options
        const chartDefaults = {
            responsive: true,
            maintainAspectRatio: false,
            plugins: { legend: { display: false } }
        };
        
        function renderRevenueByLocationChart() {
            const canvas = document.getElementById('revenueByLocationChart');
            if (!canvas) return;
            
            destroyChart('revenueByLocation');
            
            const revenueByLocation = {};
            filteredAppointments.forEach(row => {
                const location = row.Location || 'Unknown';
                revenueByLocation[location] = (revenueByLocation[location] || 0) + parseFloat(row.Revenue || 0);
            });
            
            const ctx = canvas.getContext('2d');
            allCharts.revenueByLocation = new Chart(ctx, {
                type: 'bar',
                data: {
                    labels: Object.keys(revenueByLocation),
                    datasets: [{
                        label: 'Revenue',
                        data: Object.values(revenueByLocation),
                        backgroundColor: '#71BED2',
                        borderColor: '#013160',
                        borderWidth: 2
                    }]
                },
                options: {
                    responsive: true,
                    maintainAspectRatio: false,
                    plugins: { legend: { display: false } },
                    scales: {
                        y: {
                            beginAtZero: true,
                            ticks: {
                                callback: function(value) {
                                    return formatCurrency(value);
                                }
                            }
                        }
                    }
                }
            });
        }
        
        function renderRevenueByServiceChart() {
            const canvas = document.getElementById('revenueByServiceChart');
            if (!canvas) return;
            
            destroyChart('revenueByService');
            
            const revenueByService = {};
            filteredAppointments.forEach(row => {
                const service = row['Appointment'] || 'Unknown';
                revenueByService[service] = (revenueByService[service] || 0) + parseFloat(row.Revenue || 0);
            });
            
            // Filter out services with $0 revenue
            const filteredServices = Object.entries(revenueByService)
                .filter(([service, revenue]) => revenue > 0)
                .sort((a, b) => b[1] - a[1])
                .slice(0, 8);
            
            const ctx = canvas.getContext('2d');
            allCharts.revenueByService = new Chart(ctx, {
                type: 'bar',
                data: {
                    labels: filteredServices.map(s => s[0].substring(0, 25)),
                    datasets: [{
                        label: 'Revenue',
                        data: filteredServices.map(s => s[1]),
                        backgroundColor: '#013160',
                        borderColor: '#71BED2',
                        borderWidth: 2
                    }]
                },
                options: {
                    responsive: true,
                    maintainAspectRatio: false,
                    onClick: (event, elements) => {
                        if (elements.length > 0) {
                            const index = elements[0].index;
                            const serviceName = filteredServices[index][0];
                            showServiceDetails(serviceName);
                        }
                    },
                    plugins: { legend: { display: false } },
                    scales: {
                        y: {
                            beginAtZero: true,
                            ticks: {
                                callback: function(value) {
                                    return formatCurrency(value);
                                }
                            }
                        }
                    }
                }
            });
        }
        
        function renderIntroSessionsChart() {
            const canvas = document.getElementById('introSessionsChart');
            if (!canvas) return;
            
            destroyChart('introSessions');
            
            const introCount = filteredAppointments.filter(row => 
                isIntroOffer(row['Appointment'])
            ).length;
            const regularCount = filteredAppointments.length - introCount;
            
            const ctx = canvas.getContext('2d');
            allCharts.introSessions = new Chart(ctx, {
                type: 'doughnut',
                data: {
                    labels: ['Intro Offers', 'Regular Sessions'],
                    datasets: [{
                        data: [introCount, regularCount],
                        backgroundColor: ['#FBB514', '#013160'],
                        borderWidth: 2,
                        borderColor: '#fff'
                    }]
                },
                options: {
                    responsive: true,
                    maintainAspectRatio: false,
                    plugins: {
                        legend: { position: 'bottom' }
                    }
                }
            });
        }
        
        function renderPaymentMethodsChart() {
            const canvas = document.getElementById('paymentMethodsChart');
            if (!canvas) return;
            
            destroyChart('paymentMethods');
            
            const paymentMethods = {};
            filteredAppointments.forEach(row => {
                const method = row['Payment Methods'] || 'Unknown';
                paymentMethods[method] = (paymentMethods[method] || 0) + 1;
            });
            
            const ctx = canvas.getContext('2d');
            allCharts.paymentMethods = new Chart(ctx, {
                type: 'pie',
                data: {
                    labels: Object.keys(paymentMethods),
                    datasets: [{
                        data: Object.values(paymentMethods),
                        backgroundColor: ['#013160', '#71BED2', '#FBB514', '#28a745', '#dc3545'],
                        borderWidth: 2,
                        borderColor: '#fff'
                    }]
                },
                options: {
                    responsive: true,
                    maintainAspectRatio: false,
                    plugins: {
                        legend: { position: 'bottom' }
                    }
                }
            });
        }
        
        function renderHeatmap() {
            const container = document.getElementById('heatmapContainer');
            if (!container) return;
            
            const days = ['Monday', 'Tuesday', 'Wednesday', 'Thursday', 'Friday', 'Saturday'];
            
            // Group appointments by location
            const locationData = {};
            filteredAppointments.forEach(row => {
                const location = row.Location || 'Unknown';
                if (!locationData[location]) {
                    locationData[location] = {};
                    days.forEach(day => {
                        locationData[location][day] = {};
                        for (let hour = 6; hour <= 21; hour++) {
                            locationData[location][day][hour] = 0;
                        }
                    });
                }
                
                const date = parseDate(row['Appointment Date']);
                const dayIndex = date.getDay();
                
                // Skip Sunday (0)
                if (dayIndex === 0) return;
                
                // Map day index to day name (1=Monday, 6=Saturday)
                const dayName = days[dayIndex - 1];
                const hour = date.getHours();
                
                if (locationData[location][dayName] && locationData[location][dayName][hour] !== undefined) {
                    locationData[location][dayName][hour]++;
                }
            });
            
            // Sort locations alphabetically
            const locations = Object.keys(locationData).sort();
            
            // Render a heatmap for each location
            let html = '';
            locations.forEach((location, index) => {
                const heatmapData = locationData[location];
                
                // Find max value for this location
                let maxValue = 0;
                Object.values(heatmapData).forEach(dayData => {
                    Object.values(dayData).forEach(count => {
                        if (count > maxValue) maxValue = count;
                    });
                });
                
                // Add location header
                html += `<div style="margin-top: ${index > 0 ? '30px' : '0'}; padding: 20px; background: ${index % 2 === 0 ? '#f8f9fa' : 'white'}; border-radius: 10px;">`;
                html += `<h3 style="margin-bottom: 15px; color: var(--primary);">${location}</h3>`;
                
                // Render table
                html += '<table class="heatmap-table"><thead><tr><th>Day</th>';
                for (let hour = 6; hour <= 21; hour++) {
                    const displayHour = hour > 12 ? `${hour - 12}p` : (hour === 12 ? '12p' : `${hour}a`);
                    html += `<th>${displayHour}</th>`;
                }
                html += '</tr></thead><tbody>';
                
                days.forEach(day => {
                    html += `<tr><td onclick="showDayOfWeekDetails('${day}', '${location}')" style="cursor: pointer; font-weight: 500;">${day}</td>`;
                    for (let hour = 6; hour <= 21; hour++) {
                        const count = heatmapData[day][hour];
                        const intensity = maxValue > 0 ? Math.ceil((count / maxValue) * 7) : 0;
                        html += `<td class="heatmap-cell heatmap-${intensity}" 
                            title="${location} - ${day} ${hour}:00 - ${count} appointments" 
                            onclick="showHourDetails('${day}', ${hour}, '${location}')" 
                            style="cursor: pointer;">${count}</td>`;
                    }
                    html += '</tr>';
                });
                
                html += '</tbody></table>';
                html += '</div>';
            });
            
            html += '<p style="margin-top: 15px; color: #666; font-size: 14px;"><strong>Tip:</strong> Click on a <strong>day name</strong> to see hourly breakdown. Click on an <strong>hour cell</strong> to see specific appointments.</p>';
            
            container.innerHTML = html;
        }
        
        function renderMembershipHeatmap() {
            const container = document.getElementById('membershipHeatmapContainer');
            if (!container) return;
            
            const days = ['Monday', 'Tuesday', 'Wednesday', 'Thursday', 'Friday', 'Saturday', 'Sunday'];
            
            // Initialize heatmap data
            const heatmapData = {};
            days.forEach(day => {
                heatmapData[day] = {};
                for (let hour = 6; hour <= 21; hour++) {
                    heatmapData[day][hour] = 0;
                }
            });
            
            // Populate heatmap with membership sales data (convert GMT to Local)
            filteredMemberships.forEach(m => {
                const localDate = m['Bought Date/Time (GMT)'] ? convertGMTtoLocal(m['Bought Date/Time (GMT)']) : null;
                if (localDate) {
                    const dayIndex = localDate.getDay(); // 0=Sunday, 1=Monday, ..., 6=Saturday
                    
                    // Skip Sunday (day 0) - you're not open on Sundays
                    if (dayIndex === 0) return;
                    
                    // Map JavaScript day index to days array index
                    // JS: 1=Mon, 2=Tue, 3=Wed, 4=Thu, 5=Fri, 6=Sat
                    // Array: 0=Mon, 1=Tue, 2=Wed, 3=Thu, 4=Fri, 5=Sat, 6=Sun
                    const dayName = days[dayIndex - 1]; // Subtract 1 to map Monday(1) to index 0
                    const hour = localDate.getHours();
                    
                    if (heatmapData[dayName] && heatmapData[dayName][hour] !== undefined) {
                        heatmapData[dayName][hour]++;
                    }
                }
            });
            
            // Find max value for color scaling
            let maxValue = 0;
            Object.values(heatmapData).forEach(dayData => {
                Object.values(dayData).forEach(count => {
                    if (count > maxValue) maxValue = count;
                });
            });
            
            // Render table
            let html = '<div style="padding: 20px; background: white; border-radius: 10px;">';
            html += '<table class="heatmap-table"><thead><tr><th>Day</th>';
            for (let hour = 6; hour <= 21; hour++) {
                const displayHour = hour > 12 ? `${hour - 12}p` : (hour === 12 ? '12p' : `${hour}a`);
                html += `<th>${displayHour}</th>`;
            }
            html += '</tr></thead><tbody>';
            
            days.forEach(day => {
                html += `<tr><td onclick="showMembershipDayDetails('${day}')" style="cursor: pointer; font-weight: 500;">${day}</td>`;
                for (let hour = 6; hour <= 21; hour++) {
                    const count = heatmapData[day][hour];
                    const intensity = maxValue > 0 ? Math.ceil((count / maxValue) * 7) : 0;
                    html += `<td class="heatmap-cell heatmap-${intensity}" 
                        title="${day} ${hour}:00 - ${count} sales"
                        onclick="showMembershipHourDetails('${day}', ${hour})"
                        style="cursor: pointer;">${count}</td>`;
                }
                html += '</tr>';
            });
            
            html += '</tbody></table>';
            html += '</div>';
            html += '<p style="margin-top: 15px; color: #666; font-size: 14px;"><strong>Tip:</strong> Click on a <strong>day name</strong> to see hourly breakdown. Click on an <strong>hour cell</strong> to see specific sales.</p>';
            
            container.innerHTML = html;
        }
        
        function showMembershipDayDetails(dayName) {
            const days = ['Monday', 'Tuesday', 'Wednesday', 'Thursday', 'Friday', 'Saturday', 'Sunday'];
            const dayIndex = days.indexOf(dayName);
            
            // Map array index to JS day index
            // Array: 0=Mon, 1=Tue, 2=Wed, 3=Thu, 4=Fri, 5=Sat, 6=Sun
            // JS getDay(): 0=Sun, 1=Mon, 2=Tue, 3=Wed, 4=Thu, 5=Fri, 6=Sat
            const jsDayIndex = dayIndex === 6 ? 0 : dayIndex + 1;
            
            const daySales = filteredMemberships.filter(m => {
                const localDate = m['Bought Date/Time (GMT)'] ? convertGMTtoLocal(m['Bought Date/Time (GMT)']) : null;
                return localDate && localDate.getDay() === jsDayIndex;
            });
            
            const revenue = daySales.reduce((sum, m) => sum + (parseFloat(m['Paid Amount']) || 0), 0);
            const uniqueCustomers = new Set(daySales.map(m => (m['Customer Email'] || '').toLowerCase())).size;
            
            // Hour breakdown
            const hourBreakdown = {};
            daySales.forEach(m => {
                const localDate = m['Bought Date/Time (GMT)'] ? convertGMTtoLocal(m['Bought Date/Time (GMT)']) : null;
                if (localDate) {
                    const hour = localDate.getHours();
                    if (!hourBreakdown[hour]) {
                        hourBreakdown[hour] = { count: 0, revenue: 0 };
                    }
                    hourBreakdown[hour].count++;
                    hourBreakdown[hour].revenue += parseFloat(m['Paid Amount']) || 0;
                }
            });
            
            const sortedHours = Object.entries(hourBreakdown)
                .sort((a, b) => b[1].count - a[1].count)
                .slice(0, 10);
            
            const hourRows = sortedHours.map(([hour, data]) => {
                const hourNum = parseInt(hour);
                const ampm = hourNum >= 12 ? 'PM' : 'AM';
                const displayHour = hourNum > 12 ? hourNum - 12 : (hourNum === 0 ? 12 : hourNum);
                return `
                    <tr>
                        <td>${displayHour}:00 ${ampm}</td>
                        <td>${data.count}</td>
                        <td>${formatCurrency(data.revenue)}</td>
                        <td>${formatCurrency(data.revenue / data.count)}</td>
                    </tr>
                `;
            }).join('');
            
            const content = `
                <div class="modal-highlight">
                    <h3>${dayName} Sales Overview</h3>
                    <div class="metrics-grid" style="grid-template-columns: repeat(3, 1fr); margin: 20px 0;">
                        <div class="metric-card compact">
                            <div class="metric-label">Total Sales</div>
                            <div class="metric-value">${daySales.length}</div>
                        </div>
                        <div class="metric-card compact">
                            <div class="metric-label">Unique Customers</div>
                            <div class="metric-value">${uniqueCustomers}</div>
                        </div>
                        <div class="metric-card compact">
                            <div class="metric-label">Total Revenue</div>
                            <div class="metric-value">${formatCurrency(revenue)}</div>
                        </div>
                    </div>
                </div>
                
                <h4>Top 10 Hours by Sales</h4>
                <table>
                    <thead>
                        <tr>
                            <th>Hour</th>
                            <th>Sales</th>
                            <th>Revenue</th>
                            <th>Avg Sale</th>
                        </tr>
                    </thead>
                    <tbody>
                        ${hourRows || '<tr><td colspan="4" style="text-align: center; color: #999;">No sales data for this day</td></tr>'}
                    </tbody>
                </table>
            `;
            
            showModal(`${dayName} Sales Details`, content);
        }
        
        function showMembershipHourDetails(dayName, hour) {
            const days = ['Monday', 'Tuesday', 'Wednesday', 'Thursday', 'Friday', 'Saturday', 'Sunday'];
            const dayIndex = days.indexOf(dayName);
            const jsDayIndex = dayIndex === 6 ? 0 : dayIndex + 1;
            
            const hourSales = filteredMemberships.filter(m => {
                const localDate = m['Bought Date/Time (GMT)'] ? convertGMTtoLocal(m['Bought Date/Time (GMT)']) : null;
                if (!localDate) return false;
                return localDate.getDay() === jsDayIndex && localDate.getHours() === hour;
            });
            
            const revenue = hourSales.reduce((sum, m) => sum + (parseFloat(m['Paid Amount']) || 0), 0);
            
            const ampm = hour >= 12 ? 'PM' : 'AM';
            const displayHour = hour > 12 ? hour - 12 : (hour === 0 ? 12 : hour);
            
            // Helper function to format name as "First L."
            const formatName = (firstName, lastName) => {
                if (!firstName && !lastName) return 'Unknown';
                const first = (firstName || '').trim();
                const last = (lastName || '').trim();
                if (!last) return first;
                return `${first} ${last.charAt(0)}.`;
            };
            
            const salesRows = hourSales.map(m => {
                // Get customer name
                const customerFirst = m['First Name'] || m['Customer First Name'] || '';
                const customerLast = m['Last Name'] || m['Customer Last Name'] || '';
                const customerName = formatName(customerFirst, customerLast);
                
                // Get sold by name - field is 'Sold by' (lowercase b)
                let soldByFull = m['Sold by'] || '';
                
                // Check if this customer has a first VSP from the tracking
                const email = (m['Customer Email'] || '').toLowerCase().trim();
                if (email && window.customerFirstVSP && window.customerFirstVSP[email]) {
                    soldByFull = window.customerFirstVSP[email].vsp || soldByFull;
                }
                
                let soldByFormatted = 'Direct/Online';
                if (soldByFull && soldByFull !== 'N/A' && soldByFull !== '') {
                    const nameParts = soldByFull.trim().split(/\s+/);
                    if (nameParts.length >= 2) {
                        soldByFormatted = `${nameParts[0]} ${nameParts[nameParts.length - 1].charAt(0)}.`;
                    } else if (nameParts.length === 1) {
                        soldByFormatted = nameParts[0];
                    }
                }
                
                // Convert date to Central Time for display
                const gmtDate = m['Bought Date/Time (GMT)'] ? convertGMTtoLocal(m['Bought Date/Time (GMT)']) : null;
                const centralDate = gmtDate ? convertGMTtoLocal(m['Bought Date/Time (GMT)']) : null;
                const dateDisplay = centralDate ? centralDate.toLocaleString() : 'N/A';
                
                return `
                    <tr>
                        <td>${customerName}</td>
                        <td>${m['Membership Name'] || 'Unknown'}</td>
                        <td>${formatCurrency(parseFloat(m['Paid Amount']) || 0)}</td>
                        <td>${dateDisplay}</td>
                        <td>${soldByFormatted}</td>
                    </tr>
                `;
            }).join('');
            
            const content = `
                <div class="modal-highlight">
                    <h3>${dayName} at ${displayHour}:00 ${ampm}</h3>
                    <div class="metrics-grid" style="grid-template-columns: repeat(2, 1fr); margin: 20px 0;">
                        <div class="metric-card compact">
                            <div class="metric-label">Total Sales</div>
                            <div class="metric-value">${hourSales.length}</div>
                        </div>
                        <div class="metric-card compact">
                            <div class="metric-label">Total Revenue</div>
                            <div class="metric-value">${formatCurrency(revenue)}</div>
                        </div>
                    </div>
                </div>
                
                <h4>All Sales</h4>
                <table>
                    <thead>
                        <tr>
                            <th>Customer</th>
                            <th>Membership</th>
                            <th>Amount</th>
                            <th>Date/Time</th>
                            <th>Sold By</th>
                        </tr>
                    </thead>
                    <tbody>
                        ${salesRows || '<tr><td colspan="5" style="text-align: center; color: #999;">No sales for this time slot</td></tr>'}
                    </tbody>
                </table>
            `;
            
            showModal(`${dayName} ${displayHour}:00 ${ampm} Sales`, content);
        }
        
        function renderLTVDistributionChart(tier1, tier2, tier3, tier4, tier5, tier6) {
            const canvas = document.getElementById('ltvDistributionChart');
            if (!canvas) return;
            
            destroyChart('ltvDistribution');
            
            // Get current tier configuration
            const currentTierConfig = LTV_TIERS[CONFIG.ltvTiers];
            const ranges = currentTierConfig.ranges;
            
            // Format labels
            const formatK = (num) => num >= 1000 ? `$${(num/1000).toFixed(num % 1000 === 0 ? 0 : 1)}K` : `$${num}`;
            const labels = [
                `$1-${formatK(ranges[0])}`,
                `${formatK(ranges[0])}-${formatK(ranges[1])}`,
                `${formatK(ranges[1])}-${formatK(ranges[2])}`,
                `${formatK(ranges[2])}-${formatK(ranges[3])}`,
                `${formatK(ranges[3])}-${formatK(ranges[4])}`,
                ranges[5] === Infinity ? `${formatK(ranges[4])}+` : `${formatK(ranges[4])}-${formatK(ranges[5])}+`
            ];
            
            const ctx = canvas.getContext('2d');
            allCharts.ltvDistribution = new Chart(ctx, {
                type: 'bar',
                data: {
                    labels: labels,
                    datasets: [{
                        label: 'Customers',
                        data: [tier1, tier2, tier3, tier4, tier5, tier6],
                        backgroundColor: ['#dc3545', '#ffc107', '#71BED2', '#013160', '#28a745', '#9c27b0']
                    }]
                },
                options: {
                    responsive: true,
                    maintainAspectRatio: false,
                    onClick: (event, elements) => {
                        if (elements.length > 0) {
                            const index = elements[0].index;
                            const values = [tier1, tier2, tier3, tier4, tier5, tier6];
                            showLTVDetails(labels[index], values[index]);
                        }
                    },
                    plugins: { 
                        legend: { display: false },
                        tooltip: {
                            callbacks: {
                                label: function(context) {
                                    const total = tier1 + tier2 + tier3 + tier4 + tier5 + tier6;
                                    const percentage = total > 0 ? ((context.parsed.y / total) * 100).toFixed(1) : 0;
                                    return `${formatNumber(context.parsed.y)} customers (${percentage}%)`;
                                }
                            }
                        }
                    },
                    scales: { 
                        y: { 
                            beginAtZero: true,
                            ticks: {
                                stepSize: 1
                            }
                        } 
                    }
                }
            });
        }
        
        function renderCustomerTypesChart(customers, leads) {
            const canvas = document.getElementById('customerTypesChart');
            if (!canvas) return;
            
            destroyChart('customerTypes');
            
            const ctx = canvas.getContext('2d');
            allCharts.customerTypes = new Chart(ctx, {
                type: 'doughnut',
                data: {
                    labels: ['Customers', 'Leads'],
                    datasets: [{
                        data: [customers, leads],
                        backgroundColor: ['#013160', '#71BED2'],
                        borderWidth: 2,
                        borderColor: '#fff'
                    }]
                },
                options: {
                    responsive: true,
                    maintainAspectRatio: false,
                    plugins: { legend: { position: 'bottom' } }
                }
            });
        }

        function renderVisitFrequencyChart(visitDist) {
            const canvas = document.getElementById('visitFrequencyChart');
            if (!canvas) return;
            
            destroyChart('visitFrequency');
            
            const ctx = canvas.getContext('2d');
            allCharts.visitFrequency = new Chart(ctx, {
                type: 'bar',
                data: {
                    labels: Object.keys(visitDist),
                    datasets: [{
                        label: 'Clients',
                        data: Object.values(visitDist),
                        backgroundColor: ['#dc3545', '#ffc107', '#71BED2', '#013160', '#28a745']
                    }]
                },
                options: {
                    responsive: true,
                    maintainAspectRatio: false,
                    onClick: (event, elements) => {
                        if (elements.length > 0) {
                            const index = elements[0].index;
                            const labels = Object.keys(visitDist);
                            const values = Object.values(visitDist);
                            showVisitFrequencyDetails(labels[index], values[index]);
                        }
                    },
                    plugins: { legend: { display: false } },
                    scales: { y: { beginAtZero: true } }
                }
            });
        }

        function renderRetentionBreakdownChart(oneTime, returning) {
            const canvas = document.getElementById('retentionBreakdownChart');
            if (!canvas) return;
            
            destroyChart('retentionBreakdown');
            
            const ctx = canvas.getContext('2d');
            allCharts.retentionBreakdown = new Chart(ctx, {
                type: 'doughnut',
                data: {
                    labels: ['One-Time Visitors', 'Returning Clients'],
                    datasets: [{
                        data: [oneTime, returning],
                        backgroundColor: ['#dc3545', '#28a745'],
                        borderWidth: 2,
                        borderColor: '#fff'
                    }]
                },
                options: {
                    responsive: true,
                    maintainAspectRatio: false,
                    onClick: (event, elements) => {
                        if (elements.length > 0) {
                            const index = elements[0].index;
                            const labels = ['One-Time Visitors', 'Returning Clients'];
                            const values = [oneTime, returning];
                            showRetentionDetails(labels[index], values[index]);
                        }
                    },
                    plugins: { 
                        legend: { position: 'bottom' },
                        tooltip: {
                            callbacks: {
                                label: function(context) {
                                    const total = oneTime + returning;
                                    const percentage = ((context.parsed / total) * 100).toFixed(1);
                                    return `${context.label}: ${formatNumber(context.parsed)} (${percentage}%)`;
                                }
                            }
                        }
                    }
                }
            });
        }
        
        function renderPractitionerCharts(practitionerData) {
            // Revenue chart
            const revenueCanvas = document.getElementById('practitionerRevenueChart');
            if (revenueCanvas) {
                destroyChart('practitionerRevenue');
                
                const sorted = Object.entries(practitionerData)
                    .sort((a, b) => b[1].revenue - a[1].revenue);
                
                const ctx = revenueCanvas.getContext('2d');
                allCharts.practitionerRevenue = new Chart(ctx, {
                    type: 'bar',
                    data: {
                        labels: sorted.map(p => p[0]),
                        datasets: [{
                            label: 'Revenue',
                            data: sorted.map(p => p[1].revenue),
                            backgroundColor: '#FBB514',
                            borderColor: '#013160',
                            borderWidth: 2
                        }]
                    },
                    options: {
                        responsive: true,
                        maintainAspectRatio: false,
                        indexAxis: 'y',
                        onClick: (event, elements) => {
                            if (elements.length > 0) {
                                const index = elements[0].index;
                                const practitionerName = sorted[index][0];
                                showPractitionerDetails(practitionerName);
                            }
                        },
                        plugins: { legend: { display: false } },
                        scales: {
                            x: {
                                beginAtZero: true,
                                ticks: {
                                    callback: function(value) {
                                        return formatCurrency(value);
                                    }
                                }
                            }
                        }
                    }
                });
            }
            
            // Appointments chart
            const apptsCanvas = document.getElementById('practitionerApptsChart');
            if (apptsCanvas) {
                destroyChart('practitionerAppts');
                
                const sorted = Object.entries(practitionerData)
                    .sort((a, b) => b[1].appointments - a[1].appointments);
                
                const ctx = apptsCanvas.getContext('2d');
                allCharts.practitionerAppts = new Chart(ctx, {
                    type: 'bar',
                    data: {
                        labels: sorted.map(p => p[0]),
                        datasets: [{
                            label: 'Appointments',
                            data: sorted.map(p => p[1].appointments),
                            backgroundColor: '#71BED2',
                            borderColor: '#013160',
                            borderWidth: 2
                        }]
                    },
                    options: {
                        responsive: true,
                        maintainAspectRatio: false,
                        indexAxis: 'y',
                        onClick: (event, elements) => {
                            if (elements.length > 0) {
                                const index = elements[0].index;
                                const practitionerName = sorted[index][0];
                                showPractitionerDetails(practitionerName);
                            }
                        },
                        plugins: { legend: { display: false } },
                        scales: { x: { beginAtZero: true } }
                    }
                });
            }
        }
        
        function renderTimelineCharts(dailyData, dates) {
            // Fees timeline chart (stacked)
            const feesCanvas = document.getElementById('feesTimelineChart');
            if (feesCanvas) {
                destroyChart('feesTimeline');
                
                const ctx = feesCanvas.getContext('2d');
                const franchiseFees = dates.map(date => dailyData[date].revenue * CONFIG.franchiseFeePercent / 100);
                const brandFunds = dates.map(date => dailyData[date].revenue * CONFIG.brandFundPercent / 100);
                const ccFees = dates.map(date => dailyData[date].revenue * CONFIG.ccFeesPercent / 100);
                
                allCharts.feesTimeline = new Chart(ctx, {
                    type: 'bar',
                    data: {
                        labels: dates,
                        datasets: [
                            {
                                label: 'Franchise Fee',
                                data: franchiseFees,
                                backgroundColor: 'rgba(1, 49, 96, 0.8)',
                                borderColor: 'rgba(1, 49, 96, 1)',
                                borderWidth: 1
                            },
                            {
                                label: 'Brand Fund',
                                data: brandFunds,
                                backgroundColor: 'rgba(113, 190, 210, 0.8)',
                                borderColor: 'rgba(113, 190, 210, 1)',
                                borderWidth: 1
                            },
                            {
                                label: 'CC Processing',
                                data: ccFees,
                                backgroundColor: 'rgba(251, 181, 20, 0.8)',
                                borderColor: 'rgba(251, 181, 20, 1)',
                                borderWidth: 1
                            }
                        ]
                    },
                    options: {
                        responsive: true,
                        maintainAspectRatio: false,
                        scales: {
                            x: { stacked: true },
                            y: {
                                stacked: true,
                                beginAtZero: true,
                                ticks: {
                                    callback: function(value) {
                                        return formatCurrency(value);
                                    }
                                }
                            }
                        },
                        plugins: {
                            legend: { position: 'bottom' },
                            tooltip: {
                                callbacks: {
                                    label: function(context) {
                                        return context.dataset.label + ': ' + formatCurrency(context.parsed.y);
                                    }
                                }
                            }
                        }
                    }
                });
            }
            
            // Daily revenue chart
            const revenueCanvas = document.getElementById('dailyRevenueChart');
            if (revenueCanvas) {
                destroyChart('dailyRevenue');
                
                const ctx = revenueCanvas.getContext('2d');
                const revenueData = dates.map(date => dailyData[date].revenue);
                const trendlineData = calculateTrendline(revenueData);
                
                allCharts.dailyRevenue = new Chart(ctx, {
                    type: 'line',
                    data: {
                        labels: dates,
                        datasets: [
                            {
                                label: 'Daily Revenue',
                                data: revenueData,
                                borderColor: '#71BED2',
                                backgroundColor: 'rgba(113, 190, 210, 0.1)',
                                borderWidth: 3,
                                fill: true,
                                tension: 0.4,
                                order: 1
                            },
                            {
                                label: 'Trend',
                                data: trendlineData,
                                borderColor: 'rgba(113, 190, 210, 0.7)',
                                backgroundColor: 'transparent',
                                borderWidth: 3,
                                borderDash: [5, 5],
                                fill: false,
                                tension: 0,
                                pointRadius: 0,
                                order: 2
                            }
                        ]
                    },
                    options: {
                        responsive: true,
                        maintainAspectRatio: false,
                        plugins: { legend: { display: false } },
                        scales: {
                            y: {
                                beginAtZero: true,
                                ticks: {
                                    callback: function(value) {
                                        return formatCurrency(value);
                                    }
                                }
                            }
                        }
                    }
                });
            }
            
            // Cumulative revenue chart
            const cumulativeCanvas = document.getElementById('cumulativeRevenueChart');
            if (cumulativeCanvas) {
                destroyChart('cumulativeRevenue');
                
                let cumulative = 0;
                const cumulativeData = dates.map(date => {
                    cumulative += dailyData[date].revenue;
                    return cumulative;
                });
                
                const cumulativeTrendline = calculateTrendline(cumulativeData);
                
                const ctx = cumulativeCanvas.getContext('2d');
                allCharts.cumulativeRevenue = new Chart(ctx, {
                    type: 'line',
                    data: {
                        labels: dates,
                        datasets: [
                            {
                                label: 'Cumulative Revenue',
                                data: cumulativeData,
                                borderColor: '#28a745',
                                backgroundColor: 'rgba(40, 167, 69, 0.1)',
                                borderWidth: 3,
                                fill: true,
                                tension: 0.4,
                                order: 1
                            },
                            {
                                label: 'Trend',
                                data: cumulativeTrendline,
                                borderColor: 'rgba(40, 167, 69, 0.7)',
                                backgroundColor: 'transparent',
                                borderWidth: 3,
                                borderDash: [5, 5],
                                fill: false,
                                tension: 0,
                                pointRadius: 0,
                                order: 2
                            }
                        ]
                    },
                    options: {
                        responsive: true,
                        maintainAspectRatio: false,
                        plugins: { legend: { display: false } },
                        scales: {
                            y: {
                                beginAtZero: true,
                                ticks: {
                                    callback: function(value) {
                                        return formatCurrency(value);
                                    }
                                }
                            }
                        }
                    }
                });
            }
            
            // Daily appointments chart
            const apptsCanvas = document.getElementById('dailyAppointmentsChart');
            if (apptsCanvas) {
                destroyChart('dailyAppointments');
                
                const ctx = apptsCanvas.getContext('2d');
                const apptsData = dates.map(date => dailyData[date].appointments);
                const apptsTrendline = calculateTrendline(apptsData);
                
                allCharts.dailyAppointments = new Chart(ctx, {
                    type: 'line',
                    data: {
                        labels: dates,
                        datasets: [
                            {
                                label: 'Daily Appointments',
                                data: apptsData,
                                borderColor: '#013160',
                                backgroundColor: 'rgba(1, 49, 96, 0.1)',
                                borderWidth: 3,
                                fill: true,
                                tension: 0.4,
                                order: 1
                            },
                            {
                                label: 'Trend',
                                data: apptsTrendline,
                                borderColor: 'rgba(1, 49, 96, 0.7)',
                                backgroundColor: 'transparent',
                                borderWidth: 3,
                                borderDash: [5, 5],
                                fill: false,
                                tension: 0,
                                pointRadius: 0,
                                order: 2
                            }
                        ]
                    },
                    options: {
                        responsive: true,
                        maintainAspectRatio: false,
                        plugins: { legend: { display: false } },
                        scales: {
                            y: {
                                beginAtZero: true,
                                ticks: { stepSize: 1 }
                            }
                        }
                    }
                });
            }
            
            // Daily profit chart
            const profitCanvas = document.getElementById('dailyProfitChart');
            if (profitCanvas) {
                destroyChart('dailyProfit');
                
                const ctx = profitCanvas.getContext('2d');
                const profitData = dates.map(date => dailyData[date].profit);
                const profitTrendline = calculateTrendline(profitData);
                
                allCharts.dailyProfit = new Chart(ctx, {
                    type: 'line',
                    data: {
                        labels: dates,
                        datasets: [
                            {
                                label: 'Daily Profit',
                                data: profitData,
                                borderColor: '#FBB514',
                                backgroundColor: 'rgba(251, 181, 20, 0.1)',
                                borderWidth: 3,
                                fill: true,
                                tension: 0.4,
                                order: 1
                            },
                            {
                                label: 'Trend',
                                data: profitTrendline,
                                borderColor: 'rgba(251, 181, 20, 0.7)',
                                backgroundColor: 'transparent',
                                borderWidth: 3,
                                borderDash: [5, 5],
                                fill: false,
                                tension: 0,
                                pointRadius: 0,
                                order: 2
                            }
                        ]
                    },
                    options: {
                        responsive: true,
                        maintainAspectRatio: false,
                        plugins: { legend: { display: false } },
                        scales: {
                            y: {
                                beginAtZero: true,
                                ticks: {
                                    callback: function(value) {
                                        return formatCurrency(value);
                                    }
                                }
                            }
                        }
                    }
                });
            }
            
            // Daily revenue per appointment chart
            const revenuePerApptCanvas = document.getElementById('dailyRevenuePerApptChart');
            if (revenuePerApptCanvas) {
                destroyChart('dailyRevenuePerAppt');
                
                const ctx = revenuePerApptCanvas.getContext('2d');
                const revenuePerApptData = dates.map(date => {
                    return dailyData[date].appointments > 0 
                        ? dailyData[date].revenue / dailyData[date].appointments 
                        : 0;
                });
                const revenuePerApptTrendline = calculateTrendline(revenuePerApptData);
                
                allCharts.dailyRevenuePerAppt = new Chart(ctx, {
                    type: 'line',
                    data: {
                        labels: dates,
                        datasets: [
                            {
                                label: 'Revenue per Appointment',
                                data: revenuePerApptData,
                                borderColor: '#9c27b0',
                                backgroundColor: 'rgba(156, 39, 176, 0.1)',
                                borderWidth: 3,
                                fill: true,
                                tension: 0.4,
                                order: 1
                            },
                            {
                                label: 'Trend',
                                data: revenuePerApptTrendline,
                                borderColor: 'rgba(156, 39, 176, 0.7)',
                                backgroundColor: 'transparent',
                                borderWidth: 3,
                                borderDash: [5, 5],
                                fill: false,
                                tension: 0,
                                pointRadius: 0,
                                order: 2
                            }
                        ]
                    },
                    options: {
                        responsive: true,
                        maintainAspectRatio: false,
                        plugins: { legend: { display: false } },
                        scales: {
                            y: {
                                beginAtZero: true,
                                ticks: {
                                    callback: function(value) {
                                        return formatCurrency(value);
                                    }
                                }
                            }
                        }
                    }
                });
            }
            
            // Daily hours chart
            const hoursCanvas = document.getElementById('dailyHoursChart');
            if (hoursCanvas) {
                destroyChart('dailyHours');
                
                const ctx = hoursCanvas.getContext('2d');
                const hoursData = dates.map(date => dailyData[date].hours);
                const hoursTrendline = calculateTrendline(hoursData);
                
                allCharts.dailyHours = new Chart(ctx, {
                    type: 'line',
                    data: {
                        labels: dates,
                        datasets: [
                            {
                                label: 'Daily Hours',
                                data: hoursData,
                                borderColor: '#ff6384',
                                backgroundColor: 'rgba(255, 99, 132, 0.1)',
                                borderWidth: 3,
                                fill: true,
                                tension: 0.4,
                                order: 1
                            },
                            {
                                label: 'Trend',
                                data: hoursTrendline,
                                borderColor: 'rgba(255, 99, 132, 0.7)',
                                backgroundColor: 'transparent',
                                borderWidth: 3,
                                borderDash: [5, 5],
                                fill: false,
                                tension: 0,
                                pointRadius: 0,
                                order: 2
                            }
                        ]
                    },
                    options: {
                        responsive: true,
                        maintainAspectRatio: false,
                        plugins: { legend: { display: false } },
                        scales: {
                            y: {
                                beginAtZero: true,
                                ticks: {
                                    callback: function(value) {
                                        return value.toFixed(1) + ' hrs';
                                    }
                                }
                            }
                        }
                    }
                });
            }
            
            // Daily utilization chart
            const utilizationCanvas = document.getElementById('dailyUtilizationChart');
            if (utilizationCanvas) {
                destroyChart('dailyUtilization');
                
                const ctx = utilizationCanvas.getContext('2d');
                const utilizationData = dates.map(date => dailyData[date].utilization);
                const utilizationTrendline = calculateTrendline(utilizationData.map(v => v || 0));
                
                allCharts.dailyUtilization = new Chart(ctx, {
                    type: 'line',
                    data: {
                        labels: dates,
                        datasets: [
                            {
                                label: 'Daily Utilization %',
                                data: utilizationData,
                                borderColor: '#28a745',
                                backgroundColor: 'rgba(40, 167, 69, 0.1)',
                                borderWidth: 3,
                                fill: true,
                                tension: 0.4,
                                spanGaps: true,
                                order: 1
                            },
                            {
                                label: 'Trend',
                                data: utilizationTrendline,
                                borderColor: 'rgba(40, 167, 69, 0.7)',
                                backgroundColor: 'transparent',
                                borderWidth: 3,
                                borderDash: [5, 5],
                                fill: false,
                                tension: 0,
                                pointRadius: 0,
                                order: 2
                            }
                        ]
                    },
                    options: {
                        responsive: true,
                        maintainAspectRatio: false,
                        plugins: { legend: { display: false } },
                        scales: {
                            y: {
                                beginAtZero: true,
                                max: 100,
                                ticks: {
                                    callback: function(value) {
                                        return value.toFixed(0) + '%';
                                    }
                                }
                            }
                        }
                    }
                });
            }
            
            // New vs Returning clients chart
            const clientTypeCanvas = document.getElementById('dailyClientTypeChart');
            if (clientTypeCanvas) {
                destroyChart('dailyClientType');
                
                const ctx = clientTypeCanvas.getContext('2d');
                allCharts.dailyClientType = new Chart(ctx, {
                    type: 'bar',
                    data: {
                        labels: dates,
                        datasets: [
                            {
                                label: 'New Clients',
                                data: dates.map(date => dailyData[date].newClients.size),
                                backgroundColor: '#28a745',
                                borderColor: '#218838',
                                borderWidth: 1
                            },
                            {
                                label: 'Returning Clients',
                                data: dates.map(date => dailyData[date].returningClients.size),
                                backgroundColor: '#71BED2',
                                borderColor: '#5aa8bf',
                                borderWidth: 1
                            }
                        ]
                    },
                    options: {
                        responsive: true,
                        maintainAspectRatio: false,
                        plugins: { 
                            legend: { 
                                display: true,
                                position: 'top'
                            } 
                        },
                        scales: {
                            x: { stacked: true },
                            y: { 
                                stacked: true,
                                beginAtZero: true,
                                ticks: { stepSize: 1 }
                            }
                        }
                    }
                });
            }
        }
        
        // Render membership charts in timeline tab
        function renderMembershipTimelineCharts() {
            // Only render if memberships data is available
            if (!filteredMemberships || filteredMemberships.length === 0) {
                return;
            }
            
            // Weekly Sales Trend Chart
            const weeklyCanvas = document.getElementById('membershipWeeklyChart');
            if (weeklyCanvas) {
                destroyChart('membershipWeekly');
                const ctx = weeklyCanvas.getContext('2d');
                
                // Group by week
                const weeklyData = {};
                filteredMemberships.forEach(m => {
                    const boughtDate = m['Bought Date/Time (GMT)'] ? convertGMTtoLocal(m['Bought Date/Time (GMT)']) : null;
                    if (boughtDate) {
                        const year = boughtDate.getFullYear();
                        const week = Math.ceil((boughtDate - new Date(year, 0, 1)) / (7 * 24 * 60 * 60 * 1000));
                        const weekKey = `${year}-W${String(week).padStart(2, '0')}`;
                        if (!weeklyData[weekKey]) {
                            weeklyData[weekKey] = { count: 0, revenue: 0 };
                        }
                        weeklyData[weekKey].count++;
                        weeklyData[weekKey].revenue += parseFloat(m['Paid Amount']) || 0;
                    }
                });
                
                const sortedWeeks = Object.keys(weeklyData).sort();
                
                allCharts.membershipWeekly = new Chart(ctx, {
                    type: 'line',
                    data: {
                        labels: sortedWeeks,
                        datasets: [
                            {
                                label: 'Weekly Sales Count',
                                data: sortedWeeks.map(w => weeklyData[w].count),
                                borderColor: '#007bff',
                                backgroundColor: 'rgba(0, 123, 255, 0.1)',
                                borderWidth: 2,
                                fill: true,
                                tension: 0.4,
                                yAxisID: 'y'
                            },
                            {
                                label: 'Weekly Revenue',
                                data: sortedWeeks.map(w => weeklyData[w].revenue),
                                borderColor: '#28a745',
                                backgroundColor: 'rgba(40, 167, 69, 0.1)',
                                borderWidth: 2,
                                fill: true,
                                tension: 0.4,
                                yAxisID: 'y1'
                            }
                        ]
                    },
                    options: {
                        responsive: true,
                        maintainAspectRatio: false,
                        plugins: {
                            legend: {
                                display: true,
                                position: 'top'
                            }
                        },
                        scales: {
                            y: {
                                type: 'linear',
                                display: true,
                                position: 'left',
                                beginAtZero: true,
                                ticks: { stepSize: 1 }
                            },
                            y1: {
                                type: 'linear',
                                display: true,
                                position: 'right',
                                beginAtZero: true,
                                grid: {
                                    drawOnChartArea: false
                                },
                                ticks: {
                                    callback: function(value) {
                                        return formatCurrency(value);
                                    }
                                }
                            }
                        }
                    }
                });
            }
            
            // Average Sale Value Over Time Chart
            const avgValueCanvas = document.getElementById('membershipAvgValueChart');
            if (avgValueCanvas) {
                destroyChart('membershipAvgValue');
                const ctx = avgValueCanvas.getContext('2d');
                
                // Group by week to calculate averages
                const weeklyRevenue = {};
                filteredMemberships.forEach(m => {
                    const boughtDate = m['Bought Date/Time (GMT)'] ? convertGMTtoLocal(m['Bought Date/Time (GMT)']) : null;
                    if (boughtDate) {
                        const year = boughtDate.getFullYear();
                        const week = Math.ceil((boughtDate - new Date(year, 0, 1)) / (7 * 24 * 60 * 60 * 1000));
                        const weekKey = `${year}-W${String(week).padStart(2, '0')}`;
                        if (!weeklyRevenue[weekKey]) {
                            weeklyRevenue[weekKey] = [];
                        }
                        weeklyRevenue[weekKey].push(parseFloat(m['Paid Amount']) || 0);
                    }
                });
                
                const sortedWeeks = Object.keys(weeklyRevenue).sort();
                
                // Calculate average value per week
                const weeklyAvg = {};
                sortedWeeks.forEach(week => {
                    const values = weeklyRevenue[week];
                    if (values.length > 0) {
                        weeklyAvg[week] = values.reduce((sum, v) => sum + v, 0) / values.length;
                    } else {
                        weeklyAvg[week] = 0;
                    }
                });
                
                allCharts.membershipAvgValue = new Chart(ctx, {
                    type: 'line',
                    data: {
                        labels: sortedWeeks,
                        datasets: [{
                            label: 'Average Membership Sale Value (Weekly Average)',
                            data: sortedWeeks.map(w => weeklyAvg[w]),
                            borderColor: '#ff6384',
                            backgroundColor: 'rgba(255, 99, 132, 0.1)',
                            borderWidth: 2,
                            fill: true,
                            tension: 0.4
                        }]
                    },
                    options: {
                        responsive: true,
                        maintainAspectRatio: false,
                        plugins: { 
                            legend: { 
                                display: true,
                                position: 'top',
                                labels: {
                                    font: {
                                        size: 12,
                                        weight: 'bold'
                                    }
                                }
                            },
                            title: {
                                display: true,
                                text: 'Note: Values represent weekly averages',
                                font: {
                                    size: 10,
                                    style: 'italic'
                                },
                                color: '#666',
                                padding: {
                                    top: 5,
                                    bottom: 10
                                }
                            }
                        },
                        scales: {
                            y: {
                                beginAtZero: true,
                                ticks: {
                                    callback: function(value) {
                                        return formatCurrency(value);
                                    }
                                }
                            }
                        }
                    }
                });
            }
        }
        
        // Render leads timeline charts with location breakdown and click handlers
        function renderLeadsTimelineCharts() {
            if (!filteredLeadsConverted || filteredLeadsConverted.length === 0) return;
            
            // Group leads by date
            const leadsByDate = {};
            const leadsByLocationAndDate = {};
            const locations = new Set();
            
            filteredLeadsConverted.forEach(lead => {
                const convertedDate = parseDate(lead['Converted']);
                if (!convertedDate) return;
                
                const dateKey = convertedDate.toISOString().split('T')[0];
                const location = lead['Home location'] || 'Unknown';
                
                locations.add(location);
                
                // Total leads by date
                if (!leadsByDate[dateKey]) {
                    leadsByDate[dateKey] = { count: 0, leads: [] };
                }
                leadsByDate[dateKey].count++;
                leadsByDate[dateKey].leads.push(lead);
                
                // Leads by location and date
                if (!leadsByLocationAndDate[location]) {
                    leadsByLocationAndDate[location] = {};
                }
                if (!leadsByLocationAndDate[location][dateKey]) {
                    leadsByLocationAndDate[location][dateKey] = { count: 0, leads: [] };
                }
                leadsByLocationAndDate[location][dateKey].count++;
                leadsByLocationAndDate[location][dateKey].leads.push(lead);
            });
            
            const sortedDates = Object.keys(leadsByDate).sort();
            const locationsArray = Array.from(locations).sort();
            
            // Store data globally for click handlers
            window.leadsTimelineData = { leadsByDate, leadsByLocationAndDate, sortedDates, locations: locationsArray };
            
            // Chart 1: All leads over time
            const allCanvas = document.getElementById('leadsTimelineAllChart');
            if (allCanvas) {
                destroyChart('leadsTimelineAll');
                const ctx = allCanvas.getContext('2d');
                allCharts.leadsTimelineAll = new Chart(ctx, {
                    type: 'bar',
                    data: {
                        labels: sortedDates.map(d => new Date(d).toLocaleDateString('en-US', { month: 'short', day: 'numeric' })),
                        datasets: [{
                            label: 'Daily Leads',
                            data: sortedDates.map(d => leadsByDate[d].count),
                            backgroundColor: '#013160',
                            borderColor: '#013160',
                            borderWidth: 1
                        }]
                    },
                    options: {
                        responsive: true,
                        maintainAspectRatio: false,
                        onClick: (event, elements) => {
                            if (elements.length > 0) {
                                const index = elements[0].index;
                                const date = sortedDates[index];
                                showLeadsTimelineDetails(date, leadsByDate[date].leads, 'All Locations');
                            }
                        },
                        plugins: {
                            legend: { display: false },
                            tooltip: {
                                callbacks: {
                                    label: function(context) {
                                        return `${formatNumber(context.parsed.y)} leads`;
                                    }
                                }
                            }
                        },
                        scales: {
                            y: {
                                beginAtZero: true,
                                ticks: { stepSize: 1 }
                            }
                        }
                    }
                });
            }
            
            // Chart 2: Stacked by location
            const stackedCanvas = document.getElementById('leadsTimelineLocationStackedChart');
            if (stackedCanvas) {
                destroyChart('leadsTimelineLocationStacked');
                const ctx = stackedCanvas.getContext('2d');
                
                const colors = ['#013160', '#71BED2', '#FBB514', '#28a745', '#dc3545', '#ffc107', '#9c27b0', '#ff5722'];
                
                const datasets = locationsArray.map((location, i) => ({
                    label: location,
                    data: sortedDates.map(d => leadsByLocationAndDate[location][d]?.count || 0),
                    backgroundColor: colors[i % colors.length],
                    borderColor: colors[i % colors.length],
                    borderWidth: 1
                }));
                
                allCharts.leadsTimelineLocationStacked = new Chart(ctx, {
                    type: 'bar',
                    data: {
                        labels: sortedDates.map(d => new Date(d).toLocaleDateString('en-US', { month: 'short', day: 'numeric' })),
                        datasets: datasets
                    },
                    options: {
                        responsive: true,
                        maintainAspectRatio: false,
                        onClick: (event, elements) => {
                            if (elements.length > 0) {
                                const index = elements[0].index;
                                const datasetIndex = elements[0].datasetIndex;
                                const date = sortedDates[index];
                                const location = locationsArray[datasetIndex];
                                const leads = leadsByLocationAndDate[location][date]?.leads || [];
                                showLeadsTimelineDetails(date, leads, location);
                            }
                        },
                        plugins: {
                            legend: {
                                display: true,
                                position: 'top'
                            }
                        },
                        scales: {
                            x: {
                                stacked: true
                            },
                            y: {
                                stacked: true,
                                beginAtZero: true,
                                ticks: { stepSize: 1 }
                            }
                        }
                    }
                });
            }
            
            // Chart 3: Individual charts for each location - REMOVED
            /*
            let locationChartsHTML = '';
            locationsArray.forEach((location, i) => {
                locationChartsHTML += `
                    <div class="chart-container full-width">
                        <div class="interactive-badge" title="Click on any bar to see lead details"></div>
                        <h3>Daily Leads: ${location}</h3>
                        <div class="chart-wrapper">
                            <canvas id="leadsTimelineLocation${i}Chart"></canvas>
                        </div>
                    </div>
                `;
            });
            document.getElementById('leadsTimelineByLocation').innerHTML = locationChartsHTML;
            
            // Render individual location charts
            locationsArray.forEach((location, i) => {
                const canvas = document.getElementById(`leadsTimelineLocation${i}Chart`);
                if (canvas) {
                    const chartKey = `leadsTimelineLocation${i}`;
                    destroyChart(chartKey);
                    const ctx = canvas.getContext('2d');
                    
                    const colors = ['#013160', '#71BED2', '#FBB514', '#28a745', '#dc3545', '#ffc107', '#9c27b0', '#ff5722'];
                    
                    allCharts[chartKey] = new Chart(ctx, {
                        type: 'bar',
                        data: {
                            labels: sortedDates.map(d => new Date(d).toLocaleDateString('en-US', { month: 'short', day: 'numeric' })),
                            datasets: [{
                                label: 'Daily Leads',
                                data: sortedDates.map(d => leadsByLocationAndDate[location][d]?.count || 0),
                                backgroundColor: colors[i % colors.length],
                                borderColor: colors[i % colors.length],
                                borderWidth: 1
                            }]
                        },
                        options: {
                            responsive: true,
                            maintainAspectRatio: false,
                            onClick: (event, elements) => {
                                if (elements.length > 0) {
                                    const index = elements[0].index;
                                    const date = sortedDates[index];
                                    const leads = leadsByLocationAndDate[location][date]?.leads || [];
                                    showLeadsTimelineDetails(date, leads, location);
                                }
                            },
                            plugins: {
                                legend: { display: false }
                            },
                            scales: {
                                y: {
                                    beginAtZero: true,
                                    ticks: { stepSize: 1 }
                                }
                            }
                        }
                    });
                }
            });
            */
        }
        
        // Show lead details when clicking on timeline chart
        function showLeadsTimelineDetails(date, leads, location) {
            if (!leads || leads.length === 0) return;
            
            const dateObj = new Date(date);
            const formattedDate = `${String(dateObj.getMonth() + 1).padStart(2, '0')}/${String(dateObj.getDate()).padStart(2, '0')}/${dateObj.getFullYear()}`;
            
            let html = `<h3>${location} - ${formattedDate}</h3>`;
            html += `<p style="margin: 10px 0; color: #666;"><strong>${formatNumber(leads.length)}</strong> lead(s) joined on this date</p>`;
            
            // Count converted vs not converted
            const converted = leads.filter(l => {
                const convertedTo = (l['Converted to'] || '').trim();
                return convertedTo && convertedTo !== 'N/A' && convertedTo !== '';
            }).length;
            
            html += `<p style="margin: 10px 0;"><strong>Converted:</strong> ${converted} of ${leads.length} (${((converted/leads.length)*100).toFixed(1)}%)</p>`;
            
            html += '<div class="table-container" style="max-height: 400px; overflow-y: auto;">';
            html += '<table><thead><tr>';
            html += '<th>Name</th><th>Source</th><th>Converted To</th><th>LTV</th>';
            html += '</tr></thead><tbody>';
            
            leads.forEach(lead => {
                const convertedTo = lead['Converted to'] || 'N/A';
                const isConverted = convertedTo !== 'N/A';
                const ltv = parseLTV(lead['LTV']);
                
                html += '<tr>';
                html += `<td>${lead['First Name']} ${lead['Last Name']}</td>`;
                html += `<td>${lead['Lead source'] || 'Unknown'}</td>`;
                html += `<td><span style="padding: 4px 8px; border-radius: 4px; background: ${isConverted ? '#d4edda' : '#f8d7da'}; color: ${isConverted ? '#155724' : '#721c24'};">${convertedTo}</span></td>`;
                html += `<td>${formatCurrency(ltv)}</td>`;
                html += '</tr>';
            });
            
            html += '</tbody></table></div>';
            
            // Add summary stats
            const totalLTV = leads.reduce((sum, l) => sum + (parseLTV(l['LTV'])), 0);
            const avgLTV = converted > 0 ? totalLTV / converted : 0;
            
            html += `<div style="margin-top: 20px; padding: 15px; background: #f8f9fa; border-radius: 8px;">`;
            html += `<strong>Summary:</strong> Total LTV: ${formatCurrency(totalLTV)} | Avg LTV: ${formatCurrency(avgLTV)}`;
            html += `</div>`;
            
            showModal(`Leads Details: ${location} - ${formattedDate}`, html);
        }
        
        // Show lead details when clicking on source chart
        function showLeadsSourceDetails(source, leads) {
            if (!leads || leads.length === 0) return;
            
            let html = `<h3>Leads from: ${source}</h3>`;
            html += `<p style="margin: 10px 0; color: #666;"><strong>${formatNumber(leads.length)}</strong> lead(s) from this source</p>`;
            
            // Count converted vs not converted
            const converted = leads.filter(l => {
                const convertedTo = (l['Converted to'] || (l['Type'] === 'Customer' ? 'Yes' : '')).trim();
                return convertedTo && convertedTo !== 'N/A' && convertedTo !== '';
            }).length;
            
            html += `<p style="margin: 10px 0;"><strong>Converted:</strong> ${converted} of ${leads.length} (${((converted/leads.length)*100).toFixed(1)}%)</p>`;
            
            // Group by location
            const byLocation = {};
            leads.forEach(l => {
                const location = l['Home location'] || 'Unknown';
                if (!byLocation[location]) byLocation[location] = 0;
                byLocation[location]++;
            });
            
            // Sort leads by date descending
            const sortedLeads = [...leads].sort((a, b) => {
                const dateA = parseDate(a['Converted'] || a['Join date']);
                const dateB = parseDate(b['Converted'] || b['Join date']);
                if (!dateA && !dateB) return 0;
                if (!dateA) return 1;
                if (!dateB) return -1;
                return dateB - dateA; // Descending
            });
            
            html += '<div class="table-container" style="max-height: 400px; overflow-y: auto;">';
            html += '<table><thead><tr>';
            html += '<th>Name</th><th>Date</th><th>Converted To</th><th>LTV</th>';
            html += '</tr></thead><tbody>';
            
            sortedLeads.forEach(lead => {
                const convertedTo = lead['Converted to'] || (lead['Type'] === 'Customer' ? 'Customer' : 'Lead');
                const isConverted = lead['Type'] === 'Customer' || (convertedTo !== 'N/A' && convertedTo !== 'Lead');
                const ltv = parseLTV(lead['LTV']);
                const date = parseDate(lead['Converted'] || lead['Join date']);
                const dateStr = date ? `${String(date.getMonth() + 1).padStart(2, '0')}/${String(date.getDate()).padStart(2, '0')}/${date.getFullYear()}` : 'N/A';
                
                html += '<tr>';
                html += `<td>${lead['First Name'] || lead['First name'] || ''} ${lead['Last Name'] || lead['Last name'] || ''}</td>`;
                html += `<td>${dateStr}</td>`;
                html += `<td><span style="padding: 4px 8px; border-radius: 4px; background: ${isConverted ? '#d4edda' : '#f8d7da'}; color: ${isConverted ? '#155724' : '#721c24'};">${convertedTo}</span></td>`;
                html += `<td>${formatCurrency(ltv)}</td>`;
                html += '</tr>';
            });
            
            html += '</tbody></table></div>';
            
            // Add summary stats with location breakdown
            const totalLTV = leads.reduce((sum, l) => sum + (parseLTV(l['LTV'])), 0);
            const avgLTV = converted > 0 ? totalLTV / converted : 0;
            
            // Sort locations by count descending
            const sortedLocations = Object.entries(byLocation).sort((a, b) => b[1] - a[1]);
            
            html += `<div style="margin-top: 20px; padding: 15px; background: #f8f9fa; border-radius: 8px;">`;
            html += `<div style="display: grid; grid-template-columns: repeat(3, 1fr); gap: 15px; margin-bottom: 15px;">`;
            html += `<div><strong>Total LTV:</strong><br>${formatCurrency(totalLTV)}</div>`;
            html += `<div><strong>Avg LTV:</strong><br>${formatCurrency(avgLTV)}</div>`;
            html += `<div><strong>Locations:</strong><br>${Object.keys(byLocation).length}</div>`;
            html += `</div>`;
            
            // Add location breakdown
            html += `<div style="border-top: 1px solid #ddd; padding-top: 10px; margin-top: 10px;">`;
            html += `<strong>Location Breakdown:</strong><br>`;
            html += `<div style="display: grid; grid-template-columns: repeat(auto-fill, minmax(200px, 1fr)); gap: 8px; margin-top: 8px;">`;
            sortedLocations.forEach(([location, count]) => {
                const percentage = ((count / leads.length) * 100).toFixed(1);
                html += `<div style="padding: 6px 10px; background: white; border-radius: 4px; border: 1px solid #ddd;">`;
                html += `<strong>${location}:</strong> ${count} (${percentage}%)`;
                html += `</div>`;
            });
            html += `</div></div>`;
            html += `</div>`;
            
            showModal(`Lead Source Details: ${source}`, html);
        }
    
        // Modal control functions
        function openSettingsModal() {
            document.getElementById('settingsModal').classList.add('show');
            document.body.style.overflow = 'hidden';
        }

        function closeSettingsModal() {
            document.getElementById('settingsModal').classList.remove('show');
            document.body.style.overflow = 'auto';
            document.getElementById('franchiseSettingsStatus').innerHTML = '';
        }

        window.openUploadModal = function() {
            document.getElementById('uploadModal').classList.add('show');
            document.body.style.overflow = 'hidden';
            updateDateFilterStatus();
        }
        
        function updateDateFilterStatus() {
            const statusDiv = document.getElementById('dateFilterStatus');
            const displaySpan = document.getElementById('dateFilterDisplay');
            
            if (CONFIG.notBeforeDate) {
                const date = new Date(CONFIG.notBeforeDate);
                const formattedDate = date.toLocaleDateString('en-US', { 
                    year: 'numeric', 
                    month: 'long', 
                    day: 'numeric' 
                });
                displaySpan.textContent = formattedDate;
                statusDiv.style.display = 'block';
            } else {
                statusDiv.style.display = 'none';
            }
        }

        window.closeUploadModal = function() {
            document.getElementById('uploadModal').classList.remove('show');
            document.body.style.overflow = 'auto';
        }
        
        function hideEmptyState() {
            document.getElementById('emptyState').style.display = 'none';
            document.getElementById('mainContent').style.display = 'block';
            document.getElementById('uploadBadge').style.display = 'none';
            document.getElementById('uploadBtn').classList.remove('highlight');
        }

        function showEmptyState() {
            document.getElementById('emptyState').style.display = 'block';
            document.getElementById('mainContent').style.display = 'none';
            document.getElementById('uploadBadge').style.display = 'block';
            document.getElementById('uploadBtn').classList.add('highlight');
        }

</script>
    
    <!-- Footer -->
    <div class="dashboard-footer">
        <div class="footer-content">
            <span class="footer-version">v2.20251114.11</span>
            <span class="footer-separator">|</span>
            <span class="footer-credits">Made by bonJoeV with ‚ù§Ô∏è</span>
        </div>
    </div>
</body>
</html>
